

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="南行">
  <meta name="keywords" content="">
  
    <meta name="description" content="基本概念各种平台有不同的内存分配器可用：  dlmalloc – 通用分配器 Ptmalloc2 – glibc jemalloc – FreeBSD 和 Firefox tcmalloc – Google libumem – Solaris  历史上ptmalloc2 是从 dlmalloc 派生而来的。在 fork 之后，添加了线程支持，并于 2006 年发布。在正式发布后，ptmalloc2">
<meta property="og:type" content="article">
<meta property="og:title" content="Ptmalloc2内存管理分析">
<meta property="og:url" content="http://nanhang.top/2025/07/01/ctf/heap/ptmalloc/index.html">
<meta property="og:site_name" content="南行的一座山">
<meta property="og:description" content="基本概念各种平台有不同的内存分配器可用：  dlmalloc – 通用分配器 Ptmalloc2 – glibc jemalloc – FreeBSD 和 Firefox tcmalloc – Google libumem – Solaris  历史上ptmalloc2 是从 dlmalloc 派生而来的。在 fork 之后，添加了线程支持，并于 2006 年发布。在正式发布后，ptmalloc2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250411183214.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115151.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115205.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115231.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115251.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115326.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115428.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115440.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115451.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115500.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115512.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115524.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115537.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115549.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020250330115603.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105124201.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241119212358.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105161925.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105165455.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105171119.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241120082430.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241120084426.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105173944.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105174727.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105174830.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105174844.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241208111115.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241208111123.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105180409.png">
<meta property="og:image" content="http://nanhang.top/assets/Pasted%20image%2020241105210106.png">
<meta property="article:published_time" content="2025-07-01T01:51:01.000Z">
<meta property="article:modified_time" content="2025-07-01T02:00:34.208Z">
<meta property="article:author" content="南行">
<meta property="article:tag" content="Heap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://nanhang.top/assets/Pasted%20image%2020250411183214.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Ptmalloc2内存管理分析 - 南行的一座山</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"nanhang.top","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="南行的一座山" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>南行的一座山</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml" target="_self">
                <i class="iconfont icon-rss"></i>
                <span>RSS</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Ptmalloc2内存管理分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-01 09:51" pubdate>
          2025年7月1日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          140 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Ptmalloc2内存管理分析</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>各种平台有不同的内存分配器可用：</p>
<ul>
<li>dlmalloc – 通用分配器</li>
<li>Ptmalloc2 – glibc</li>
<li>jemalloc – FreeBSD 和 Firefox</li>
<li>tcmalloc – Google</li>
<li>libumem – Solaris</li>
</ul>
<p>历史上<a target="_blank" rel="noopener" href="http://www.malloc.de/en/">ptmalloc2</a> 是从 <a target="_blank" rel="noopener" href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> 派生而来的。在 fork 之后，添加了线程支持，并于 2006 年发布。在正式发布后，ptmalloc2 被集成到 glibc 源代码中。集成后，将直接对 glibc malloc 源代码本身进行代码更改。因此，ptmalloc2 和 glibc 的 malloc 实现之间可能会有很多变化。</p>
<p><img src="/assets/Pasted%20image%2020250411183214.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>线程：</strong> 在 Linux 的早期，dlmalloc 被用作默认内存分配器。但后来由于 ptmalloc2 的多线程支持，它成为 linux 的默认内存分配器。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在 dlmalloc 中，当两个线程同时调用 malloc 时，只有一个线程可以进入关键部分，因为空闲列表数据结构在所有可用线程之间共享。因此，在多线程应用程序中，内存分配需要时间，从而导致性能下降。而在 ptmalloc2 中，当两个线程同时调用 malloc 时，会立即分配内存，因为每个线程都维护一个单独的堆段，因此维护这些堆的自由列表数据结构也是独立的。这种为每个线程维护单独的堆和空闲列表数据结构的行为称为 <strong>per thread arena</strong>。</p>
<ul>
<li>静态内存管理</li>
</ul>
<p>静态内存管理是指在编译时确定内存分配，并且内存分配的大小和生命周期在程序运行时保持不变。比如我们编程时的静态变量和全局变量就属于静态内存管理，好处是快速，缺点是不够灵活。</p>
<ul>
<li>动态内存管理</li>
</ul>
<p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理。</p>
<ul>
<li>一块内存</li>
<li>几种数据结构</li>
<li>一些安全机制</li>
<li>动态分配和回收</li>
<li>提高利用率</li>
<li>减少碎片化</li>
</ul>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ol>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以用来响应新申请的内存的请求。</li>
</ol>
<p><img src="/assets/Pasted%20image%2020250330115151.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115205.png" srcset="/img/loading.gif" lazyload></p>
<p>第一个malloc完成的时候，top chunk就存在了。</p>
<p>top chunk包含arena扩容的部分，不属于任何bin</p>
<p><img src="/assets/Pasted%20image%2020250330115231.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115251.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115326.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115428.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115440.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115451.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115500.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115512.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115524.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115537.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115549.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020250330115603.png" srcset="/img/loading.gif" lazyload></p>
<p>动态内存管理是指在程序运行时根据需要进行内存分配和释放，由程序员显式管理。这个最显著的例子就是我们的<code>malloc</code>和<code>free</code>函数。好处是灵活，缺点是复杂。</p>
<p>我们在编写 C 语言程序时<code>malloc</code>一块内存是由堆管理器（ptmalloc）分配了一块内存给我们使用，<code>malloc</code>返回的是指向那块内存的指针。</p>
<p>例如下面的代码，会将<code>malloc</code>分配的内存地址保存在<code>ptr</code>指针中，我们通过<code>ptr</code>指针来使用这块内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *ptr=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br></code></pre></td></tr></table></figure>

<p><code>malloc</code>通过 ptmalloc 向我们分配这块内存，而内存分配多少是由 ptmalloc 的分配机制来决定的。</p>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><ul>
<li>32位程序经典内存布局：<ul>
<li>最高地址的 1G 内存空间属于内核空间不能使用。</li>
<li>内核空间以下的空间属于栈，栈自顶向下增长，最大大小为 8M</li>
<li>栈以下便是<code>mmap</code>区域，空间向上增长，和栈相对。</li>
<li><code>heap</code>段自底向上增长。</li>
<li>剩下的空间属于可执行文件空间，即<code>bss</code>段、<code>data</code>段、<code>text</code>段</li>
</ul>
</li>
</ul>
<p><img src="/../assets/Pasted%20image%2020241105124201.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>64位程序经典内存布局：<ul>
<li>最高地址的 128TB 内存空间属于内核空间不能使用。</li>
<li>内核空间以下的空间属于栈，栈自顶向下增长，最大大小为 8M</li>
<li>栈以下便是<code>mmap</code>区域，空间向上增长，和栈相对。</li>
<li><code>heap</code>段自底向上增长。</li>
<li>剩下的空间属于可执行文件空间，即<code>bss</code>段、<code>data</code>段、<code>text</code>段</li>
</ul>
</li>
</ul>
<p>![[..&#x2F;..&#x2F;..&#x2F;RE&#x2F;assets&#x2F;assets&#x2F;Pasted image 20240630112911.png]]</p>
<h2 id="C语言内存操作函数"><a href="#C语言内存操作函数" class="headerlink" title="C语言内存操作函数"></a>C语言内存操作函数</h2><ul>
<li><code>malloc</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>realloc</code></li>
</ul>
<p>如果<code>ptr</code>为空，则<code>realloc</code>的行为类似于<code>malloc</code>。如果<code>size</code>为0，则它的行为类似于<code>free</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>calloc</code></li>
</ul>
<p>与<code>malloc</code>不同的是，<code>calloc</code>分配的内存会自动清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>free</code></li>
</ul>
<p>释放由<code>malloc</code>、<code>calloc</code>或<code>realloc</code>分配的内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure>


<h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><h3 id="brk和sbrk"><a href="#brk和sbrk" class="headerlink" title="brk和sbrk"></a>brk和sbrk</h3><p><code>brk</code>是系统调用，<code>sbrk</code>为库函数。系统调用负责提供一种最小功能，而库函数则提供比较复杂的功能。<code>malloc</code>函数族就是调用<code>sbrk</code>函数将数据段的下界移动分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">brk</span><span class="hljs-params">(<span class="hljs-type">void</span> *end_data_segment)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> increment)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><code>mmap</code>函数在 Linux 系统中主要作用是将文件或设备映射到进程的虚拟地址空间，也可以用于在不依赖文件的情况下分配匿名内存区域。</p>
<p><code>mmap</code>在内存分配中用于匿名映射，直接向操作系统请求内存，而不改变进程的堆区域。这样分配方式要比<code>brk</code>更灵活一点，适合分配较大的内存块。<code>malloc</code>函数的实现中，通过使用<code>mmap</code>分配超过一定大小（如128kb）的内存块。</p>
<p><code>munmap</code>函数用于将特定地址区域的对象映射删除掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure>


<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul>
<li>常用命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">vmmap #查看进程的内存布局<br>heap #查看所有堆<br>bins #查看所有bin<br>heap -v #查看堆块的详细信息<br>vis #可视化堆<br>arena #显示arena的详细信息<br>x/32gx &amp;main_arena #查看main_arena上的值<br>call malloc_stats() #打印malloc分配的内存<br>p malloc(0x100) #打印分配的堆块<br>heapbase #查看堆的起始地址<br>heapinfo #显示堆的信息<br>parseheap #显示堆结构<br>info threads #多线程调试<br>tracemalloc #会提示所有操作堆的地方<br>arenas #显示所有arena的基本信息<br>arenainfo #好看的显示所有arena的信息<br>p &amp;__free_hook #查看某个函数的真实地址<br>p *__free_hook #查看某个函数的指向<br></code></pre></td></tr></table></figure>

<p>个人比较喜欢通过<code>patchelf</code>修改程序<code>ld</code>和<code>libc</code>进行调试。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>glibc 的数据结构中有<code>tcache</code>机制和没有<code>tcache</code>机制是存在一些区别的。</p>
<p>这里我们会对比没有<code>tcache</code>机制的 glibc2.23 和 有<code>tcache</code>机制的 glibc2.27 的区别。</p>
<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p>在 ptmalloc 中使用<code>malloc_par</code>结构体来记录堆管理器的相关参数，该结构体定义于<code>malloc.c</code>中，如下：</p>
<ul>
<li>2.23</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-type">int</span> n_mmaps;<br>  <span class="hljs-type">int</span> n_mmaps_max;<br>  <span class="hljs-type">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-type">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  <span class="hljs-comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span><br>  <span class="hljs-comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span><br>  INTERNAL_SIZE_T max_mmapped_mem;<br>  INTERNAL_SIZE_T max_total_mem;  <span class="hljs-comment">/* only kept for NO_THREADS */</span><br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-type">char</span> *sbrk_base;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>2.27</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span>  </span><br><span class="hljs-class">&#123;</span>  <br>  <span class="hljs-comment">/* Tunable parameters */</span>  <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;  <br>  INTERNAL_SIZE_T top_pad;  <br>  INTERNAL_SIZE_T mmap_threshold;  <br>  INTERNAL_SIZE_T arena_test;  <br>  INTERNAL_SIZE_T arena_max;  <br>  <br>  <span class="hljs-comment">/* Memory map support */</span>  <br>  <span class="hljs-type">int</span> n_mmaps;  <br>  <span class="hljs-type">int</span> n_mmaps_max;  <br>  <span class="hljs-type">int</span> max_n_mmaps;  <br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets  </span><br><span class="hljs-comment">     it manually, at which point we need to disable any     </span><br><span class="hljs-comment">     dynamic behavior. */</span>  <br>  <span class="hljs-type">int</span> no_dyn_threshold;  <br>  <br>  <span class="hljs-comment">/* Statistics */</span>  <br>  INTERNAL_SIZE_T mmapped_mem;  <br>  INTERNAL_SIZE_T max_mmapped_mem;  <br>  <br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span>  <br>  <span class="hljs-type">char</span> *sbrk_base;  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE  </span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span>  <br>  <span class="hljs-type">size_t</span> tcache_bins;  <br>  <span class="hljs-type">size_t</span> tcache_max_bytes;  <br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span>  <br>  <span class="hljs-type">size_t</span> tcache_count;  <br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which  </span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span>  <br>  <span class="hljs-type">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>malloc_par</code>结构体定义了和<code>mmap</code>和<code>arena</code>相关的一些参数，以及<code>sbrk</code>的基址，其中重要的参数解释如下：</p>
<ul>
<li><code>top_pad</code>：初始化或扩展堆的时候需要多申请的内存大小。</li>
<li><code>mmap_threshold</code>：决定<code>sysmalloc</code>是通过<code>mmap</code>或<code>sbrk</code>分配内存的界限，即如果申请的内存大小不小于该值则采用<code>mmap</code>分配，否则采用<code>sbrk</code>扩展<code>heap</code>区域分配。并且这个值是动态调整的，如果释放的内存是通过<code>mmap</code>得到的则<code>mmap_threshold</code>与该内存大小取<code>max</code>。并且<code>mmap_threshold</code>最大不能超过<code>DEFAULT_MMAP_THRESHOLD_MAX</code>，即 0x2000000。</li>
<li><code>trim_threshold</code>：用于<code>main_arena</code>中保留内存量的控制。当释放的<code>chunk</code>为<code>mmap</code>获得的，同时大小大于<code>mmap_threshold</code>，则除了更新<code>mmap_threshold</code>外还会将<code>trim_threshold</code>乘2。当释放的<code>chunk</code>大小不在<code>fast bin</code>范围合并完<code>size</code>大于<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>即0x10000，会根据该字段缩小<code>top chunk</code>。</li>
<li><code>n_mmaps</code>：<code>mmap</code>的内存数量，即 ptmalloc 每次成功<code>mmap</code>则<code>n_mmpas</code>加 1，ptmalloc 每次成功<code>munmap</code>则<code>n_mmaps</code>减1。</li>
<li><code>n_mmaps_max</code>：<code>n_mmaps</code>的上限，即最多能<code>mmap</code>的内存数量。</li>
<li><code>max_n_mmaps</code>：<code>n_mmaps</code>达到过的最大值。</li>
<li><code>mmapped_mem</code>：当前<code>mmap</code>的内存大小总和。</li>
<li><code>max_mmapped_mem</code>：<code>mmap</code>的内存大小总和达到过的最大值。</li>
<li><code>sbrk_base</code>：表示通过<code>brk</code>系统调用申请的<code>heap</code>区域的起始地址。</li>
<li><code>no_dyn_threshold</code>：表示是否禁用<code>heap</code>动态调整保留内存的大小，默认为0。</li>
</ul>
<p>该结构体类型的实例<code>mp_</code>用以记录 ptmalloc 相关参数，同样定义于<code>malloc.h</code>中，如下：</p>
<ul>
<li>2.23</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>2.27</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span>  <br>&#123;  <br>  .top_pad = DEFAULT_TOP_PAD,  <br>  .n_mmaps_max = DEFAULT_MMAP_MAX,  <br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,  <br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))  </span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)  <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE  </span><br>  ,  <br>  .tcache_count = TCACHE_FILL_COUNT,  <br>  .tcache_bins = TCACHE_MAX_BINS,  <br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),  <br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 gdb 调试时我们可以通过<code>p mp_</code>命令查看该实例值。</p>
<p>或者可以通过<code>display mp_</code>命令来动态查看所有<code>malloc_par</code>字段的值</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p><code>heap_info</code>位于一个<code>heap</code>块的开头，用以记录通过<code>mmap</code>系统调用从 Memory Mapping Segment 处申请到的内存块的信息。定义于<code>arena.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A heap is a single contiguous memory region holding (coalesceable)</span><br><span class="hljs-comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span><br><span class="hljs-comment">   address aligned to HEAP_MAX_SIZE.  */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure>

<p><code>heap_info</code>结构体的成员如下：</p>
<ul>
<li><code>ar_ptr</code>：指向管理该堆块的<code>arena</code></li>
<li><code>prev</code>：该<code>heap_info</code>所链接的上一个<code>heap_info</code></li>
<li><code>size</code>：记录该堆块的大小</li>
<li><code>mprotect_size</code>：记录该堆块中被保护（<code>mprotected</code>）的大小。</li>
<li><code>pad</code>：即<code>padding</code>，用以在<code>SIZE_SZ</code>不正常的情况下进行填充以让内存对齐，正常情况下<code>pad</code>所占用空间应为0字节。</li>
</ul>
<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>大部分情况下对于每个线程而言其都会单独有着一个<code>arena</code>实例用以管理属于该线程的堆内存区域。</p>
<p><code>ptmalloc</code>内部的内存池是由<code>malloc_state</code>结构体进行定义的，即<code>arena</code>本身便为<code>malloc_state</code>的一个实例对象。</p>
<p><code>malloc_state</code>结构体定义于<code>malloc.c</code>中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  <span class="hljs-comment">//NFASTBINS宏用于计算fastbin数组的大小</span><br>  <span class="hljs-comment">//#define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span><br>  <br>  <span class="hljs-comment">//MAX_FAST_SIZE是glibc中定义的最大fastbin大小，通常为一个常量</span><br>  <span class="hljs-comment">//#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br>  <span class="hljs-comment">//64位下为160,32位为80  </span><br>  <br>  <span class="hljs-comment">//首先通过request2size将申请的内存大小转化为合适的chunk大小</span><br>  <span class="hljs-comment">/*#define request2size(req) \</span><br><span class="hljs-comment">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ? \</span><br><span class="hljs-comment">   MINSIZE : \</span><br><span class="hljs-comment">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-comment">//64位结果为172，32位结果为84</span><br>  <span class="hljs-comment">//然后通过fastbin_index计算chunk size对应的fastbin索引</span><br>  <span class="hljs-comment">//32位结果为9，64位结果也为9</span><br><br>  <span class="hljs-comment">//实际上fastbinY数组的大小是10，这是因为额外保留了一个位置用于其它特殊目的</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  <span class="hljs-comment">//NBINS是一个宏定义，值为128</span><br>  <span class="hljs-comment">//bins[254]</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-comment">//BINMAPSIZE (NBINS / BITSPERMAP)</span><br>  <span class="hljs-comment">//结果为4</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-comment">//指向下一个arena</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-comment">//指向下一个空闲内存区域的指针</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  <span class="hljs-comment">//在多线程内存管理中，记录当前有多少个线程与特定的arena相关联</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>2.27</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_lock_define (, mutex);  <br>  <br><span class="hljs-comment">/* Flags (formerly in max_fast).  */</span>  <br><span class="hljs-type">int</span> flags;  <br>  <br><span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span>  <br><span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span>  <br><span class="hljs-type">int</span> have_fastchunks;<br></code></pre></td></tr></table></figure>

<p><code>malloc_state</code>结构体的成员如下：</p>
<ul>
<li><code>mutex</code>：<code>mutex</code>变量即为多线程互斥锁，用以保证线程安全。</li>
<li><code>flags</code>：标志位，用以表示<code>arena</code>的一些状态，如：是否有<code>fastbin</code>、内存是否连续等。</li>
<li><code>fastbinY</code>：存放 fastbin chunk的数组，一共有10个fastbin chunk。</li>
<li><code>top</code>：指向<code>Top chunk</code>的指针。</li>
<li><code>last_remainder</code>：<code>chunk</code>切割中的剩余部分。<code>malloc</code>在分配<code>chunk</code>时若是没找到<code>size</code>合适的<code>chunk</code>而是找到了一个<code>size</code>更大的<code>chunk</code>，则会从大<code>chunk</code>中切割掉一块返回给用户，剩下的那一块便是<code>last_remainder</code>，其随后会被放入<code>unsorted bin</code>中。</li>
<li><code>bins</code>：存放闲置<code>chunk</code>的数组。<code>bins</code>包括<code>large bin</code>，<code>small bin</code>和<code>unsorted bin</code>。</li>
<li><code>binmap</code>：记录<code>bin</code>是否为空的<code>bitset</code>。需要注意的是<code>chunk</code>被取出后若一个<code>bin</code>空了并不会立即被置0，而会在下一次遍历到时重新置位。</li>
<li><code>system_mem</code>：记录当前<code>arena</code>在堆区中所分配到的内存的总大小。</li>
<li><code>max_system_mem</code>：当操作系统予进程以内存时，<code>system_mem</code>会随之增大，当内存被返还给操作系统时，<code>system_mem</code>会随之减小，<code>max_system_mem</code>变量便是用来记录在这个过程中<code>system_mem</code>的峰值。</li>
</ul>
<p>在gdb调试中我们可以通过<code>p &amp;main_arena</code>来查看<code>main arena</code></p>
<p><code>main_arena</code>为一个定义于<code>malloc.c</code>中的静态的<code>malloc_state</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span><br><span class="hljs-comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span><br><span class="hljs-comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span><br><span class="hljs-comment">   before using. This malloc relies on the property that malloc_state</span><br><span class="hljs-comment">   is initialized to all zeroes (as is true of C statics).  */</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由于其为 libc 中的静态变量，该<code>arena</code>会随着 libc 文件一同加载到 Memory Mapping Segment。因此在堆题中通常通过泄露<code>arena</code>的地址以获得 libc 在内存中的基地址。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>在程序执行的过程中，我们称由<code>malloc</code>申请的内存为<code>chunk</code>。这块内存在<code>ptmalloc</code>内部用<code>malloc_chunk</code>结构体来表示。当程序申请的<code>chunk</code>被<code>free</code>后，会被加入到相应的空闲管理链表中。</p>
<p>我们在malloc一块内存的时候返回给我们的指针是指向user data的指针</p>
<p><code>malloc_chunk</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>每个字段的具体的解释如下：</p>
<ul>
<li><code>prev_size</code>：如果物理相邻的前一地址<code>chunk</code>是空闲的话，那该字段记录的是前一个<code>chunk</code>的大小（包括<code>chunk</code>头）。否则，该字段可以用来存储物理相邻的前一个<code>chunk</code>的数据。</li>
<li><code>size</code>：该<code>chunk</code>的大小，大小必须是<code>2 * SIZE_SZ</code>的整数倍。该字段的低三个比特位对<code>chunk</code>的大小没有影响，它们从高到低分别表示为：<ul>
<li><code>NON_MAIN_ARENA</code>，记录当前<code>chunk</code>是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li><code>IS_MAPPED</code>，记录当前<code>chunk</code>是否是由<code>mmap</code>分配的。</li>
<li><code>PREV_INUSE</code>，记录前一个<code>chunk</code>块是否被分配。一般来说，堆中第一个被分配的内存块的<code>size</code>字段的<code>P</code>位都会被设置为 1，以便于防止访问前面的非法内存。当一个<code>chunk</code>的<code>size</code>的<code>P</code>位为0时，我们能通过<code>prev_size</code>字段来获取上一个<code>chunk</code>的大小以及地址。这也方便进行空闲<code>chunk</code>之间的合并。</li>
</ul>
</li>
<li><code>fd</code>，<code>bk</code>。<code>chunk</code>处于分配状态时，从<code>fd</code>字段开始是用户的数据。<code>chunk</code>空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul>
<li><code>fd</code>指向下一个（非物理相邻）空闲的<code>chunk</code></li>
<li><code>bk</code>指向上一个（非物理相邻）空闲的<code>chunk</code></li>
</ul>
</li>
</ul>
<p>通过<code>fd</code>和<code>bk</code>可以将空闲的<code>chunk</code>块加入到空闲的<code>chunk</code>块链表进行统一管理。</p>
<ul>
<li><code>fd_nextsize</code>，<code>bk_nextsize</code>，也是只有<code>chunk</code>空闲的时候才使用，不过其用于较大的<code>chunk</code>（large chunk）。<ul>
<li><code>fd_nextsize</code>：指向前一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含<code>bin</code>的头指针。</li>
<li><code>bk_nextsize</code>：指向后一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含<code>bin</code>的头指针。</li>
<li>一般空闲的<code>large chunk</code>在<code>fd</code>的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适<code>chunk</code>时挨个遍历。</li>
</ul>
</li>
</ul>
<p><code>chunk</code>的结构</p>
<p><img src="/assets/Pasted%20image%2020241119212358.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>用户释放掉的<code>chunk</code>不会马上归还给系统，ptmalloc 会统一管理<code>heap</code>和<code>mmap</code>映射区域中的空闲的<code>chunk</code>。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的<code>chunk</code>中挑选一块合适的给用户。这也可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的<code>chunk</code>进行管理。首先，它会根据空闲的<code>chunk</code>的大小以及使用状态将<code>chunk</code>初步分为4类：<code>fast bins</code>，<code>small bins</code>，<code>large bins</code>，<code>unsorted bin</code>。对于 libc2.27 及以上版本还有<code>tcache</code>。</p>
<p><strong>概述</strong></p>
<p>对于<code>small bins</code>，<code>large bins</code>，<code>unsorted bin</code>来说，ptmalloc 将它们维护在一个<code>bins</code>数组中。这些<code>bin</code>对应的数据结构在<code>malloc_state</code>中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS 128</span><br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure>

<p><code>bins</code>数组实际上可以看做是以<code>chunk</code>为单位，只不过采用空间复用策略，因为实际用到的只有<code>fd</code>和<code>bk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br></code></pre></td></tr></table></figure>

<p><img src="/../assets/Pasted%20image%2020241105161925.png" srcset="/img/loading.gif" lazyload></p>
<p>由于是双链表结构<code>bins</code>数组每连续两个<code>chunk</code>指针维护一个<code>bin</code>（即<code>fd</code>和<code>bk</code>），其结构如下图所示（64位）。其中 <code>small bins</code>中<code>chunk</code>大小已给出。<code>large bins</code>的每个<code>bin</code>中的<code>chunk</code>大小在一个范围内。</p>
<p><img src="/../assets/Pasted%20image%2020241105165455.png" srcset="/img/loading.gif" lazyload><br><code>lareg bin</code>的<code>chunk</code>范围如下：</p>
<p>大于<code>0x400</code>的<code>chunk</code>就会放到<code>large bin</code>中。</p>
<p>对于<code>fast bin</code>，在<code>malloc_state</code>又单独定义了一个<code>fastbinsY</code>的结构维护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	/* Fastbins */</span><br>	mfastbinptr fastbinY[ NFASBINS ];<br>*/<br></code></pre></td></tr></table></figure>

<p>由于<code>fast bin</code>为单链表结构，因此数组中第一个指针就可以维护一个<code>bin</code>。结构如图所示：</p>
<p><img src="/../assets/Pasted%20image%2020241105171119.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Fast Bin</strong></p>
<p>为了避免大部分时间花在了合并、分割以及中间检查的过程中影响效率，因此 ptmalloc 中专门设计了<code>fast bin</code>。</p>
<p><code>fast bin</code>采用单链表形式，结构如下图所示：</p>
<p><img src="/assets/Pasted%20image%2020241120082430.png" srcset="/img/loading.gif" lazyload></p>
<p><code>fast bin</code>有如下性质：</p>
<ul>
<li>由于采用单链表结构，<code>fast bin</code>采取 LIFO（后进先出）策略。</li>
<li>每个<code>fast bin</code>中维护的<code>chunk</code>大小确定，并且<code>fast bin</code>维护的最大的<code>chunk</code>为 128 字节（64位），因此不超过 0x80（chunk大小）的内存释放会进入<code>fast bin</code>。</li>
<li><code>fast bin</code>范围的<code>chunk</code>下一个相邻<code>chunk</code>的<code>PREV_INUSE</code>始终被置为1。因此它们不会和其它被释放的<code>chunk</code>合并。除非调用<code>malloc_consolidate</code>函数。</li>
</ul>
<p>安全检查：</p>
<ul>
<li><code>size</code>：在<code>malloc()</code>函数分配<code>fastbin size</code>范围的<code>chunk</code>时，若是对应的<code>fastbin</code>中有空闲<code>chunk</code>，在取出前会检查其<code>size</code>域与对应下标是否一致，不会检查标志位，若否便会触发<code>abort</code>。</li>
<li><code>double free</code>： 在<code>free()</code>函数中会对<code>fast bin</code>链表的头结点进行检查，若将要被放入<code>fast bin</code>中的<code>chunk</code>与对应下标的链表的头结点为同一<code>chunk</code>，则会触发<code>abort</code>。</li>
<li>Safe linking 机制（only glibc2.32 and up）：自 glibc 2.32 起引入了 safe-linking 机制，其核心思想是在链表上的<code>chunk</code>中并不直接存放其所连接的下一个<code>chunk</code>的地址，而是存放下一个<code>chunk</code>的地址与【<code>fd</code>指针自身地址右移 12 位】所异或得的值，使得攻击者在得知<code>chunk</code>的地址之前无法直接利用其构造任意地址写。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是<code>fastbin</code>的入口节点存放的仍是未经异或的<code>chunk</code>地址。</p>
<p>另外第一个加入<code>fast bin</code>的<code>chunk</code>的<code>fd</code>字段可以泄露堆地址（右移 12 位）。</p>
<p><strong>Small Bin</strong></p>
<p><code>small bin</code>采用双向链表，结构如下图所示。</p>
<p><img src="/assets/Pasted%20image%2020241120084426.png" srcset="/img/loading.gif" lazyload></p>
<p><code>small bin</code>有如下性质：</p>
<ul>
<li><code>small bins</code>中每个<code>bin</code>对应的链表采用 FIFO 的规则。</li>
<li>每个<code>small bin</code>维护的<code>chunk</code>大小确定，并且<code>small bin</code>维护的最大的<code>chunk</code>为1008字节（64位），即 0x3f0 的<code>chunk</code>大小。</li>
</ul>
<p><strong>Large Bin</strong></p>
<p><code>large bins</code>中一共包括64个<code>bin</code>，每个<code>bin</code>中的<code>chunk</code>的大小不一致，而是处于一定区间范围内。<code>large bin</code>的结构如下：</p>
<p><img src="/../assets/Pasted%20image%2020241105173944.png" srcset="/img/loading.gif" lazyload></p>
<p>关于<code>fd_nextsize</code>和<code>bk_nextsize</code>的机制，这里以<code>fd_nextsize</code>为例：</p>
<ul>
<li><code>fd_nextsize</code>和<code>bk_nextsize</code>与<code>bins</code>数组没有连接关系（这就解释了为什么<code>bins</code>上没有体现<code>fd_nextsize</code>和<code>bk_nextsize</code>结构）。</li>
<li><code>large bin</code>里的<code>chunk</code>在<code>fd</code>指针指向的方向上按照<code>chunk</code>大小降序排序。</li>
<li>当<code>large bin</code>里有一个<code>chunk</code>时，<code>fd_nextsize</code>和<code>bk_nextsize</code>指向自己（如上面<code>large bin</code>的结构图所示）。</li>
<li>当<code>large bin</code>里同一个大小的<code>chunk</code>有多个时，只有相同大小<code>chunk</code>中的第一个的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针有效，其余的<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设为<code>NULL</code>。</li>
</ul>
<p><img src="/../assets/Pasted%20image%2020241105174727.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>large bin</code>中有多个不同大小的<code>chunk</code>时<code>fd_nextsize</code>连接比它小的第一个<code>chunk</code>，<code>bk_nextsize</code>就是把<code>fd_nextsize</code>反过来连到对应结构上。</li>
</ul>
<p><img src="/../assets/Pasted%20image%2020241105174830.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>large bin</code>最小的一组 <code>chunk</code> 中的第一个 <code>chunk</code> 的 <code>fd_nextsize</code> 连接的是最大的 <code>chunk</code>，最大的 <code>chunk</code> 的 <code>bk_nextsize</code> 相反。</li>
</ul>
<p><img src="/../assets/Pasted%20image%2020241105174844.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>Unsorted Bin</strong></p>
<p><code>unsorted bin</code>可以视为空闲<code>chunk</code>回归其所属<code>bin</code>之前的缓冲区。像<code>small bin</code>一样采用双向链表维护。<code>chunk</code>大小乱序。</p>
<h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>程序第一次进行<code>malloc</code>的时候，<code>heap</code>会被分为两块，一块给用户，剩下的那块就是<code>top chunk</code>。其实，所谓的<code>top chunk</code>就是处于当前堆的物理地址最高的<code>chunk</code>。这个<code>chunk</code>不属于任何一个<code>bin</code>，它的作用在于当所有的<code>bin</code>都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的<code>top chunk</code>。否则，就对<code>heap</code>进行扩展后再进行分配。在<code>main_arena</code>中通过<code>sbrk</code>扩展<code>heap</code>，而在<code>threadarena</code>中通过<code>mmap</code>分配新的heap。</p>
<p>需要注意的是，<code>top chunk</code>的<code>prev_inuse</code>比特位始终为1，否则其前面的<code>chunk</code>就会被合并到<code>top chunk</code>中。</p>
<h3 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h3><p>在用户使用<code>malloc</code>请求分配内存时，ptmalloc2 找到的<code>chunk</code>可能并不和申请的内存大小一致，这时候就将剩余部分称之为<code>last remainder chunk</code>，<code>unsortbin</code>也会存这一块。<code>top chunk</code>分割剩下的部分不会作为<code>last_remainder</code>。</p>
<p>Mmaped chunk</p>
<ul>
<li><p>当需要分配的chunk足够大，而且fast bins和bins都不能满足要求，甚至top chunk本身也不能满足分配需求时，ptmalloc会使用mmap来直接使用内存映射来将页映射到进程空间。</p>
</li>
<li><p>这样分配的chunk在被free时将直接解除映射，于是就将内存归还给了操作系统，再次对这样的内存区的引用（UAF）将导致segmentation fault错误。</p>
</li>
<li><p>Main_arena有个mmap threshold分配阈值，初始默认为128KB。若请求分配小于阈值，而当前heap空间不够，则用sbrk()增大heap。如果请求超过阈值，或者sbrk()失败了，就用mmap映射一块内存。</p>
</li>
<li><p>Mmap分配阈值动态调整机制。</p>
</li>
</ul>
<h2 id="threads-arena"><a href="#threads-arena" class="headerlink" title="threads arena"></a>threads arena</h2><ul>
<li>每个进程只有一个主分配区(main_arena)，可能存在多个非主分配区(non_main_arena)：</li>
</ul>
<p> - x86: <code>2*number of cores + 1</code></p>
<p> - x64: <code>8*number of cores + 1</code></p>
<ul>
<li><p><code>main_arena</code>使用<code>brk</code>和<code>mmap</code>申请虚拟内存</p>
<ul>
<li><code>mmap</code>分配的内存一律通过<code>munmap</code>返还</li>
<li>只有一个heap</li>
</ul>
</li>
<li><p><code>non_main_arena</code>只能用<code>mmap</code></p>
<ul>
<li>每次用<code>mmap</code>向系统批发<code>HEAP_MAX_SIZE</code>(32位1MB,64位64MB)，对象请求时再零售</li>
<li>当前<code>heap</code>不够用，<code>mmap</code>再次申请<code>heap</code>，所以可以包含多个<code>heaps</code></li>
</ul>
</li>
</ul>
<h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2* 核心数 + 1&#x3D; 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？  </p>
<p>当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</p>
<p>当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</p>
<p>1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</p>
<p>2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</p>
<p>3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</p>
<p>这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</p>
<p><img src="/assets/Pasted%20image%2020241208111115.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/assets/Pasted%20image%2020241208111123.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="tcache机制"><a href="#tcache机制" class="headerlink" title="tcache机制"></a>tcache机制</h2><p><code>tcache</code> 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能，与<code>fast bin</code>类似。<code>tcache</code> 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code> 。</p>
<p><code>tcache_entry</code> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于链接空闲的<code>chunk</code>结构体，其中的<code>next</code>指针指向下一个大小相同的<code>chunk</code>。需要注意的是这里的<code>next</code>指向<code>chunk</code>的<code>user data</code>，而<code>fast bin</code>的<code>fd</code>指向<code>chunk</code>开头的地址。而且，<code>tcache_entry</code> 会复用空闲 <code>chunk</code> 的<code>user data</code>部分。</p>
<p><code>tcache_perthread_struct</code> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>对应结构如下</p>
<p><img src="/../assets/Pasted%20image%2020241105180409.png" srcset="/img/loading.gif" lazyload><br>每个<code>thread</code>都会维护一个 <code>tcache_perthread_struct</code> ，它是整个 <code>tcache</code> 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code> 项 <code>tcache_entry</code>。这个结构在 <code>tcache_init</code> 函数中被初始化在堆上，大小为 0x250（高版本为 0x290）。其中数据部分前 0x40 为 <code>counts</code> ，剩下的为 <code>entries</code> 结构。如果能控制这个堆块就可以控制整个 <code>tcache</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>  <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br><br>  arena_get (ar_ptr, bytes);<br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>    <br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br><br>  <span class="hljs-keyword">if</span> (victim)<br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>tcache_perthread_struct</code> 中的 <code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（<code>free</code> 后）的 <code>chunk</code>，这一点上和 fast bin 很像。</p>
<p>另外与<code>fast bin</code>相同的是释放进入 <code>tcache</code> 的 <code>chunk</code> 的下一个相邻 <code>chunk</code> 的 <code>PREV_INUSE</code> 位不清零。</p>
<p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 <code>chunk</code> 的数目，每条链上最多可以有 7 个 <code>chunk</code> 。注意指针指向的位置是 <code>fd</code> 指针，这一点与<code>fast bin</code>不同。<br>结构如下：</p>
<p><img src="/../assets/Pasted%20image%2020241105210106.png" srcset="/img/loading.gif" lazyload></p>
<p>stash 机制：</p>
<p>当申请的大小在 <code>tcache</code> 范围的 <code>chunk</code> 在 <code>tcache</code> 中没有，此时 ptmalloc 会在其他 <code>bin</code> 里面找，如果找到了会将该 <code>chunk</code> 放到 <code>tcache</code> 中，直到 <code>tcache</code> 填满，最后直接返回找到的 <code>chunk</code> 或是从 <code>tcache</code> 中取出并返回。</p>
<p>安全检查：</p>
<ul>
<li>tcache key（only libc2.29 and up）：自 glibc2.29 版本起 <code>tcache</code> 新增了一个 key 字段，该字段位于 <code>chunk</code> 的 bk 字段，值为 <code>tcache</code> 结构体的地址，若 <code>free()</code> 检测到 <code>chunk-&gt;bk == tcache</code> 则会遍历 <code>tcache</code> 查找对应链表中是否有该 <code>chunk</code><br>  最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</li>
<li>Safe linking 机制（only glibc2.32 and up）：与<code>fast bin</code>类似。<br>  绕过方法：<ul>
<li>在 <code>tcache</code> 的一个 <code>entry</code> 中放入第一个 <code>chunk</code> 时，其同样会对该 <code>entry</code> 中的 “<code>chunk</code>” （NULL）进行异或运算后写入到将放入 <code>tcache</code> 中的 <code>chunk</code> 的 <code>fd</code> 字段，若是我们能够打印该 free chunk 的 <code>fd</code> 字段，便能够直接获得未经异或运算的堆上相关地址（右移 12 位）</li>
<li>在 <code>tcache-&gt;entry</code> 中存放的仍是未经加密过的地址，若是我们能够控制 <code>tcache</code> 管理器则仍可以在不知道堆相关地址时进行任意地址写。</li>
</ul>
</li>
</ul>
<h2 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2><ul>
<li>我们调用<code>malloc</code>函数分配一块内存给一个指针时，实际上我们是调用了<code>_libc_malloc</code>函数。</li>
<li>首先会在<code>_libc_malloc</code>函数中判断<code>__malloc_hook</code>函数指针是否为空，如果不为空则调用<code>__malloc_hook</code>函数指针（glibc2.34已删除）。</li>
<li>如果<code>glibc</code>存在<code>tcache</code>且有相应大小的<code>chunk</code>则将其从<code>tcache</code>中取出并返回结果。</li>
<li>如果没有<code>tcache</code>或其中不存在相应的<code>chunk</code>，则调用<code>_int_malloc</code>函数申请内存。<ul>
<li>首先把申请的内存的字节数转化为<code>chunk</code>的大小。</li>
<li>如果<code>arena</code>未初始化，则调用<code>sysmalloc</code>向系统申请内存，然后将获取的<code>chunk</code>返回。</li>
<li>如果申请的<code>chunk</code>大小不超过<code>fast bin</code>的最大值，则尝试从对应的<code>fast bin</code>的头部获取<code>chunk</code>。在获取到<code>chunk</code>后，如果对应的<code>fast bin</code>还有<code>chunk</code>并且大小在<code>tcache</code>范围就将它们依次从头结点取出放到<code>tcache</code>中，直到把<code>tcache</code>填满。最后将申请到的<code>chunk</code>返回。</li>
<li>如果申请的<code>chunk</code>在<code>large bin</code>大小范围则调用<code>malloc_consolidate</code>函数将<code>fast bin</code>中的<code>chunk</code>合并后放入 <code>unsorted bin</code>。</li>
<li>循环进行如下操作：<ul>
<li>循环取<code>unsorted bin</code>最后一个<code>chunk</code>。<ul>
<li>如果用户的请求为<code>small bin chunk</code>，那么我们首先考虑<code>last remainder</code>，如果当前<code>chunk</code>是<code>last remainder</code>，且<code>last remainder</code>是<code>unsorted bin</code>中的唯一一个<code>chunk</code>，并且<code>last remainder</code>的大小分割后还可以作为一个<code>chunk</code>，则从<code>last remainder</code>中切下一块内存返回。</li>
<li>如果<code>chunk</code>的大小恰好等于申请的<code>chunk</code>大小，则如果该内存大小在 tcache 范围且 tcache 没有满，则先将其放入<code>tcache</code>，之后会考虑从<code>tcache</code>中找<code>chunk</code>。否则直接将找到的<code>chunk</code>返回。</li>
<li>根据<code>chunk</code>的大小将其放入<code>small bin</code>或<code>large bin</code>中。对于<code>small bin</code>直接从链表头部加入；对于 <code>large bin</code>，首先特判加入链表尾部的情况，如果不在链表尾部则从头部遍历找位置，如果<code>large bin</code>中有与加入的<code>chunk</code>大小相同的<code>chunk</code>，则加入到第一个相等<code>chunk</code>后面，否则加到合适位置后还需要更新 nextsize 指针。</li>
<li>尝试从<code>tcache</code>找<code>chunk</code>。</li>
<li>如果循环超过 10000 次就跳出循环。</li>
</ul>
</li>
<li>尝试从<code>tcache</code>找<code>chunk</code>。</li>
<li>如果申请<code>chunk</code>大小不在<code>small bin</code>范围，则从后往前遍历对应<code>large bin</code>，找到第一个不小于申请 chunk 大小的 chunk。为了 unlink 时避免修改 nextsize 的操作，如果存在多个合适的 chunk 则选择第二个 chunk。如果选取的 chunk 比申请的 chunk 大不少于 MINSIZE，则需要将多出来的部分切出来作为 <code>remainder</code>，并将其加入<code>unsorted bin</code>头部。然后将获取的<code>chunk</code>返回。</li>
<li>找一个<code>chunk</code>范围比申请<code>chunk</code>大的非空<code>bin</code>里面找最后一个<code>chunk</code>，这个过程用 binmap 优化，同时也可以更新 <code>binmap</code> 的状态。这个<code>chunk</code>上切下所需的<code>chunk</code>，剩余部分放入<code>unsorted bin</code>头部。然后将获取的<code>chunk</code>返回。</li>
<li>如果<code>top chunk</code>切下所需<code>chunk</code>后剩余部分还是不小于 <code>MINSIZE</code> 则从<code>top chunk</code>上切下所需 <code>chunk</code> 返回。</li>
<li>如果<code>fast bins</code>还有<code>chunk</code>则调用<code>malloc_consolidate</code>合并<code>fast bin</code>中的<code>chunk</code>并放入<code>unsorted bin</code>中，然后继续循环。</li>
<li>如果<code>fast bins</code>还有<code>chunk</code>则调用<code>malloc_consolidate</code>合并<code>fast bin</code>中的<code>chunk</code>并放入 <code>unsorted bin</code>中，然后继续循环。</li>
<li>最后<code>sysmalloc</code>系统调用向操作系统申请内存分配<code>chunk</code>。<ul>
<li>如果<code>arena</code>没有初始化或者申请的内存大于<code>mp_.mmap_threshold</code>，并且<code>mmap</code>的次数小于最大值，则使用<code>mmap</code>申请内存。然后检查一下是否16字节对齐然后更新<code>mmap</code>次数和<code>mmap</code>申请过的最大内存大小后就将<code>chunk</code>返回。</li>
<li>如果<code>arena</code>没有初始化就返回0。</li>
<li>对之前的<code>top chunk</code>进行检查，如果是 dummy top的话，因为是用<code>unsorted bin</code>表示的，因此 top chunk 的大小需要是0。否则堆的大小应该不小于 MINSIZE ，并且前一个堆块一个处于使用中，并且堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为0.初次之外，<code>top chunk</code>大小必须比申请<code>chunk</code>大小加上 MINSIZE 要小。</li>
<li>如果<code>arena</code>不是<code>main_arena</code><ul>
<li>尝试将<code>top chunk</code>所在的<code>heap</code>扩展大小，如果成功则更新<code>arena</code>记录的内存总大小 <code>system_mem</code>和<code>top chunk</code>大小。</li>
<li>尝试申请一个新的<code>heap</code>。设置新的<code>heap</code>以及<code>arena</code>的参数并且将原来的<code>top chunk</code>先从尾部切下 2 个0x10大小的<code>chunk</code>，剩余部分如果不小于 MINSIZE 则将其释放掉。</li>
<li>否则，如果前面没有执行到<code>mmap</code>申请<code>chunk</code>的分支就尝试执行。</li>
</ul>
</li>
<li>如果<code>arena</code>是 <code>main arena</code><ul>
<li>计算需要获取的内存大小。需要获取的内存大小等于申请的<code>chunk</code>大小加上0x20000和MINSIZE。如果堆空间连续，则可以再减去原来内存的大小。然后将需要获取的内存大小与页对齐。</li>
<li><code>sbrk</code>扩展内存如果成功则会尝试调用一个 hook 函数，否则<code>mmap</code>申请内存，然后<code>brk</code>移到申请的内存处并设置堆不连续参数。</li>
<li>如果成功获取到内存，则更新<code>arena</code>记录的内存总大小<code>system_mem</code>和<code>sbrk_base</code>。之后对一系列的情况进行处理，在这期间，之前的<code>top chunk</code>会被从尾部切下两个 0x10 大小的<code>chunk</code>，剩余部分如果不小于<code>MINSIZE</code>则将其释放掉。</li>
</ul>
</li>
<li>最后从新获取的<code>top chunk</code>切下所需的<code>chunk</code>并返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>如果前一个 chunk 处于使用状态，那么不需要去通过链表串起来，所以当前 chunk 也就不需要 prev_size，当申请的内存大小对 2 * size_t 取余之后比 size_t 小于等于的话就可以用它的下一个 chunk 的 prev_size</p>
<p>还是 64 位下，如果大小是 0x49 的话取余之后还差 0x5，那就没法用了，只能多申请一块，最后加上 chunk header 用了 0x60</p>
<p>内存对齐</p>
<table>
<thead>
<tr>
<th>机器类型</th>
<th>64位</th>
<th>32位</th>
</tr>
</thead>
<tbody><tr>
<td>对齐位数</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>size_t</td>
<td>8</td>
<td>4</td>
</tr>
</tbody></table>
<h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a><code>__libc_malloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br><span class="hljs-comment">//定义了一个指向arena的指针，用于内存分配</span><br>  mstate ar_ptr;<br><br><span class="hljs-comment">//用于存储最终返回的分配内存地址</span><br>  <span class="hljs-type">void</span> *victim;<br><br><span class="hljs-comment">//检查自定义malloc钩子</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//获取本线程对应的arena，即malloc_state结构体</span><br>  arena_get (ar_ptr, bytes);<br><br><span class="hljs-comment">//调用_int_malloc申请内存</span><br><span class="hljs-comment">//参数ar_ptr指向arena，参数bytes为申请的字节数</span><br>  victim = _int_malloc (ar_ptr, bytes);<br><br><span class="hljs-comment">//若在当前arena中分配失败，且ar_ptr非空，会调用arena_get_retry获取其他arena进行重试。</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br><span class="hljs-comment">//在完成分配或失败后，释放该arena的互斥锁，确保其它线程可以访问此arena</span><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br><span class="hljs-comment">//通过条件验证分配，不满足则直接崩溃</span><br><span class="hljs-comment">//1.是否没有申请成功内存返回是空</span><br><span class="hljs-comment">//2.该chunk是否是通过mmap分配的内存块</span><br><span class="hljs-comment">//3.判断arean指针和mainarena是否匹配</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//返回申请到的内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a><code>_int_malloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* 请求的chunk_size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* 对应bin数组中的index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* 指向对应bin的指针 */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* 指向分配的chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* 分配的chunk的size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* 分配的chunk的bin的index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* 指向分割后剩下的那块chunk */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* 分割后剩下的那块chunk的size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverse */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* 一个block值 */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* 用于链表操作 */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* 用于链表操作 */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//报错字符串指针</span><br><br>  checked_request2size (bytes, nb); <span class="hljs-comment">//将申请内存的字节数转换为合适的chunk size存入nb</span><br><br><span class="hljs-comment">//检查是否有可用的arena</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>	  <span class="hljs-comment">//无可用的arena，使用sysmalloc获取内存</span><br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>      <span class="hljs-comment">//内存分配成功则对内存进行扰动处理，即填充内存特定字节</span><br>	alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br> <span class="hljs-comment">//要分配的chunk size小于等于global_max_fast则先从fastbin中寻找</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<span class="hljs-comment">//get_max_fast用于获取global_max_fast</span><br>    &#123;<br>	  <span class="hljs-comment">//通过size计算其在fastbin中对应的索引然后存入idx</span><br>      idx = fastbin_index (nb);<br>      <span class="hljs-comment">//通过idx获取arena的fastbin中对应的bin</span><br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      <span class="hljs-comment">//获取bin的首个chunk</span><br>      mchunkptr pp = *fb;<br><br><span class="hljs-comment">//这段代码在并发环境下，通过循环和原子操作安全地从自由链表中取出一个空闲块。它使用 catomic_compare_and_exchange_val_acq 来确保无锁访问的原子性，使得多个线程能够同时操作同一个自由链表而不会出现数据竞争。</span><br>      <span class="hljs-keyword">do</span><br>        &#123;<span class="hljs-comment">//将当前链表的头节点赋值给victim</span><br>          victim = pp;<br>          <span class="hljs-comment">//如果链表为空跳出循环</span><br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用CAS操作确保线程安全，如果fastbin的头指针未被其它线程修改，将下一个块的地址设置为链表新的头节点</span><br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>             != victim);<br><br><br>      <span class="hljs-comment">//此时victim是该fb原来的首个chunk，或者为0</span><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-comment">//如果victim的大小不符合当前fastbin的要求，则进行错误处理</span><br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>            <span class="hljs-comment">//错误处理</span><br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          <span class="hljs-comment">//检查victim块是否被重复分配或被修改，确保内存安全性。</span><br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">//将chunk块指针转换为user data的指针。</span><br><span class="hljs-comment">//#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          <span class="hljs-comment">//用于初始化内存块p，将其中的数据用固定字节填充。</span><br>          alloc_perturb (p, bytes);<br>          <span class="hljs-comment">//将分配出来的内存指针返回</span><br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//如果前面在fastbin中没有找到就会从smallbin中查找</span><br><span class="hljs-comment">//如果size小于largebin中最小的size那么就从smallbin中查找</span><br><span class="hljs-comment">/*#define in_smallbin_range(sz)  \</span><br><span class="hljs-comment">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)*/</span><br><br><span class="hljs-comment">//#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-comment">//#define NSMALLBINS         64  </span><br><span class="hljs-comment">//#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT  </span><br><span class="hljs-comment">//#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-comment">//MALLOC_ALIGNMENT (2 *SIZE_SZ)，32位为8字节，64位为16字节</span><br><span class="hljs-comment">//min_large_size为0x400</span><br><br>  <span class="hljs-comment">//该宏返回一个布尔值，如果sz小于min_large_size，则返回true</span><br>  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>    <br>	<span class="hljs-comment">/*smallbin_index(sz)</span><br><span class="hljs-comment">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))</span><br><span class="hljs-comment">  + SMALLBIN_CORRECTION)*/</span><br>	<br>	  <span class="hljs-comment">//根据size找到相应在smallbin中的下标</span><br>      idx = smallbin_index (nb);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">bin_at(m, i)</span><br><span class="hljs-comment">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))</span><br><span class="hljs-comment">  - offsetof (struct malloc_chunk, fd))</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//m-&gt;bins，获取bins数组</span><br> <span class="hljs-comment">//((i)-1)*2，索引i表示bin的编号</span><br> <span class="hljs-comment">//&amp;((m)-&gt;bins[((i)-1)*2]，计算出目标bin在bins数组中的地址</span><br><span class="hljs-comment">//#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span><br><span class="hljs-comment">//offsetof宏计算fd成员在malloc_chunk中的偏移量</span><br><span class="hljs-comment">//从bins的地址减去fd的偏移量，得到一个完整的chunk结构的基地址</span><br><br>      <span class="hljs-comment">//根据下标将这个bin取出来</span><br>      bin = bin_at (av, idx);<br><br>	<span class="hljs-comment">//last(b) ((b)-&gt;bk</span><br>	  <span class="hljs-comment">//last获取当前bk指向的值，如果不等于bin则smallbin不为空</span><br>	  <span class="hljs-comment">//一般向bin中取出块用bk，添加块用fd</span><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          <br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <br>          <br>            <span class="hljs-comment">//victim为0，表示smallbin还没有初始化为双向循环链表，调用malloc_consolidate函数，此时由于global_max_fast也未初始化，所以会调用malloc_init_state初始化</span><br>            malloc_consolidate (av);<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              bck = victim-&gt;bk;<br>    <span class="hljs-comment">//双向链表检测，last(bin)-&gt;bk-&gt;fd == last(bin)</span><br>    <span class="hljs-comment">//检查下一个chunk的bk指向的上一个chunk是否指向bin</span><br>	<span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>                &#123;<br>                  <br>                  errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                  <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>	          <span class="hljs-comment">//设置inuse标志</span><br>              set_inuse_bit_at_offset (victim, nb);<br>              <span class="hljs-comment">//将victim从smallbin的双向循环链表中取出</span><br>              bin-&gt;bk = bck;<br>              bck-&gt;fd = bin;<br><br>			  <span class="hljs-comment">//判断是否指向main_arena</span><br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>	            <span class="hljs-comment">//如果不指向，则将non_main_arena置为1</span><br>                victim-&gt;size |= NON_MAIN_ARENA;<br>	          <span class="hljs-comment">//检查victim所指向的已分配内存块的完整性和合法性，确保分配的内存块符合预期的大小和对齐要求</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-comment">//将指向chunk头部的指针指向user data</span><br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              <span class="hljs-comment">//用于将分配的内存区域填充特定模式的数据，以便在调试和诊断中帮助检测未初始化内存使用等问题</span><br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">//如果smallbin没有就从largebin取</span><br>      idx = largebin_index (nb);<br>      <span class="hljs-comment">//先查看是否存在fastbin</span><br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br><br><br>  <span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<br>          <br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>        &#123;<br>          bin = bin_at (av, idx);<br><br>          <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>          <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>              victim = victim-&gt;bk_nextsize;<br>              <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br><br>              <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                 list does not have to be rerouted.  */</span><br>              <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>                victim = victim-&gt;fd;<br><br>              remainder_size = size - nb;<br>              unlink (av, victim, bck, fwd);<br><br>              <span class="hljs-comment">/* Exhaust */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>	  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><code>malloc_consolidate</code></h3><ol>
<li>首先判断当前 malloc_state 结构体中的 fastbin 是否为空，如果为空就说明整个 malloc_state 都没有完成初始化，需要对malloc_state 进行初始化。</li>
<li>malloc_state 的初始化操作由函数 malloc_init_state(av) 完成，该函数先初始化除 fastbins 之外的所有的bins，再初始化 fastbins，清空 fastbins</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-type">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>  <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-comment">//global_max_fast不为0，表示ptmalloc已经初始化，清除分配区flag中fastbin的标志位</span><br><br>	<span class="hljs-comment">/*#define clear_fastchunks(M) \</span><br><span class="hljs-comment">  catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)*/</span><br><span class="hljs-comment">//#define FASTCHUNKS_BIT        (1U)</span><br><span class="hljs-comment">//catomic_or是一个原子操作，用于对地址上的值进行按位或运算</span><br><span class="hljs-comment">//结果flags被置为1</span><br>    clear_fastchunks(av);<br><br><span class="hljs-comment">//unsorted_chunks(M) (bin_at (M, 1))</span><br><br><span class="hljs-comment">/*#define bin_at(m, i) \  </span><br><span class="hljs-comment">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))         \  </span><br><span class="hljs-comment">             - offsetof (struct malloc_chunk, fd))*/</span><br><span class="hljs-comment">//每个bin占用两个指针，所以乘以2</span><br><span class="hljs-comment">//获取arena对应的unsortedbin的第一个第一个bin</span><br><br>    unsorted_bin = unsorted_chunks(av);<br><br><span class="hljs-comment">//#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><br><span class="hljs-comment">//maxfb是指向fastbin中最后一个bin的指针</span><br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//获取第一个bin的地址</span><br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//读取fb的当前值</span><br>    <span class="hljs-comment">//将fb设置为0</span><br>    <span class="hljs-comment">//返回之前的链表头地址</span><br>      p = atomic_exchange_acq (fb, <span class="hljs-number">0</span>);<br><br><br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>	<span class="hljs-keyword">do</span> &#123;<br>	<span class="hljs-comment">//如果prev_inuse为0则报错</span><br>	  check_inuse_chunk(av, p);<br>	  <span class="hljs-comment">//将nextp赋值为下一个bin</span><br>	  nextp = p-&gt;fd;<br>	  <span class="hljs-comment">//PREV_INUSE为0x1，NON_MAIN_ARENA为0x4</span><br>	  <span class="hljs-comment">//通过按位与去除PREV_INUSE位和NON_MAIN_ARENA位</span><br>	  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);<br><br><span class="hljs-comment">//#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">//通过当前chunk的地址和大小计算出下一个chunk的地址</span><br>	  nextchunk = chunk_at_offset(p, size);<br><span class="hljs-comment">//#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">//#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">//获取nextchunk的实际内存大小</span><br>	  nextsize = chunksize(nextchunk);<br><br><span class="hljs-comment">//prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)，确认内存块是否空闲</span><br><br><span class="hljs-comment">//如果p指向的chunk空闲，即prev_inuse为0</span><br>	  <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>		<br>	    prevsize = p-&gt;prev_size;<span class="hljs-comment">//获取前一个chunk的大小</span><br>	    size += prevsize;  <span class="hljs-comment">//更新当前chunk的大小，增加前一个chunk的大小</span><br>	    p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<span class="hljs-comment">//获取上一个chunk的地址，然后赋值给p</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define unlink(AV, P, BK, FD) &#123;                                            \  </span><br><span class="hljs-comment">    FD = P-&gt;fd;              \  </span><br><span class="hljs-comment">    BK = P-&gt;bk;              \  </span><br><span class="hljs-comment">    //FD为要移除块的fd指针，BK为要移除块的bk指针</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	__builtin_expect是GCC提供的一个优化提示，告诉编译器在常见情况下链表是正确的，而不常见的情况下链表会损害</span><br><span class="hljs-comment">	FD的bk指针如果不等于当前块或BK的fd指针不等于当前块则链表损害</span><br><span class="hljs-comment">	通过malloc_printerr输出错误信息</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))        \  </span><br><span class="hljs-comment">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	如果链表没有损害，继续执行移除操作</span><br><span class="hljs-comment">    else &#123;               \  </span><br><span class="hljs-comment">	    将FD的前向指针指向BK，然后将BK的后向指向指向FD</span><br><span class="hljs-comment">        FD-&gt;bk = BK;              \  </span><br><span class="hljs-comment">        BK-&gt;fd = FD;              \  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">//判断当前块p的大小是否在小块堆的范围内。</span><br><span class="hljs-comment">        if (!in_smallbin_range (P-&gt;size)           \  </span><br><span class="hljs-comment">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;         \  </span><br><span class="hljs-comment">        //优化指令，告诉编译器这个条件很少发生</span><br><span class="hljs-comment">        //检查检查当前块在双向链表中是否完整</span><br><span class="hljs-comment">      if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)       \  </span><br><span class="hljs-comment">   || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \  </span><br><span class="hljs-comment">        malloc_printerr (check_action,          \  </span><br><span class="hljs-comment">           &quot;corrupted double-linked list (not small)&quot;,    \  </span><br><span class="hljs-comment">           P, AV);           \ </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">			判断FD的fd_nextsize是否为空，表示FD是否是当前链表的尾部</span><br><span class="hljs-comment">            if (FD-&gt;fd_nextsize == NULL) &#123;           \  </span><br><span class="hljs-comment">		        如果是尾部，而且P的fd_nextsize判定为P，则将FD作为链表的唯一元素</span><br><span class="hljs-comment">                if (P-&gt;fd_nextsize == P)           \  </span><br><span class="hljs-comment">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;        \  </span><br><span class="hljs-comment">                else &#123;              \  </span><br><span class="hljs-comment">	                确保双向链接的完整性</span><br><span class="hljs-comment">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;         \  </span><br><span class="hljs-comment">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;         \  </span><br><span class="hljs-comment">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;         \  </span><br><span class="hljs-comment">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;         \  </span><br><span class="hljs-comment">                  &#125;             \  </span><br><span class="hljs-comment">                  如果FD-&gt;nextsize不为空，意味着FD已经位于链表中。</span><br><span class="hljs-comment">	              在这种情况下，需要更新P的前后链接</span><br><span class="hljs-comment">              &#125; else &#123;              \  </span><br><span class="hljs-comment">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;        \  </span><br><span class="hljs-comment">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;        \  </span><br><span class="hljs-comment">              &#125;              \  </span><br><span class="hljs-comment">          &#125;              \  </span><br><span class="hljs-comment">      &#125;               \  </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br>		<span class="hljs-comment">//av即当前的arena</span><br>		<span class="hljs-comment">//p为要移除的块</span><br>	    unlink(av, p, bck, fwd);<span class="hljs-comment">//将前一个chunk从链表中移除</span><br>	  &#125;<br><br>	<span class="hljs-comment">//如果nextchunk和top chunk不相同，则说明当前的内存块不是堆中的顶端块</span><br>	  <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br><span class="hljs-comment">/*#define inuse_bit_at_offset(p, s)           \  </span><br><span class="hljs-comment">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)*/</span><br>		<span class="hljs-comment">//检查nextchunk是否为已分配，如果已分配则nextinuse为1</span><br>	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>		<span class="hljs-comment">//如果nextinuse为未分配则执行</span><br>	    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>		<span class="hljs-comment">//将nextchunk的nextsize追加到当前块p的大小size上，更新合并后块的大小</span><br>	      size += nextsize;<br>	      <span class="hljs-comment">//将nextchunk移除</span><br>	      unlink(av, nextchunk, bck, fwd);<br>	    &#125; <span class="hljs-keyword">else</span><br>	    <span class="hljs-comment">//如果nextchunk已分配，则清除nextchunk的prev_inuse位</span><br>	      clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>		<span class="hljs-comment">//将unsortedbin的第一个指针存入first_unsorted中</span><br>	    first_unsorted = unsorted_bin-&gt;fd;<br>	    <span class="hljs-comment">//将当前块p插入到unsortedbin的开头</span><br>	    unsorted_bin-&gt;fd = p;<br>	    <span class="hljs-comment">//将原先的第一个未排序块的后向指针指向当前块p，完成双向链表的更新</span><br>	    first_unsorted-&gt;bk = p;<br><br>	    <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>	      p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>	      p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>	    &#125;<br><br>	    set_head(p, size | PREV_INUSE);<br>	    p-&gt;bk = unsorted_bin;<br>	    p-&gt;fd = first_unsorted;<br>	    set_foot(p, size);<br>	  &#125;<br>	  <span class="hljs-keyword">else</span> &#123;<br>	    size += nextsize;<br>	    set_head(p, size | PREV_INUSE);<br>	    av-&gt;top = p;<br>	  &#125;<br>	&#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">//直到遍历完当前fastbin中的所有空闲chunk</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>    <span class="hljs-comment">//直到遍历完所有的fastbin</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果ptmalloc没有初始化，初始化ptmalloc</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">//如果当前的free是chunk通过mmap分配的，调用munmap_chunk函数</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//不需要对分配区加锁，调用_int_free函数执行实际的释放工作</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="sysmalloc-源码分析"><a href="#sysmalloc-源码分析" class="headerlink" title="sysmalloc 源码分析"></a>sysmalloc 源码分析</h2><p><code>sysmalloc</code>负责向操作系统申请内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *  <br><span class="hljs-title function_">sysmalloc</span> <span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span>  <br>&#123;  <br>  mchunkptr old_top;              <span class="hljs-comment">//av-&gt;top的原始值</span><br>  INTERNAL_SIZE_T old_size;       <span class="hljs-comment">//它的大小  </span><br>  <span class="hljs-type">char</span> *old_end;                  <span class="hljs-comment">//它的结束地址 </span><br>  <br>  <span class="hljs-type">long</span> size;                      <span class="hljs-comment">//参数给MORECORE或mmap调用  </span><br>  <span class="hljs-type">char</span> *brk;                      <span class="hljs-comment">//MORECORE的返回值  </span><br>  <br>  <span class="hljs-type">long</span> correction;                <span class="hljs-comment">//参数给第二个MORECORE调用  </span><br>  <span class="hljs-type">char</span> *snd_brk;                  <span class="hljs-comment">//第二个返回值 </span><br>  <br>  INTERNAL_SIZE_T front_misalign; <span class="hljs-comment">/* 表示分配内存时，在起始地址与对齐要求之间多出的不可用字节 */</span>  <br>  INTERNAL_SIZE_T end_misalign;   <span class="hljs-comment">/* 表示分配后，在页面结尾部分由于对齐问题而留下的不可用字节 */</span>  <br>  <span class="hljs-type">char</span> *aligned_brk;              <span class="hljs-comment">/* 执行brk内经过对齐调整后的地址 */</span>  <br>  <br>  mchunkptr p;                    <span class="hljs-comment">/* 用于指向分配器内部的内存块结构 */</span>  <br>  mchunkptr remainder;            <span class="hljs-comment">/* 分配内存后剩余的内存块 */</span>  <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;   <span class="hljs-comment">/* 表示remainder块的大小 */</span>  <br>  <br>  <span class="hljs-comment">//GLRO是一个宏，用于读取全局只读变量。</span><br>  <span class="hljs-comment">//dl_pagesize是一个变量，表示系统页面的大小。</span><br>  <span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);  <br>  <span class="hljs-comment">//tried_mmap 表示程序是否使用 mmap 系统调用分配内存</span><br>  <span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;  <br>    <br>  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">     如果使用mmap，并且请求的大小达到mmap阈值，并且系统支持mmap，</span><br><span class="hljs-comment">     并且当前分配的mmap区域数量较少，尝试直接映射这个请求，</span><br><span class="hljs-comment">     而不是扩展top</span><br><span class="hljs-comment">  */</span>  <br>  <span class="hljs-comment">//当arena为空，或请求内存nb超过阈值（mmap_threshold）且mmap次数未达到限制时，则进入mmap分配</span><br>  <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>  <br>      || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)  <br>    &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))  <br>    &#123;  <br>      <span class="hljs-type">char</span> *mm;           <span class="hljs-comment">//mmap调用的返回值</span><br>  <br>    try_mmap:  <span class="hljs-comment">//定义一个标签，提供一个跳转位置</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">			将大小上调到最近的页大小。对于mmapped区块，开销比普通区块多一个SIZE_SZ单位，</span><br><span class="hljs-comment">			因为没有后续区块的prev_size字段可用。</span><br><span class="hljs-comment">	*/</span><br><br>		<span class="hljs-comment">//MALLOC_ALIGNMENT是内存分配的对齐单位，通常为16字节</span><br>      <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)  <br>		<span class="hljs-comment">//对齐到页大小时，只需将用户请求大小nb加上元数据开销SIZE_SZ，并调整为页大小的整数倍</span><br>		<span class="hljs-comment">//ALIGN_UP是对齐函数，确保(nb+SIZE_SZ)的大小是pagesize的整数倍</span><br>        size = ALIGN_UP (nb + SIZE_SZ, pagesize);  <br>      <span class="hljs-keyword">else</span>  <br>	    <span class="hljs-comment">//如果对齐规则更复杂，需要考虑额外的对齐掩码，MALLOC_ALIGN_MASK</span><br>	    <span class="hljs-comment">//MALLOC_ALIGN_MASK 的作用是用于处理非双字对齐的需求</span><br>        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);  <br>      <span class="hljs-comment">//将tried_mmap置为true，表示当前尝试通过mmap分配内存</span><br>      tried_mmap = <span class="hljs-literal">true</span>;  <br>  <br>      <span class="hljs-comment">//防止内存大小溢出</span><br>      <span class="hljs-comment">//将size转化为无符号长整型进行比较，确保size不会溢出为负值</span><br>      <span class="hljs-comment">//如果size小于请求大小nb，意味着计算时可能发生了溢出，此时不会继续尝试mmap</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))  <br>        &#123;  <br>	      <span class="hljs-comment">//调用mmap分配内存</span><br>	      <span class="hljs-comment">//0为系统选择映射地址，size调整页大小的分配内存大小</span><br>	      <span class="hljs-comment">//PROT_READ|PROT_WRITE映射的内存可读可写</span><br>	      <span class="hljs-comment">//0，不设置特殊标志，默认匿名映射</span><br>	      <span class="hljs-comment">//如果分配成功返回一个指针，否则返回MAP_FAILED</span><br>          mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));  <br><br>		  <span class="hljs-comment">//如果内存分配成功则执行</span><br>          <span class="hljs-keyword">if</span> (mm != MAP_FAILED)  <br>            &#123;  <br>              <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 mmapped区域的开始偏移存储在区块的prev_size字段中。这允许我们在这里</span><br><span class="hljs-comment">                 和memalign()中调整返回的开始地址以满足对齐要求，并且仍然能够在</span><br><span class="hljs-comment">                 free()和realloc()中计算出正确的munmap参数地址。</span><br><span class="hljs-comment">              */</span><br>              <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)  <br>                &#123;  <br>                  <span class="hljs-comment">/* 对于glibc，chunk2mem增加地址2*SIZE_SZ，并且MALLOC_ALIGN_MASK是2*SIZE_SZ-1。</span><br><span class="hljs-comment">                     每个mmap区域都是页面对齐的，因此一定是MALLOC_ALIGN_MASK对齐的。*/</span>                  assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);  <br>                  front_misalign = <span class="hljs-number">0</span>;  <br>                &#125;  <br>              <span class="hljs-keyword">else</span>  <br>                front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;  <br>              <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)  <br>                &#123;  <br>                  correction = MALLOC_ALIGNMENT - front_misalign;  <br>                  p = (mchunkptr) (mm + correction);  <br>                  p-&gt;prev_size = correction;  <br>                  set_head (p, (size - correction) | IS_MMAPPED);  <br>                &#125;  <br>              <span class="hljs-keyword">else</span>  <br>                &#123;  <br>                  p = (mchunkptr) mm;  <br>                  set_head (p, size | IS_MMAPPED);  <br>                &#125;  <br>  <br>              <span class="hljs-comment">/* 更新统计数据 */</span>  <br>  <br>              <span class="hljs-type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;  <br>              <span class="hljs-type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);  <br>  <br>              <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;  <br>              sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;  <br>              <span class="hljs-type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);  <br>  <br>              check_chunk (av, p);  <br><br>			<span class="hljs-comment">//返回chunk</span><br>              <span class="hljs-keyword">return</span> chunk2mem (p);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>  <span class="hljs-comment">/* 如果没有可用的arena，并且mmap也失败了则返回0 */</span>  <br>  <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-comment">/* 记录进入时top的配置 */</span>  <br>  <span class="hljs-comment">//记录top chunk</span><br>  old_top = av-&gt;top;  <br>  <br>  old_size = chunksize (old_top);  <br>  old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));  <br>  <br>  brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);  <br>  <br>  <span class="hljs-comment">/*如果不是第一次通过，我们需要old_size至少是MINSIZE，并且设置了prev_inuse位。*/</span><br>  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||  <br>          ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;  <br>           prev_inuse (old_top) &amp;&amp;  <br>           ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));  <br>  <br>   <span class="hljs-comment">/* 前提条件: 当前空间不足以满足nb请求 */</span><br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));  <br>  <br>  <span class="hljs-comment">// 如果av不是主arena，则尝试扩展当前堆或创建新堆。</span><br>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)  <br>    &#123;  <br>      heap_info *old_heap, *heap;  <br>      <span class="hljs-type">size_t</span> old_heap_size;  <br>  <br>        <span class="hljs-comment">/* 首先尝试扩展当前堆。 */</span><br>      old_heap = heap_for_ptr (old_top);  <br>      old_heap_size = old_heap-&gt;size;  <br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span>  <br>          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>)  <br>        &#123;  <br>          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;  <br>          arena_mem += old_heap-&gt;size - old_heap_size;  <br>          set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)  <br>                    | PREV_INUSE);  <br>        &#125;  <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="hljs-keyword">sizeof</span> (*heap)), mp_.top_pad)))  <br>        &#123;  <br>          <span class="hljs-comment">/* Use a newly allocated heap.  */</span>  <br>          heap-&gt;ar_ptr = av;  <br>          heap-&gt;prev = old_heap;  <br>          av-&gt;system_mem += heap-&gt;size;  <br>          arena_mem += heap-&gt;size;  <br>          <span class="hljs-comment">/* Set up the new top.  */</span>  <br>          top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span> (*heap));  <br>          set_head (top (av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span> (*heap)) | PREV_INUSE);  <br>  <br>          <span class="hljs-comment">/* Setup fencepost and free the old top chunk with a multiple of  </span><br><span class="hljs-comment">             MALLOC_ALIGNMENT in size. */</span>          <span class="hljs-comment">/* The fencepost takes at least MINSIZE bytes, because it might             become the top chunk again later.  Note that a footer is set             up, too, although the chunk is marked in use. */</span>          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;  <br>          set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);  <br>          <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)  <br>            &#123;  <br>              set_head (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);  <br>              set_foot (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));  <br>              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);  <br>              _int_free (av, old_top, <span class="hljs-number">1</span>);  <br>            &#125;  <br>          <span class="hljs-keyword">else</span>  <br>            &#123;  <br>              set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);  <br>              set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));  <br>            &#125;  <br>        &#125;  <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)  <br>        <span class="hljs-comment">/* We can at least try to use to mmap memory.  */</span>  <br>        <span class="hljs-keyword">goto</span> try_mmap;  <br>    &#125;  <br>  <span class="hljs-keyword">else</span>     <span class="hljs-comment">/* av == main_arena */</span>  <br>  <br>  <br>    &#123; <span class="hljs-comment">/* Request enough space for nb + pad + overhead */</span>  <br>      size = nb + mp_.top_pad + MINSIZE;  <br>  <br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">         如果是连续的，我们可以减去希望与新空间合并的现有空间。</span><br><span class="hljs-comment">         我们稍后只在我们实际没有获得连续空间时再加回来。</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (contiguous (av))  <br>        size -= old_size;  <br>  <br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">         将大小调整为页的倍数。</span><br><span class="hljs-comment">         如果MORECORE不是连续的，这确保我们只用整页参数调用它。</span><br><span class="hljs-comment">         并且如果MORECORE是连续的，并且这不是第一次通过，</span><br><span class="hljs-comment">         这会保持先前调用的页对齐。</span><br><span class="hljs-comment">       */</span> <br>      size = ALIGN_UP (size, pagesize);  <br>  <br>      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear         negative. Note that since mmap takes size_t arg, it may succeed         below even if we cannot call MORECORE.       */</span>  <br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)  <br>        &#123;  <br>          brk = (<span class="hljs-type">char</span> *) (MORECORE (size));  <br>          LIBC_PROBE (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);  <br>        &#125;  <br>  <br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>        &#123;  <br>          <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span>  <br>          <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);  <br>          <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))  <br>            (*hook)();  <br>        &#125;  <br>      <span class="hljs-keyword">else</span>  <br>        &#123;  <br>          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             If have mmap, try using it as a backup when MORECORE fails or             cannot be used. This is worth doing on systems that have &quot;holes&quot; in             address space, so sbrk cannot extend to give contiguous space, but             space is available elsewhere.  Note that we ignore mmap max count             and threshold limits, since the space will not be used as a             segregated mmap region.           */</span>  <br>          <span class="hljs-comment">/* Cannot merge with old top, so add its size back in */</span>          <span class="hljs-keyword">if</span> (contiguous (av))  <br>            size = ALIGN_UP (size + old_size, pagesize);  <br>  <br>          <span class="hljs-comment">/* If we are relying on mmap as backup, then use larger units */</span>  <br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))  <br>            size = MMAP_AS_MORECORE_SIZE;  <br>  <br>          <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span>  <br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))  <br>            &#123;  <br>              <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));  <br>  <br>              <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)  <br>                &#123;  <br>                  <span class="hljs-comment">/* We do not need, and cannot use, another sbrk call to find end */</span>  <br>                  brk = mbrk;  <br>                  snd_brk = brk + size;  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     Record that we no longer have a contiguous sbrk region.                     After the first time mmap is used as backup, we do not                     ever rely on contiguous space since this could incorrectly                     bridge regions.                   */</span>                  set_noncontiguous (av);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>  <br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>        &#123;  <br>          <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)  <br>            mp_.sbrk_base = brk;  <br>          av-&gt;system_mem += size;  <br>  <br>          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             If MORECORE extends previous space, we can likewise extend top size.           */</span>  <br>          <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>            set_head (old_top, (size + old_size) | PREV_INUSE);  <br>  <br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)  <br>            &#123;  <br>              <span class="hljs-comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span>  <br>              malloc_printerr (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>, brk,  <br>           av);  <br>            &#125;  <br>  <br>          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             Otherwise, make adjustments:  </span><br><span class="hljs-comment">           * If the first time through or noncontiguous, we need to call sbrk              just to find out where the end of memory lies.  </span><br><span class="hljs-comment">           * We need to ensure that all returned chunks from malloc will meet              MALLOC_ALIGNMENT  </span><br><span class="hljs-comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk              request size to account for fact that we will not be able to              combine new space with existing space in old_top.  </span><br><span class="hljs-comment">           * Almost all systems internally allocate whole pages at a time, in              which case we might as well use the whole last page of request.              So we allocate enough more memory to hit a page boundary now,              which in turn causes future contiguous calls to page-align.           */</span>  <br>          <span class="hljs-keyword">else</span>  <br>            &#123;  <br>              front_misalign = <span class="hljs-number">0</span>;  <br>              end_misalign = <span class="hljs-number">0</span>;  <br>              correction = <span class="hljs-number">0</span>;  <br>              aligned_brk = brk;  <br>  <br>              <span class="hljs-comment">/* handle contiguous cases */</span>  <br>              <span class="hljs-keyword">if</span> (contiguous (av))  <br>                &#123;  <br>                  <span class="hljs-comment">/* Count foreign sbrk as system_mem.  */</span>  <br>                  <span class="hljs-keyword">if</span> (old_size)  <br>                    av-&gt;system_mem += brk - old_end;  <br>  <br>                  <span class="hljs-comment">/* Guarantee alignment of first new chunk made from this space */</span>  <br>  <br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;  <br>                  <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)  <br>                    &#123;  <br>                      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                         Skip over some bytes to arrive at an aligned position.                         We don&#x27;t need to specially mark these wasted front bytes.                         They will never be accessed anyway because                         prev_inuse of av-&gt;top (and any chunk created from its start)                         is always true after initialization.                       */</span>  <br>                      correction = MALLOC_ALIGNMENT - front_misalign;  <br>                      aligned_brk += correction;  <br>                    &#125;  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     If this isn&#x27;t adjacent to existing space, then we will not                     be able to merge with old_top space, so must add to 2nd request.                   */</span>  <br>                  correction += old_size;  <br>  <br>                  <span class="hljs-comment">/* Extend the end address to hit a page boundary */</span>  <br>                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);  <br>                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;  <br>  <br>                  assert (correction &gt;= <span class="hljs-number">0</span>);  <br>                  snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (correction));  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     If can&#x27;t allocate correction, try to at least find out current                     brk.  It might be enough to proceed without failing.  </span><br><span class="hljs-comment">                     Note that if second sbrk did NOT fail, we assume that space                     is contiguous with first sbrk. This is a safe assumption unless                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk                     occurred between our first and second calls.                   */</span>  <br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>                    &#123;  <br>                      correction = <span class="hljs-number">0</span>;  <br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));  <br>                    &#125;  <br>                  <span class="hljs-keyword">else</span>  <br>                    &#123;  <br>                      <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span>  <br>                      <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);  <br>                      <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))  <br>                        (*hook)();  <br>                    &#125;  <br>                &#125;  <br>  <br>              <span class="hljs-comment">/* handle non-contiguous cases */</span>  <br>              <span class="hljs-keyword">else</span>  <br>                &#123;  <br>                  <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)  <br>                    <span class="hljs-comment">/* MORECORE/mmap must correctly align */</span>  <br>                    assert (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);  <br>                  <span class="hljs-keyword">else</span>  <br>                    &#123;  <br>                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;  <br>                      <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)  <br>                        &#123;  <br>                          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                             Skip over some bytes to arrive at an aligned position.                             We don&#x27;t need to specially mark these wasted front bytes.                             They will never be accessed anyway because                             prev_inuse of av-&gt;top (and any chunk created from its start)                             is always true after initialization.                           */</span>  <br>                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;  <br>                        &#125;  <br>                    &#125;  <br>  <br>                  <span class="hljs-comment">/* Find out current end of memory */</span>  <br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>                    &#123;  <br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));  <br>                    &#125;  <br>                &#125;  <br>  <br>              <span class="hljs-comment">/* Adjust top based on results of second sbrk */</span>  <br>              <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>                &#123;  <br>                  av-&gt;top = (mchunkptr) aligned_brk;  <br>                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);  <br>                  av-&gt;system_mem += correction;  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     If not the first time through, we either have a                     gap due to foreign sbrk or a non-contiguous region.  Insert a                     double fencepost at old_top to prevent consolidation with space                     we don&#x27;t own. These fenceposts are artificial chunks that are                     marked as inuse and are in any case too small to use.  We need                     two to make sizes and alignments work out.                   */</span>  <br>                  <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)  <br>                    &#123;  <br>                      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                         Shrink old_top to insert fenceposts, keeping size a                         multiple of MALLOC_ALIGNMENT. We know there is at least                         enough space in old_top to do this.                       */</span>                      old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;  <br>                      set_head (old_top, old_size | PREV_INUSE);  <br>  <br>                      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                         Note that the following assignments completely overwrite                         old_top when old_size was previously MINSIZE.  This is                         intentional. We need the fencepost, even if old_top otherwise gets                         lost.                       */</span>                      chunk_at_offset (old_top, old_size)-&gt;size =  <br>                        (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE;  <br>  <br>                      chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ)-&gt;size =  <br>                        (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE;  <br>  <br>                      <span class="hljs-comment">/* If possible, release the rest. */</span>  <br>                      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)  <br>                        &#123;  <br>                          _int_free (av, old_top, <span class="hljs-number">1</span>);  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-comment">/* if (av !=  &amp;main_arena) */</span>  <br>  <br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))  <br>    av-&gt;max_system_mem = av-&gt;system_mem;  <br>  check_malloc_state (av);  <br>  <br>  <span class="hljs-comment">/* finally, do the allocation */</span>  <br>  p = av-&gt;top;  <br>  size = chunksize (p);  <br>  <br>  <span class="hljs-comment">/* check that one of the above allocation paths succeeded */</span>  <br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))  <br>    &#123;  <br>      remainder_size = size - nb;  <br>      remainder = chunk_at_offset (p, nb);  <br>      av-&gt;top = remainder;  <br>      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));  <br>      set_head (remainder, remainder_size | PREV_INUSE);  <br>      check_malloced_chunk (av, p, nb);  <br>      <span class="hljs-keyword">return</span> chunk2mem (p);  <br>    &#125;  <br>  <br>  <span class="hljs-comment">/* catch all failure paths */</span>  <br>  __set_errno (ENOMEM);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h2><h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a><code>__libc_free</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br>  <span class="hljs-comment">// 调用 __free_hook ，参数是是否的内存的地址。</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br> <br>  p = mem2chunk (mem);<br>  <span class="hljs-comment">// 如果是 mmapp 得到的内存单独处理</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>      <span class="hljs-comment">// 释放的内存大小如果大于 mmap_threshold 并且小于 DEFAULT_MMAP_THRESHOLD_MAX(0x20000)</span><br>      <span class="hljs-comment">// 则更新 mmap_threshold 为释放内存的大小，trim_threshold 为两倍释放内存的大小。</span><br>      <span class="hljs-comment">// 其中 mmap_threshold 是 sysmalloc 中 brk 和 mmap 两种系统调用获取内存的选择的边界值</span><br>      <span class="hljs-comment">// trim_threshold 为是否 systrim 减少 ptmalloc 保留内存的参考值</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      <span class="hljs-comment">// 调用 nummap 释放内存</span><br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>  <span class="hljs-comment">// 调用 _int_free 释放内存</span><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a><code>_int_free</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock) &#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* 释放的chunk的size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* 对应的fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* 内存空间中下一个chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* 下一个chunk的大小 */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* 下一个chunk是否在使用 */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* 内存空间中上一个chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* 用于储存bin链表指针 */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* 用于储存bin链表指针 */</span><br> <br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br>  size = chunksize (p);<br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>) || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-comment">//chunk的指针地址不能溢出</span><br>    errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>  errout:<br>    <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>      (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br>    malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123;<br>    <span class="hljs-comment">//chunk的大小必须大于等于MINSIZE且对齐</span><br>    errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br>  check_inuse_chunk(av, p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  ) &#123;<br>    <span class="hljs-comment">//当前free的chunk属于fastbin</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span><br>        <span class="hljs-keyword">if</span> (have_lock || (&#123; assert (locked == <span class="hljs-number">0</span>); mutex_lock(&amp;av-&gt;mutex); locked = <span class="hljs-number">1</span>; chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123;<br>          errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>          <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>          (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>          locked = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁</span><br>    &#125;<br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br> <br>    set_fastchunks(av);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br>    <span class="hljs-comment">//设置当前分配区的fastbin的flag,表示当前分配区的fastbin中已有空闲chunk.然后根据当前free的chunk大小获取所属的fastbin</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">//fastbin double free检测</span><br>          errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>          <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>          old_idx = fastbin_index(chunksize(old));<br>        p-&gt;fd = old2 = old;<br>    &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br>    <span class="hljs-comment">//使用lock-free技术实现fastbin的单向链表插入操作</span><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-comment">//当前free的chunk不是通过mmap分配的,并且当前还没有获得分配区的锁,获取分配区的锁</span><br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<br>      locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br> <br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) &#123;<br>      <span class="hljs-comment">//free的是top chunk</span><br>        errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av) &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-comment">//内存中下一个chunk的地址大于top chunk的末尾</span><br>        errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) &#123;<br>      <span class="hljs-comment">//该chunk已经是free状态</span><br>        errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br> <br>    nextsize = chunksize(nextchunk);<br>    <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span><br>        errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br> <br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      <span class="hljs-comment">//如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并</span><br>      prevsize = p-&gt;prev_size;<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      unlink(av, p, bck, fwd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">//与当前free的chunk相邻的下一个chunk不是分配区的top chunk</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        <span class="hljs-comment">//如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并</span><br>          unlink(av, nextchunk, bck, fwd);<br>          size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span><br>          clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br> <br>      bck = unsorted_chunks(av);<br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;<br>        <span class="hljs-comment">//unsorted_bin第一个chunk的fd的bk不是第一个chunk</span><br>          errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>          <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>          p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>          p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br>      <span class="hljs-comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<br>      check_free_chunk(av, p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk</span><br>      size += nextsize;<br>      set_head(p, size | PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>      <span class="hljs-comment">//如果合并后的chunk大小大于64KB</span><br>      <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>          malloc_consolidate(av);<br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>          <span class="hljs-comment">//如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用systrim函数收缩heap</span><br>            systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//为非主分配区,调用heap_trim函数收缩非主分配区的sub_heap</span><br>          heap_info *heap = heap_for_ptr(top(av));<br>          assert(heap-&gt;ar_ptr == av);<br>          heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      <span class="hljs-comment">//有锁则对分配区解锁</span><br>      assert (locked);<br>      (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//当前free的chunk是通过mmap分配则调用munma_chunk释放</span><br>    munmap_chunk (p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a><code>systrim</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">systrim</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> pad, mstate av)</span> &#123;<br>  <span class="hljs-type">long</span> top_size;<br>  <span class="hljs-type">long</span> extra;<br>  <span class="hljs-type">long</span> released;<br>  <span class="hljs-type">char</span> *current_brk;<br>  <span class="hljs-type">char</span> *new_brk;<br>  <span class="hljs-type">size_t</span> pagesize;<br>  <span class="hljs-type">long</span> top_area;<br> <br>  pagesize = GLRO (dl_pagesize);<br>  top_size = chunksize (av-&gt;top);<br>  top_area = top_size - MINSIZE - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (top_area &lt;= pad)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  extra = ALIGN_DOWN(top_area - pad, pagesize);<br>  <span class="hljs-comment">//计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost</span><br>  <span class="hljs-keyword">if</span> (extra == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>  current_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">if</span> (current_brk == (<span class="hljs-type">char</span> *) (av-&gt;top) + top_size) &#123;<br>    <span class="hljs-comment">//如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩</span><br>    MORECORE (-extra);<br>    <span class="hljs-comment">//调用sbrk释放指定大小的内存</span><br>    <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>      (*hook)();<br>    new_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>    LIBC_PROBE (memory_sbrk_less, <span class="hljs-number">2</span>, new_brk, extra);<br>    <span class="hljs-keyword">if</span> (new_brk != (<span class="hljs-type">char</span> *) MORECORE_FAILURE) &#123;<br>      <span class="hljs-comment">//计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小</span><br>      released = (<span class="hljs-type">long</span>) (current_brk - new_brk);<br>      <span class="hljs-keyword">if</span> (released != <span class="hljs-number">0</span>) &#123;<br>        av-&gt;system_mem -= released;<br>        set_head (av-&gt;top, (top_size - released) | PREV_INUSE);<br>        check_malloc_state (av);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="calloc源码分析"><a href="#calloc源码分析" class="headerlink" title="calloc源码分析"></a>calloc源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_calloc (<span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> elem_size)<br>&#123;<br>  mstate av;<br>  mchunkptr oldtop, p;<br>  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;<br>  <span class="hljs-type">void</span> *mem;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clearsize;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nclears;<br>  INTERNAL_SIZE_T *d;<br> <br>  <span class="hljs-comment">/* size_t is unsigned so the behavior on overflow is defined.  */</span><br>  <span class="hljs-comment">// 将需要申请的内存大小转换为以字节为单位</span><br>  bytes = n * elem_size;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_INTERNAL_SIZE_T \</span><br><span class="hljs-meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span><br><br>  <span class="hljs-comment">// 如果 n 和 elem_size 中的任何一个不小于 HALF_INTERNAL_SIZE_T</span><br>  <span class="hljs-comment">// 以 64 位为例，HALF_INTERNAL_SIZE_T = 2^32</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="hljs-number">0</span>))<br>    &#123;<br>      <span class="hljs-comment">// 判断 bytes 是否溢出</span><br>      <span class="hljs-keyword">if</span> (elem_size != <span class="hljs-number">0</span> &amp;&amp; bytes / elem_size != n)<br>        &#123;<br>          __set_errno (ENOMEM);<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 获取 __malloc_hook</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) =<br>    atomic_forced_read (__malloc_hook);<br>  <br>  <span class="hljs-comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook，参数为申请内存的大小。</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      sz = bytes;<br>      mem = (*hook)(sz, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (mem, <span class="hljs-number">0</span>, sz);<br>    &#125;<br> <br>  sz = bytes;<br> <br>  arena_get (av, sz);<br>  <span class="hljs-keyword">if</span> (av)<br>    &#123;<br>      <span class="hljs-comment">/* Check if we hand out the top chunk, in which case there may be no</span><br><span class="hljs-comment">     need to clear. */</span><br>   <span class="hljs-comment">// 获取 top chunk 和 top chunk 的大小，这里的 top chunk 的大小是指 top chunk 头之后可以“控制”的的内存大小，具体看后面的解释。</span><br>   <span class="hljs-comment">// 获取这些的原因是无论是 main_arena 控制的 heap 区域通过 sbrk 扩展还是非 main_arena 区域通过对 heap_info 向后扩展受保护的内存区域，</span><br>   <span class="hljs-comment">// 新扩展的内存初始值为 0，即这些内存不需要清空，因此后面会将需要清零的内存大小减去和这部分内存重合的区域，提升程序效率。</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CLEARS</span><br>      oldtop = top (av);<br>      oldtopsize = chunksize (top (av));<br><span class="hljs-meta"># <span class="hljs-keyword">if</span> MORECORE_CLEARS &lt; 2</span><br>      <span class="hljs-comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena &amp;&amp;<br>      oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="hljs-type">char</span> *) oldtop)<br>  <span class="hljs-comment">// 对于 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap 区域末尾位置</span><br>    oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="hljs-type">char</span> *) oldtop);<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>    &#123;<br>    <span class="hljs-comment">// 对于非 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap_info 受保护区域末尾位置</span><br>      heap_info *heap = heap_for_ptr (oldtop);<br>      <span class="hljs-keyword">if</span> (oldtopsize &lt; (<span class="hljs-type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="hljs-type">char</span> *) oldtop)<br>        oldtopsize = (<span class="hljs-type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="hljs-type">char</span> *) oldtop;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">/* No usable arenas.  */</span><br>      <span class="hljs-comment">// av 为 NULL ，那么之后 _int_malloc 会直接 mmap 获取内存，而 mmap 获取的内存初始值为 0，因此不需要清零。</span><br>      oldtop = <span class="hljs-number">0</span>;<br>      oldtopsize = <span class="hljs-number">0</span>;<br>    &#125;<br>  <span class="hljs-comment">// 调用 _int_malloc 获取内存</span><br>  mem = _int_malloc (av, sz);<br> <br>  <span class="hljs-comment">// 同 __libc_malloc 的 3 种情况</span><br>  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||<br>          av == arena_for_chunk (mem2chunk (mem)));<br> <br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span> &amp;&amp; av != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_calloc_retry, <span class="hljs-number">1</span>, sz);<br>      av = arena_get_retry (av, sz);<br>      mem = _int_malloc (av, sz);<br>    &#125;<br> <br>  <span class="hljs-keyword">if</span> (av != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br> <br>  <span class="hljs-comment">/* Allocation failed even after a retry.  */</span><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>  p = mem2chunk (mem);<br> <br>  <span class="hljs-comment">/* Two optional cases in which clearing not necessary */</span><br>  <span class="hljs-comment">// 如果是 mmap 获取的不需要清零，因此只要 chunk 的 size 字段中的 IS_MMAPPED 位置 1 就不会清零。</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))<br>    &#123;<br>      <span class="hljs-keyword">if</span> (__builtin_expect (perturb_byte, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (mem, <span class="hljs-number">0</span>, sz);<br> <br>      <span class="hljs-keyword">return</span> mem;<br>    &#125;<br> <br>  csz = chunksize (p);<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CLEARS</span><br>  <span class="hljs-comment">// 如果是从 top chunk 上切下来的则只需要清零 top chunk 范围的内存。</span><br>  <span class="hljs-keyword">if</span> (perturb_byte == <span class="hljs-number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))<br>    &#123;<br>      <span class="hljs-comment">/* clear only the bytes from non-freshly-sbrked memory */</span><br>      csz = oldtopsize;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br>  <span class="hljs-comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span><br><span class="hljs-comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span><br><span class="hljs-comment">     minimally 3.  */</span><br>  <span class="hljs-comment">// 清空内存，包括下一个 chunk 的 prev_size 。   </span><br>  d = (INTERNAL_SIZE_T *) mem;<br>  clearsize = csz - SIZE_SZ;<br>  nclears = clearsize / <span class="hljs-keyword">sizeof</span> (INTERNAL_SIZE_T);<br>  assert (nclears &gt;= <span class="hljs-number">3</span>);<br>   <br>  <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (d, <span class="hljs-number">0</span>, clearsize);<br> <br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      *(d + <span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;<br>      *(d + <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>      *(d + <span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">4</span>)<br>        &#123;<br>          *(d + <span class="hljs-number">3</span>) = <span class="hljs-number">0</span>;<br>          *(d + <span class="hljs-number">4</span>) = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">6</span>)<br>            &#123;<br>              *(d + <span class="hljs-number">5</span>) = <span class="hljs-number">0</span>;<br>              *(d + <span class="hljs-number">6</span>) = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">8</span>)<br>                &#123;<br>                  *(d + <span class="hljs-number">7</span>) = <span class="hljs-number">0</span>;<br>                  *(d + <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>  <span class="hljs-keyword">return</span> mem;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="relloc源码分析"><a href="#relloc源码分析" class="headerlink" title="relloc源码分析"></a>relloc源码分析</h2><h3 id="libc-realloc"><a href="#libc-realloc" class="headerlink" title="_libc_realloc"></a><code>_libc_realloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_realloc (<span class="hljs-type">void</span> *oldmem, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  INTERNAL_SIZE_T nb;         <span class="hljs-comment">/* padded request size */</span><br> <br>  <span class="hljs-type">void</span> *newp;             <span class="hljs-comment">/* chunk to return */</span><br>  <span class="hljs-comment">// 调用 __realloc_hook</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) =<br>    atomic_forced_read (__realloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 如果 bytes 为 0 则相当于 free(oldmem)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> REALLOC_ZERO_BYTES_FREES</span><br>  <span class="hljs-keyword">if</span> (bytes == <span class="hljs-number">0</span> &amp;&amp; oldmem != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      __libc_free (oldmem); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">// 如果 oldmem 为 NULL 相当于 malloc(bytes)</span><br>  <span class="hljs-comment">/* realloc of null is supposed to be same as malloc */</span><br>  <span class="hljs-keyword">if</span> (oldmem == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> __libc_malloc (bytes);<br> <br>  <span class="hljs-comment">// 获取 oldmem 对应的 chunk 的指针和大小</span><br>  <span class="hljs-comment">/* chunk corresponding to oldmem */</span><br>  <span class="hljs-type">const</span> mchunkptr oldp = mem2chunk (oldmem);<br>  <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);<br>  <span class="hljs-comment">// 寻找 oldp 对应的 arena</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (oldp))<br>    ar_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">else</span><br>    ar_ptr = arena_for_chunk (oldp);<br> <br>  <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">     allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">     Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">     here by accident or by &quot;design&quot; from some intruder.  */</span><br>  <span class="hljs-comment">// 检查 oldp + oldsize 是否超过地址上限</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) oldp &gt; (<span class="hljs-type">uintptr_t</span>) -oldsize, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (oldp), <span class="hljs-number">0</span>))<br>    &#123;<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,<br>               ar_ptr);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">// 检查如果申请最小的 chunk 是否会超过地址上限</span><br>  checked_request2size (bytes, nb);<br> <br>  <span class="hljs-comment">// 如果是 mmap 得到的内存会单独处理</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (oldp))<br>    &#123;<br>      <span class="hljs-type">void</span> *newmem;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_MREMAP</span><br>      <span class="hljs-comment">// 如果是 mmap 得到的内存则利用 mremap 系统调用实现 realloc。</span><br>      <span class="hljs-comment">// mremap 会重新分配一块内存并将之前的数据复制到新的内存上。</span><br>      newp = mremap_chunk (oldp, nb);<br>      <span class="hljs-keyword">if</span> (newp)<br>        <span class="hljs-keyword">return</span> chunk2mem (newp);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-comment">/* Note the extra SIZE_SZ overhead. */</span><br>      <span class="hljs-keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)<br>        <span class="hljs-keyword">return</span> oldmem;                         <span class="hljs-comment">/* do nothing */</span><br> <br>      <span class="hljs-comment">/* Must alloc, copy, free. */</span><br>      <span class="hljs-comment">// 如果 mremap 获取不到所需的内存则通过 malloc 获取内存，并将原先内存的数据复制过来然后 munmap 将原先的内存释放掉</span><br>      newmem = __libc_malloc (bytes);<br>      <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;              <span class="hljs-comment">/* propagate failure */</span><br> <br>      <span class="hljs-built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="hljs-number">2</span> * SIZE_SZ);<br>      munmap_chunk (oldp);<br>      <span class="hljs-keyword">return</span> newmem;<br>    &#125;<br> <br>  (<span class="hljs-type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);<br> <br>  <span class="hljs-comment">// 调用 _int_realloc 调整内存</span><br>  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);<br> <br>  (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">// 检查内存分配后的 3 种情况</span><br>  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (newp)));<br> <br>  <span class="hljs-comment">// 如果 _int_realloc 没有成功则尝试调用 _int_malloc 重新分配内存</span><br>  <span class="hljs-keyword">if</span> (newp == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Try harder to allocate memory in other arenas.  */</span><br>      LIBC_PROBE (memory_realloc_retry, <span class="hljs-number">2</span>, bytes, oldmem);<br>      newp = __libc_malloc (bytes);<br>      <span class="hljs-comment">// 如果 malloc 成功则将数据拷贝后释放原先的内存</span><br>      <span class="hljs-keyword">if</span> (newp != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);<br>          _int_free (ar_ptr, oldp, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br> <br>  <span class="hljs-keyword">return</span> newp;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="int-realloc"><a href="#int-realloc" class="headerlink" title="int_realloc"></a><code>int_realloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// _int_realloc函数用于重新分配内存块。它尝试更改内存块的大小并可能移动它以满足新的大小要求。</span><br><span class="hljs-comment">// 参数:</span><br><span class="hljs-comment">// av - 指向内存状态的指针。</span><br><span class="hljs-comment">// oldp - 指向当前内存块的指针。</span><br><span class="hljs-comment">// oldsize - 当前内存块的大小。</span><br><span class="hljs-comment">// nb - 请求的新大小。</span><br><span class="hljs-type">void</span>* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) &#123;<br>  <span class="hljs-comment">// 定义一系列局部变量来存储分配的状态和中间结果。</span><br>  mchunkptr newp; <span class="hljs-comment">// 新分配的内存块指针。</span><br>  INTERNAL_SIZE_T newsize; <span class="hljs-comment">// 新内存块的大小。</span><br>  <span class="hljs-type">void</span>* newmem; <span class="hljs-comment">// 对应用户内存的指针。</span><br> <br>  mchunkptr next; <span class="hljs-comment">// 指向oldp后面的连续内存块。</span><br> <br>  mchunkptr remainder; <span class="hljs-comment">// 新分配内存后剩余的内存块。</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size; <span class="hljs-comment">// 剩余内存块的大小。</span><br> <br>  mchunkptr bck; <span class="hljs-comment">// 用于链接的临时变量。</span><br>  mchunkptr fwd; <span class="hljs-comment">// 用于链接的临时变量。</span><br> <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> copysize; <span class="hljs-comment">// 需要复制的字节数。</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ncopies; <span class="hljs-comment">// 需要复制的INTERNAL_SIZE_T字数。</span><br>  INTERNAL_SIZE_T* s; <span class="hljs-comment">// 复制源的指针。</span><br>  INTERNAL_SIZE_T* d; <span class="hljs-comment">// 复制目标的指针。</span><br> <br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 用于错误处理的字符串。</span><br> <br>  <span class="hljs-comment">// 检查oldp的大小是否合法。</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect(oldp-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect(oldsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;realloc(): invalid old size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br> <br>  check_inuse_chunk(av, oldp); <span class="hljs-comment">// 检查oldp是否正在使用中。</span><br> <br>  assert(!chunk_is_mmapped(oldp)); <span class="hljs-comment">// 确保oldp不是映射内存。</span><br> <br>  next = chunk_at_offset(oldp, oldsize); <span class="hljs-comment">// 计算下一个内存块的位置。</span><br>  INTERNAL_SIZE_T nextsize = chunksize(next); <span class="hljs-comment">// 获取下一个内存块的大小。</span><br>  <span class="hljs-comment">// 检查下一个内存块的大小是否合法。</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect(next-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;realloc(): invalid next size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br> <br>  <span class="hljs-comment">// 如果当前内存块已经足够大，则直接返回当前内存块。</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(oldsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb)) &#123;<br>    newp = oldp;<br>    newsize = oldsize;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果下一个内存块是 top chunk ，并且可以合并以满足请求的大小，则进行合并。</span><br>    <span class="hljs-keyword">if</span> (next == av-&gt;top &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb + MINSIZE)) &#123;<br>      set_head_size(oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      av-&gt;top = chunk_at_offset(oldp, nb);<br>      set_head(av-&gt;top, (newsize - nb) | PREV_INUSE);<br>      check_inuse_chunk(av, oldp);<br>      <span class="hljs-keyword">return</span> chunk2mem(oldp);<br>    &#125;<br>    <span class="hljs-comment">// 如果下一个内存块不在使用中，并且可以合并以满足请求的大小，则进行合并。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != av-&gt;top &amp;&amp; !inuse(next) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb)) &#123;<br>      newp = oldp;<br>      unlink(av, next, bck, fwd);<br>    &#125;<br>    <span class="hljs-comment">// 否则，分配新内存，复制数据，然后释放旧内存。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK);<br>      <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果分配失败，则返回0。</span><br> <br>      newp = mem2chunk(newmem);<br>      newsize = chunksize(newp);<br> <br>      <span class="hljs-comment">// 如果新分配的内存块紧跟在旧内存块后面，则合并这两个内存块。</span><br>      <span class="hljs-keyword">if</span> (newp == next) &#123;<br>        newsize += oldsize;<br>        newp = oldp;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则，复制旧内存块的内容到新内存块。</span><br>        copysize = oldsize - SIZE_SZ;<br>        s = (INTERNAL_SIZE_T*)(chunk2mem(oldp));<br>        d = (INTERNAL_SIZE_T*)(newmem);<br>        ncopies = copysize / <span class="hljs-keyword">sizeof</span>(INTERNAL_SIZE_T);<br>        assert(ncopies &gt;= <span class="hljs-number">3</span>);<br> <br>        <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">9</span>)<br>          <span class="hljs-built_in">memcpy</span>(d, s, copysize);<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 对于小内存块，使用手动复制以提高效率。</span><br>          *(d + <span class="hljs-number">0</span>) = *(s + <span class="hljs-number">0</span>);<br>          *(d + <span class="hljs-number">1</span>) = *(s + <span class="hljs-number">1</span>);<br>          *(d + <span class="hljs-number">2</span>) = *(s + <span class="hljs-number">2</span>);<br>          <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">4</span>) &#123;<br>            *(d + <span class="hljs-number">3</span>) = *(s + <span class="hljs-number">3</span>);<br>            *(d + <span class="hljs-number">4</span>) = *(s + <span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">6</span>) &#123;<br>              *(d + <span class="hljs-number">5</span>) = *(s + <span class="hljs-number">5</span>);<br>              *(d + <span class="hljs-number">6</span>) = *(s + <span class="hljs-number">6</span>);<br>              <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">8</span>) &#123;<br>                *(d + <span class="hljs-number">7</span>) = *(s + <span class="hljs-number">7</span>);<br>                *(d + <span class="hljs-number">8</span>) = *(s + <span class="hljs-number">8</span>);<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br> <br>        _int_free(av, oldp, <span class="hljs-number">1</span>); <span class="hljs-comment">// 释放旧内存块。</span><br>        check_inuse_chunk(av, newp); <span class="hljs-comment">// 检查新内存块是否正在使用中。</span><br>        <span class="hljs-keyword">return</span> chunk2mem(newp); <span class="hljs-comment">// 返回新内存块的用户可用部分。</span><br>      &#125;<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-comment">// 尝试释放新内存块中的多余空间。</span><br>  assert((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(newsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb));<br>  remainder_size = newsize - nb;<br>  <span class="hljs-comment">// 如果剩余空间太小，无法分割为独立的内存块，则保留它。</span><br>  <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE) &#123;<br>    set_head_size(newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_inuse_bit_at_offset(newp, newsize);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则，分割剩余空间为独立的内存块。</span><br>    remainder = chunk_at_offset(newp, nb);<br>    set_head_size(newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head(remainder, remainder_size | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_inuse_bit_at_offset(remainder, remainder_size); <span class="hljs-comment">// 标记剩余部分为正在使用中，以便_free()不会报错。</span><br>    _int_free(av, remainder, <span class="hljs-number">1</span>); <span class="hljs-comment">// 释放剩余部分。</span><br>  &#125;<br> <br>  check_inuse_chunk(av, newp); <span class="hljs-comment">// 检查新内存块是否正在使用中。</span><br>  <span class="hljs-keyword">return</span> chunk2mem(newp); <span class="hljs-comment">// 返回新内存块的用户可用部分。</span><br>&#125;<br><br></code></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p>参考：ptmalloc内存管理分析<br>参考：看雪pwn探索篇<br>参考：<a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc – sploitF-U-N</a><br>参考：<a target="_blank" rel="noopener" href="https://a1ex.online/2020/09/28/glibc-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0-1">glibc-malloc源码分析 | A1ex’s Blog</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CTF/" class="category-chain-item">CTF</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Heap/" class="print-no-link">#Heap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Ptmalloc2内存管理分析</div>
      <div>http://nanhang.top/2025/07/01/ctf/heap/ptmalloc/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>南行</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/01/ctf/heter/mips/" title="MIPS Pwn">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MIPS Pwn</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/01/ctf/heap/io-file/" title="IO_FILE利用入门">
                        <span class="hidden-mobile">IO_FILE利用入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
